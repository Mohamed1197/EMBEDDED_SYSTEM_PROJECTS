
Free_RTOS_TEST.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005006  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000026  00800060  00005006  0000509a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000048c  00800086  00800086  000050c0  2**0
                  ALLOC
  3 .stab         00005eb0  00000000  00000000  000050c0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000030ae  00000000  00000000  0000af70  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  0000e01e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000018f  00000000  00000000  0000e17e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002045  00000000  00000000  0000e30d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001101  00000000  00000000  00010352  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f82  00000000  00000000  00011453  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  000123d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002c2  00000000  00000000  00012558  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000088e  00000000  00000000  0001281a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000130a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 1a 1c 	jmp	0x3834	; 0x3834 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e0       	ldi	r30, 0x06	; 6
      68:	f0 e5       	ldi	r31, 0x50	; 80
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 38       	cpi	r26, 0x86	; 134
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a6 e8       	ldi	r26, 0x86	; 134
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 31       	cpi	r26, 0x12	; 18
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 3b 18 	call	0x3076	; 0x3076 <main>
      8a:	0c 94 01 28 	jmp	0x5002	; 0x5002 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ab 27 	jmp	0x4f56	; 0x4f56 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ab e7       	ldi	r26, 0x7B	; 123
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 c7 27 	jmp	0x4f8e	; 0x4f8e <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 b7 27 	jmp	0x4f6e	; 0x4f6e <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 d3 27 	jmp	0x4fa6	; 0x4fa6 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 b7 27 	jmp	0x4f6e	; 0x4f6e <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 d3 27 	jmp	0x4fa6	; 0x4fa6 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ab 27 	jmp	0x4f56	; 0x4f56 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8b e7       	ldi	r24, 0x7B	; 123
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 c7 27 	jmp	0x4f8e	; 0x4f8e <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 b3 27 	jmp	0x4f66	; 0x4f66 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6b e7       	ldi	r22, 0x7B	; 123
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 a9 04 	call	0x952	; 0x952 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 cf 27 	jmp	0x4f9e	; 0x4f9e <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 b7 27 	jmp	0x4f6e	; 0x4f6e <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 d3 27 	jmp	0x4fa6	; 0x4fa6 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 b7 27 	jmp	0x4f6e	; 0x4f6e <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 d3 27 	jmp	0x4fa6	; 0x4fa6 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 b7 27 	jmp	0x4f6e	; 0x4f6e <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 f6 05 	call	0xbec	; 0xbec <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 d3 27 	jmp	0x4fa6	; 0x4fa6 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 bb 27 	jmp	0x4f76	; 0x4f76 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 7e 05 	call	0xafc	; 0xafc <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 d7 27 	jmp	0x4fae	; 0x4fae <__epilogue_restores__+0x20>

00000952 <__pack_f>:
     952:	df 92       	push	r13
     954:	ef 92       	push	r14
     956:	ff 92       	push	r15
     958:	0f 93       	push	r16
     95a:	1f 93       	push	r17
     95c:	fc 01       	movw	r30, r24
     95e:	e4 80       	ldd	r14, Z+4	; 0x04
     960:	f5 80       	ldd	r15, Z+5	; 0x05
     962:	06 81       	ldd	r16, Z+6	; 0x06
     964:	17 81       	ldd	r17, Z+7	; 0x07
     966:	d1 80       	ldd	r13, Z+1	; 0x01
     968:	80 81       	ld	r24, Z
     96a:	82 30       	cpi	r24, 0x02	; 2
     96c:	48 f4       	brcc	.+18     	; 0x980 <__pack_f+0x2e>
     96e:	80 e0       	ldi	r24, 0x00	; 0
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	a0 e1       	ldi	r26, 0x10	; 16
     974:	b0 e0       	ldi	r27, 0x00	; 0
     976:	e8 2a       	or	r14, r24
     978:	f9 2a       	or	r15, r25
     97a:	0a 2b       	or	r16, r26
     97c:	1b 2b       	or	r17, r27
     97e:	a5 c0       	rjmp	.+330    	; 0xaca <__pack_f+0x178>
     980:	84 30       	cpi	r24, 0x04	; 4
     982:	09 f4       	brne	.+2      	; 0x986 <__pack_f+0x34>
     984:	9f c0       	rjmp	.+318    	; 0xac4 <__pack_f+0x172>
     986:	82 30       	cpi	r24, 0x02	; 2
     988:	21 f4       	brne	.+8      	; 0x992 <__pack_f+0x40>
     98a:	ee 24       	eor	r14, r14
     98c:	ff 24       	eor	r15, r15
     98e:	87 01       	movw	r16, r14
     990:	05 c0       	rjmp	.+10     	; 0x99c <__pack_f+0x4a>
     992:	e1 14       	cp	r14, r1
     994:	f1 04       	cpc	r15, r1
     996:	01 05       	cpc	r16, r1
     998:	11 05       	cpc	r17, r1
     99a:	19 f4       	brne	.+6      	; 0x9a2 <__pack_f+0x50>
     99c:	e0 e0       	ldi	r30, 0x00	; 0
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	96 c0       	rjmp	.+300    	; 0xace <__pack_f+0x17c>
     9a2:	62 81       	ldd	r22, Z+2	; 0x02
     9a4:	73 81       	ldd	r23, Z+3	; 0x03
     9a6:	9f ef       	ldi	r25, 0xFF	; 255
     9a8:	62 38       	cpi	r22, 0x82	; 130
     9aa:	79 07       	cpc	r23, r25
     9ac:	0c f0       	brlt	.+2      	; 0x9b0 <__pack_f+0x5e>
     9ae:	5b c0       	rjmp	.+182    	; 0xa66 <__pack_f+0x114>
     9b0:	22 e8       	ldi	r18, 0x82	; 130
     9b2:	3f ef       	ldi	r19, 0xFF	; 255
     9b4:	26 1b       	sub	r18, r22
     9b6:	37 0b       	sbc	r19, r23
     9b8:	2a 31       	cpi	r18, 0x1A	; 26
     9ba:	31 05       	cpc	r19, r1
     9bc:	2c f0       	brlt	.+10     	; 0x9c8 <__pack_f+0x76>
     9be:	20 e0       	ldi	r18, 0x00	; 0
     9c0:	30 e0       	ldi	r19, 0x00	; 0
     9c2:	40 e0       	ldi	r20, 0x00	; 0
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	2a c0       	rjmp	.+84     	; 0xa1c <__pack_f+0xca>
     9c8:	b8 01       	movw	r22, r16
     9ca:	a7 01       	movw	r20, r14
     9cc:	02 2e       	mov	r0, r18
     9ce:	04 c0       	rjmp	.+8      	; 0x9d8 <__pack_f+0x86>
     9d0:	76 95       	lsr	r23
     9d2:	67 95       	ror	r22
     9d4:	57 95       	ror	r21
     9d6:	47 95       	ror	r20
     9d8:	0a 94       	dec	r0
     9da:	d2 f7       	brpl	.-12     	; 0x9d0 <__pack_f+0x7e>
     9dc:	81 e0       	ldi	r24, 0x01	; 1
     9de:	90 e0       	ldi	r25, 0x00	; 0
     9e0:	a0 e0       	ldi	r26, 0x00	; 0
     9e2:	b0 e0       	ldi	r27, 0x00	; 0
     9e4:	04 c0       	rjmp	.+8      	; 0x9ee <__pack_f+0x9c>
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	aa 1f       	adc	r26, r26
     9ec:	bb 1f       	adc	r27, r27
     9ee:	2a 95       	dec	r18
     9f0:	d2 f7       	brpl	.-12     	; 0x9e6 <__pack_f+0x94>
     9f2:	01 97       	sbiw	r24, 0x01	; 1
     9f4:	a1 09       	sbc	r26, r1
     9f6:	b1 09       	sbc	r27, r1
     9f8:	8e 21       	and	r24, r14
     9fa:	9f 21       	and	r25, r15
     9fc:	a0 23       	and	r26, r16
     9fe:	b1 23       	and	r27, r17
     a00:	00 97       	sbiw	r24, 0x00	; 0
     a02:	a1 05       	cpc	r26, r1
     a04:	b1 05       	cpc	r27, r1
     a06:	21 f0       	breq	.+8      	; 0xa10 <__pack_f+0xbe>
     a08:	81 e0       	ldi	r24, 0x01	; 1
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e0       	ldi	r26, 0x00	; 0
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	9a 01       	movw	r18, r20
     a12:	ab 01       	movw	r20, r22
     a14:	28 2b       	or	r18, r24
     a16:	39 2b       	or	r19, r25
     a18:	4a 2b       	or	r20, r26
     a1a:	5b 2b       	or	r21, r27
     a1c:	da 01       	movw	r26, r20
     a1e:	c9 01       	movw	r24, r18
     a20:	8f 77       	andi	r24, 0x7F	; 127
     a22:	90 70       	andi	r25, 0x00	; 0
     a24:	a0 70       	andi	r26, 0x00	; 0
     a26:	b0 70       	andi	r27, 0x00	; 0
     a28:	80 34       	cpi	r24, 0x40	; 64
     a2a:	91 05       	cpc	r25, r1
     a2c:	a1 05       	cpc	r26, r1
     a2e:	b1 05       	cpc	r27, r1
     a30:	39 f4       	brne	.+14     	; 0xa40 <__pack_f+0xee>
     a32:	27 ff       	sbrs	r18, 7
     a34:	09 c0       	rjmp	.+18     	; 0xa48 <__pack_f+0xf6>
     a36:	20 5c       	subi	r18, 0xC0	; 192
     a38:	3f 4f       	sbci	r19, 0xFF	; 255
     a3a:	4f 4f       	sbci	r20, 0xFF	; 255
     a3c:	5f 4f       	sbci	r21, 0xFF	; 255
     a3e:	04 c0       	rjmp	.+8      	; 0xa48 <__pack_f+0xf6>
     a40:	21 5c       	subi	r18, 0xC1	; 193
     a42:	3f 4f       	sbci	r19, 0xFF	; 255
     a44:	4f 4f       	sbci	r20, 0xFF	; 255
     a46:	5f 4f       	sbci	r21, 0xFF	; 255
     a48:	e0 e0       	ldi	r30, 0x00	; 0
     a4a:	f0 e0       	ldi	r31, 0x00	; 0
     a4c:	20 30       	cpi	r18, 0x00	; 0
     a4e:	a0 e0       	ldi	r26, 0x00	; 0
     a50:	3a 07       	cpc	r19, r26
     a52:	a0 e0       	ldi	r26, 0x00	; 0
     a54:	4a 07       	cpc	r20, r26
     a56:	a0 e4       	ldi	r26, 0x40	; 64
     a58:	5a 07       	cpc	r21, r26
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <__pack_f+0x10e>
     a5c:	e1 e0       	ldi	r30, 0x01	; 1
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	79 01       	movw	r14, r18
     a62:	8a 01       	movw	r16, r20
     a64:	27 c0       	rjmp	.+78     	; 0xab4 <__pack_f+0x162>
     a66:	60 38       	cpi	r22, 0x80	; 128
     a68:	71 05       	cpc	r23, r1
     a6a:	64 f5       	brge	.+88     	; 0xac4 <__pack_f+0x172>
     a6c:	fb 01       	movw	r30, r22
     a6e:	e1 58       	subi	r30, 0x81	; 129
     a70:	ff 4f       	sbci	r31, 0xFF	; 255
     a72:	d8 01       	movw	r26, r16
     a74:	c7 01       	movw	r24, r14
     a76:	8f 77       	andi	r24, 0x7F	; 127
     a78:	90 70       	andi	r25, 0x00	; 0
     a7a:	a0 70       	andi	r26, 0x00	; 0
     a7c:	b0 70       	andi	r27, 0x00	; 0
     a7e:	80 34       	cpi	r24, 0x40	; 64
     a80:	91 05       	cpc	r25, r1
     a82:	a1 05       	cpc	r26, r1
     a84:	b1 05       	cpc	r27, r1
     a86:	39 f4       	brne	.+14     	; 0xa96 <__pack_f+0x144>
     a88:	e7 fe       	sbrs	r14, 7
     a8a:	0d c0       	rjmp	.+26     	; 0xaa6 <__pack_f+0x154>
     a8c:	80 e4       	ldi	r24, 0x40	; 64
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	a0 e0       	ldi	r26, 0x00	; 0
     a92:	b0 e0       	ldi	r27, 0x00	; 0
     a94:	04 c0       	rjmp	.+8      	; 0xa9e <__pack_f+0x14c>
     a96:	8f e3       	ldi	r24, 0x3F	; 63
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	e8 0e       	add	r14, r24
     aa0:	f9 1e       	adc	r15, r25
     aa2:	0a 1f       	adc	r16, r26
     aa4:	1b 1f       	adc	r17, r27
     aa6:	17 ff       	sbrs	r17, 7
     aa8:	05 c0       	rjmp	.+10     	; 0xab4 <__pack_f+0x162>
     aaa:	16 95       	lsr	r17
     aac:	07 95       	ror	r16
     aae:	f7 94       	ror	r15
     ab0:	e7 94       	ror	r14
     ab2:	31 96       	adiw	r30, 0x01	; 1
     ab4:	87 e0       	ldi	r24, 0x07	; 7
     ab6:	16 95       	lsr	r17
     ab8:	07 95       	ror	r16
     aba:	f7 94       	ror	r15
     abc:	e7 94       	ror	r14
     abe:	8a 95       	dec	r24
     ac0:	d1 f7       	brne	.-12     	; 0xab6 <__pack_f+0x164>
     ac2:	05 c0       	rjmp	.+10     	; 0xace <__pack_f+0x17c>
     ac4:	ee 24       	eor	r14, r14
     ac6:	ff 24       	eor	r15, r15
     ac8:	87 01       	movw	r16, r14
     aca:	ef ef       	ldi	r30, 0xFF	; 255
     acc:	f0 e0       	ldi	r31, 0x00	; 0
     ace:	6e 2f       	mov	r22, r30
     ad0:	67 95       	ror	r22
     ad2:	66 27       	eor	r22, r22
     ad4:	67 95       	ror	r22
     ad6:	90 2f       	mov	r25, r16
     ad8:	9f 77       	andi	r25, 0x7F	; 127
     ada:	d7 94       	ror	r13
     adc:	dd 24       	eor	r13, r13
     ade:	d7 94       	ror	r13
     ae0:	8e 2f       	mov	r24, r30
     ae2:	86 95       	lsr	r24
     ae4:	49 2f       	mov	r20, r25
     ae6:	46 2b       	or	r20, r22
     ae8:	58 2f       	mov	r21, r24
     aea:	5d 29       	or	r21, r13
     aec:	b7 01       	movw	r22, r14
     aee:	ca 01       	movw	r24, r20
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	08 95       	ret

00000afc <__unpack_f>:
     afc:	fc 01       	movw	r30, r24
     afe:	db 01       	movw	r26, r22
     b00:	40 81       	ld	r20, Z
     b02:	51 81       	ldd	r21, Z+1	; 0x01
     b04:	22 81       	ldd	r18, Z+2	; 0x02
     b06:	62 2f       	mov	r22, r18
     b08:	6f 77       	andi	r22, 0x7F	; 127
     b0a:	70 e0       	ldi	r23, 0x00	; 0
     b0c:	22 1f       	adc	r18, r18
     b0e:	22 27       	eor	r18, r18
     b10:	22 1f       	adc	r18, r18
     b12:	93 81       	ldd	r25, Z+3	; 0x03
     b14:	89 2f       	mov	r24, r25
     b16:	88 0f       	add	r24, r24
     b18:	82 2b       	or	r24, r18
     b1a:	28 2f       	mov	r18, r24
     b1c:	30 e0       	ldi	r19, 0x00	; 0
     b1e:	99 1f       	adc	r25, r25
     b20:	99 27       	eor	r25, r25
     b22:	99 1f       	adc	r25, r25
     b24:	11 96       	adiw	r26, 0x01	; 1
     b26:	9c 93       	st	X, r25
     b28:	11 97       	sbiw	r26, 0x01	; 1
     b2a:	21 15       	cp	r18, r1
     b2c:	31 05       	cpc	r19, r1
     b2e:	a9 f5       	brne	.+106    	; 0xb9a <__unpack_f+0x9e>
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	61 05       	cpc	r22, r1
     b36:	71 05       	cpc	r23, r1
     b38:	11 f4       	brne	.+4      	; 0xb3e <__unpack_f+0x42>
     b3a:	82 e0       	ldi	r24, 0x02	; 2
     b3c:	37 c0       	rjmp	.+110    	; 0xbac <__unpack_f+0xb0>
     b3e:	82 e8       	ldi	r24, 0x82	; 130
     b40:	9f ef       	ldi	r25, 0xFF	; 255
     b42:	13 96       	adiw	r26, 0x03	; 3
     b44:	9c 93       	st	X, r25
     b46:	8e 93       	st	-X, r24
     b48:	12 97       	sbiw	r26, 0x02	; 2
     b4a:	9a 01       	movw	r18, r20
     b4c:	ab 01       	movw	r20, r22
     b4e:	67 e0       	ldi	r22, 0x07	; 7
     b50:	22 0f       	add	r18, r18
     b52:	33 1f       	adc	r19, r19
     b54:	44 1f       	adc	r20, r20
     b56:	55 1f       	adc	r21, r21
     b58:	6a 95       	dec	r22
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__unpack_f+0x54>
     b5c:	83 e0       	ldi	r24, 0x03	; 3
     b5e:	8c 93       	st	X, r24
     b60:	0d c0       	rjmp	.+26     	; 0xb7c <__unpack_f+0x80>
     b62:	22 0f       	add	r18, r18
     b64:	33 1f       	adc	r19, r19
     b66:	44 1f       	adc	r20, r20
     b68:	55 1f       	adc	r21, r21
     b6a:	12 96       	adiw	r26, 0x02	; 2
     b6c:	8d 91       	ld	r24, X+
     b6e:	9c 91       	ld	r25, X
     b70:	13 97       	sbiw	r26, 0x03	; 3
     b72:	01 97       	sbiw	r24, 0x01	; 1
     b74:	13 96       	adiw	r26, 0x03	; 3
     b76:	9c 93       	st	X, r25
     b78:	8e 93       	st	-X, r24
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	20 30       	cpi	r18, 0x00	; 0
     b7e:	80 e0       	ldi	r24, 0x00	; 0
     b80:	38 07       	cpc	r19, r24
     b82:	80 e0       	ldi	r24, 0x00	; 0
     b84:	48 07       	cpc	r20, r24
     b86:	80 e4       	ldi	r24, 0x40	; 64
     b88:	58 07       	cpc	r21, r24
     b8a:	58 f3       	brcs	.-42     	; 0xb62 <__unpack_f+0x66>
     b8c:	14 96       	adiw	r26, 0x04	; 4
     b8e:	2d 93       	st	X+, r18
     b90:	3d 93       	st	X+, r19
     b92:	4d 93       	st	X+, r20
     b94:	5c 93       	st	X, r21
     b96:	17 97       	sbiw	r26, 0x07	; 7
     b98:	08 95       	ret
     b9a:	2f 3f       	cpi	r18, 0xFF	; 255
     b9c:	31 05       	cpc	r19, r1
     b9e:	79 f4       	brne	.+30     	; 0xbbe <__unpack_f+0xc2>
     ba0:	41 15       	cp	r20, r1
     ba2:	51 05       	cpc	r21, r1
     ba4:	61 05       	cpc	r22, r1
     ba6:	71 05       	cpc	r23, r1
     ba8:	19 f4       	brne	.+6      	; 0xbb0 <__unpack_f+0xb4>
     baa:	84 e0       	ldi	r24, 0x04	; 4
     bac:	8c 93       	st	X, r24
     bae:	08 95       	ret
     bb0:	64 ff       	sbrs	r22, 4
     bb2:	03 c0       	rjmp	.+6      	; 0xbba <__unpack_f+0xbe>
     bb4:	81 e0       	ldi	r24, 0x01	; 1
     bb6:	8c 93       	st	X, r24
     bb8:	12 c0       	rjmp	.+36     	; 0xbde <__unpack_f+0xe2>
     bba:	1c 92       	st	X, r1
     bbc:	10 c0       	rjmp	.+32     	; 0xbde <__unpack_f+0xe2>
     bbe:	2f 57       	subi	r18, 0x7F	; 127
     bc0:	30 40       	sbci	r19, 0x00	; 0
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	3c 93       	st	X, r19
     bc6:	2e 93       	st	-X, r18
     bc8:	12 97       	sbiw	r26, 0x02	; 2
     bca:	83 e0       	ldi	r24, 0x03	; 3
     bcc:	8c 93       	st	X, r24
     bce:	87 e0       	ldi	r24, 0x07	; 7
     bd0:	44 0f       	add	r20, r20
     bd2:	55 1f       	adc	r21, r21
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	8a 95       	dec	r24
     bda:	d1 f7       	brne	.-12     	; 0xbd0 <__unpack_f+0xd4>
     bdc:	70 64       	ori	r23, 0x40	; 64
     bde:	14 96       	adiw	r26, 0x04	; 4
     be0:	4d 93       	st	X+, r20
     be2:	5d 93       	st	X+, r21
     be4:	6d 93       	st	X+, r22
     be6:	7c 93       	st	X, r23
     be8:	17 97       	sbiw	r26, 0x07	; 7
     bea:	08 95       	ret

00000bec <__fpcmp_parts_f>:
     bec:	1f 93       	push	r17
     bee:	dc 01       	movw	r26, r24
     bf0:	fb 01       	movw	r30, r22
     bf2:	9c 91       	ld	r25, X
     bf4:	92 30       	cpi	r25, 0x02	; 2
     bf6:	08 f4       	brcc	.+2      	; 0xbfa <__fpcmp_parts_f+0xe>
     bf8:	47 c0       	rjmp	.+142    	; 0xc88 <__fpcmp_parts_f+0x9c>
     bfa:	80 81       	ld	r24, Z
     bfc:	82 30       	cpi	r24, 0x02	; 2
     bfe:	08 f4       	brcc	.+2      	; 0xc02 <__fpcmp_parts_f+0x16>
     c00:	43 c0       	rjmp	.+134    	; 0xc88 <__fpcmp_parts_f+0x9c>
     c02:	94 30       	cpi	r25, 0x04	; 4
     c04:	51 f4       	brne	.+20     	; 0xc1a <__fpcmp_parts_f+0x2e>
     c06:	11 96       	adiw	r26, 0x01	; 1
     c08:	1c 91       	ld	r17, X
     c0a:	84 30       	cpi	r24, 0x04	; 4
     c0c:	99 f5       	brne	.+102    	; 0xc74 <__fpcmp_parts_f+0x88>
     c0e:	81 81       	ldd	r24, Z+1	; 0x01
     c10:	68 2f       	mov	r22, r24
     c12:	70 e0       	ldi	r23, 0x00	; 0
     c14:	61 1b       	sub	r22, r17
     c16:	71 09       	sbc	r23, r1
     c18:	3f c0       	rjmp	.+126    	; 0xc98 <__fpcmp_parts_f+0xac>
     c1a:	84 30       	cpi	r24, 0x04	; 4
     c1c:	21 f0       	breq	.+8      	; 0xc26 <__fpcmp_parts_f+0x3a>
     c1e:	92 30       	cpi	r25, 0x02	; 2
     c20:	31 f4       	brne	.+12     	; 0xc2e <__fpcmp_parts_f+0x42>
     c22:	82 30       	cpi	r24, 0x02	; 2
     c24:	b9 f1       	breq	.+110    	; 0xc94 <__fpcmp_parts_f+0xa8>
     c26:	81 81       	ldd	r24, Z+1	; 0x01
     c28:	88 23       	and	r24, r24
     c2a:	89 f1       	breq	.+98     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c2c:	2d c0       	rjmp	.+90     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c2e:	11 96       	adiw	r26, 0x01	; 1
     c30:	1c 91       	ld	r17, X
     c32:	11 97       	sbiw	r26, 0x01	; 1
     c34:	82 30       	cpi	r24, 0x02	; 2
     c36:	f1 f0       	breq	.+60     	; 0xc74 <__fpcmp_parts_f+0x88>
     c38:	81 81       	ldd	r24, Z+1	; 0x01
     c3a:	18 17       	cp	r17, r24
     c3c:	d9 f4       	brne	.+54     	; 0xc74 <__fpcmp_parts_f+0x88>
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	2d 91       	ld	r18, X+
     c42:	3c 91       	ld	r19, X
     c44:	13 97       	sbiw	r26, 0x03	; 3
     c46:	82 81       	ldd	r24, Z+2	; 0x02
     c48:	93 81       	ldd	r25, Z+3	; 0x03
     c4a:	82 17       	cp	r24, r18
     c4c:	93 07       	cpc	r25, r19
     c4e:	94 f0       	brlt	.+36     	; 0xc74 <__fpcmp_parts_f+0x88>
     c50:	28 17       	cp	r18, r24
     c52:	39 07       	cpc	r19, r25
     c54:	bc f0       	brlt	.+46     	; 0xc84 <__fpcmp_parts_f+0x98>
     c56:	14 96       	adiw	r26, 0x04	; 4
     c58:	8d 91       	ld	r24, X+
     c5a:	9d 91       	ld	r25, X+
     c5c:	0d 90       	ld	r0, X+
     c5e:	bc 91       	ld	r27, X
     c60:	a0 2d       	mov	r26, r0
     c62:	24 81       	ldd	r18, Z+4	; 0x04
     c64:	35 81       	ldd	r19, Z+5	; 0x05
     c66:	46 81       	ldd	r20, Z+6	; 0x06
     c68:	57 81       	ldd	r21, Z+7	; 0x07
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	4a 07       	cpc	r20, r26
     c70:	5b 07       	cpc	r21, r27
     c72:	18 f4       	brcc	.+6      	; 0xc7a <__fpcmp_parts_f+0x8e>
     c74:	11 23       	and	r17, r17
     c76:	41 f0       	breq	.+16     	; 0xc88 <__fpcmp_parts_f+0x9c>
     c78:	0a c0       	rjmp	.+20     	; 0xc8e <__fpcmp_parts_f+0xa2>
     c7a:	82 17       	cp	r24, r18
     c7c:	93 07       	cpc	r25, r19
     c7e:	a4 07       	cpc	r26, r20
     c80:	b5 07       	cpc	r27, r21
     c82:	40 f4       	brcc	.+16     	; 0xc94 <__fpcmp_parts_f+0xa8>
     c84:	11 23       	and	r17, r17
     c86:	19 f0       	breq	.+6      	; 0xc8e <__fpcmp_parts_f+0xa2>
     c88:	61 e0       	ldi	r22, 0x01	; 1
     c8a:	70 e0       	ldi	r23, 0x00	; 0
     c8c:	05 c0       	rjmp	.+10     	; 0xc98 <__fpcmp_parts_f+0xac>
     c8e:	6f ef       	ldi	r22, 0xFF	; 255
     c90:	7f ef       	ldi	r23, 0xFF	; 255
     c92:	02 c0       	rjmp	.+4      	; 0xc98 <__fpcmp_parts_f+0xac>
     c94:	60 e0       	ldi	r22, 0x00	; 0
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	cb 01       	movw	r24, r22
     c9a:	1f 91       	pop	r17
     c9c:	08 95       	ret

00000c9e <DIO_u8Init>:
#include "DIO_interface.h"
#include "DIO_private.h"
#include "DIO_config.h"

u8 DIO_u8Init            (void)
{
     c9e:	df 93       	push	r29
     ca0:	cf 93       	push	r28
     ca2:	0f 92       	push	r0
     ca4:	cd b7       	in	r28, 0x3d	; 61
     ca6:	de b7       	in	r29, 0x3e	; 62
     DDRA_u8_REG = CONC(DIO_u8_PA7_INITIAL_DIRECTION,DIO_u8_PA6_INITIAL_DIRECTION,DIO_u8_PA5_INITIAL_DIRECTION,DIO_u8_PA4_INITIAL_DIRECTION,
     ca8:	ea e3       	ldi	r30, 0x3A	; 58
     caa:	f0 e0       	ldi	r31, 0x00	; 0
     cac:	10 82       	st	Z, r1
	                    DIO_u8_PA3_INITIAL_DIRECTION,DIO_u8_PA2_INITIAL_DIRECTION,DIO_u8_PA1_INITIAL_DIRECTION,DIO_u8_PA0_INITIAL_DIRECTION); 
     
	 DDRB_u8_REG = CONC(DIO_u8_PB7_INITIAL_DIRECTION,DIO_u8_PB6_INITIAL_DIRECTION,DIO_u8_PB5_INITIAL_DIRECTION,DIO_u8_PB4_INITIAL_DIRECTION,
     cae:	e7 e3       	ldi	r30, 0x37	; 55
     cb0:	f0 e0       	ldi	r31, 0x00	; 0
     cb2:	87 e0       	ldi	r24, 0x07	; 7
     cb4:	80 83       	st	Z, r24
	                    DIO_u8_PB3_INITIAL_DIRECTION,DIO_u8_PB2_INITIAL_DIRECTION,DIO_u8_PB1_INITIAL_DIRECTION,DIO_u8_PB0_INITIAL_DIRECTION); 
     
	 DDRC_u8_REG = CONC(DIO_u8_PC7_INITIAL_DIRECTION,DIO_u8_PC6_INITIAL_DIRECTION,DIO_u8_PC5_INITIAL_DIRECTION,DIO_u8_PC4_INITIAL_DIRECTION,
     cb6:	e4 e3       	ldi	r30, 0x34	; 52
     cb8:	f0 e0       	ldi	r31, 0x00	; 0
     cba:	80 ee       	ldi	r24, 0xE0	; 224
     cbc:	80 83       	st	Z, r24
	                    DIO_u8_PC3_INITIAL_DIRECTION,DIO_u8_PC2_INITIAL_DIRECTION,DIO_u8_PC1_INITIAL_DIRECTION,DIO_u8_PC0_INITIAL_DIRECTION); 
     
	 DDRD_u8_REG = CONC(DIO_u8_PD7_INITIAL_DIRECTION,DIO_u8_PD6_INITIAL_DIRECTION,DIO_u8_PD5_INITIAL_DIRECTION,DIO_u8_PD4_INITIAL_DIRECTION,
     cbe:	e1 e3       	ldi	r30, 0x31	; 49
     cc0:	f0 e0       	ldi	r31, 0x00	; 0
     cc2:	8f ef       	ldi	r24, 0xFF	; 255
     cc4:	80 83       	st	Z, r24
	                    DIO_u8_PD3_INITIAL_DIRECTION,DIO_u8_PD2_INITIAL_DIRECTION,DIO_u8_PD1_INITIAL_DIRECTION,DIO_u8_PD0_INITIAL_DIRECTION); 
    /*Initial values for pins */
     PORTA_u8_REG = CONC(DIO_u8_PA7_INITIAL_VALUE,DIO_u8_PA6_INITIAL_VALUE,DIO_u8_PA5_INITIAL_VALUE,DIO_u8_PA4_INITIAL_VALUE,
     cc6:	eb e3       	ldi	r30, 0x3B	; 59
     cc8:	f0 e0       	ldi	r31, 0x00	; 0
     cca:	10 82       	st	Z, r1
	                     DIO_u8_PA3_INITIAL_VALUE,DIO_u8_PA2_INITIAL_VALUE,DIO_u8_PA1_INITIAL_VALUE,DIO_u8_PA0_INITIAL_VALUE); 
																											   
	 PORTB_u8_REG = CONC(DIO_u8_PB7_INITIAL_VALUE,DIO_u8_PB6_INITIAL_VALUE,DIO_u8_PB5_INITIAL_VALUE,DIO_u8_PB4_INITIAL_VALUE,
     ccc:	e8 e3       	ldi	r30, 0x38	; 56
     cce:	f0 e0       	ldi	r31, 0x00	; 0
     cd0:	10 82       	st	Z, r1
	                     DIO_u8_PB3_INITIAL_VALUE,DIO_u8_PB2_INITIAL_VALUE,DIO_u8_PB1_INITIAL_VALUE,DIO_u8_PB0_INITIAL_VALUE); 
																											   
	 PORTC_u8_REG = CONC(DIO_u8_PC7_INITIAL_VALUE,DIO_u8_PC6_INITIAL_VALUE,DIO_u8_PC5_INITIAL_VALUE,DIO_u8_PC4_INITIAL_VALUE,
     cd2:	e5 e3       	ldi	r30, 0x35	; 53
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	10 82       	st	Z, r1
	                     DIO_u8_PC3_INITIAL_VALUE,DIO_u8_PC2_INITIAL_VALUE,DIO_u8_PC1_INITIAL_VALUE,DIO_u8_PC0_INITIAL_VALUE); 
																											   
	 PORTD_u8_REG = CONC(DIO_u8_PD7_INITIAL_VALUE,DIO_u8_PD6_INITIAL_VALUE,DIO_u8_PD5_INITIAL_VALUE,DIO_u8_PD4_INITIAL_VALUE,
     cd8:	e2 e3       	ldi	r30, 0x32	; 50
     cda:	f0 e0       	ldi	r31, 0x00	; 0
     cdc:	10 82       	st	Z, r1
	                     DIO_u8_PD3_INITIAL_VALUE,DIO_u8_PD2_INITIAL_VALUE,DIO_u8_PD1_INITIAL_VALUE,DIO_u8_PD0_INITIAL_VALUE);

}
     cde:	0f 90       	pop	r0
     ce0:	cf 91       	pop	r28
     ce2:	df 91       	pop	r29
     ce4:	08 95       	ret

00000ce6 <DIO_u8SetPinDirection>:

u8 DIO_u8SetPinDirection (u8 Copy_u8PortID, u8 Copy_u8PinID, u8 Copy_u8PinDirection)
{
     ce6:	df 93       	push	r29
     ce8:	cf 93       	push	r28
     cea:	cd b7       	in	r28, 0x3d	; 61
     cec:	de b7       	in	r29, 0x3e	; 62
     cee:	2e 97       	sbiw	r28, 0x0e	; 14
     cf0:	0f b6       	in	r0, 0x3f	; 63
     cf2:	f8 94       	cli
     cf4:	de bf       	out	0x3e, r29	; 62
     cf6:	0f be       	out	0x3f, r0	; 63
     cf8:	cd bf       	out	0x3d, r28	; 61
     cfa:	8a 83       	std	Y+2, r24	; 0x02
     cfc:	6b 83       	std	Y+3, r22	; 0x03
     cfe:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ReturnState = STD_TYPES_OK;
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	89 83       	std	Y+1, r24	; 0x01
	/* Check 1- Valid Port  ID
	         2- Valid Pin ID
			 3- Valid Pin Direction */
    if((Copy_u8PortID <= DIO_u8_PORTD) && (Copy_u8PinID <= DIO_u8_PIN7) && ((Copy_u8PinDirection == DIO_u8_INPUT) || (Copy_u8PinDirection == DIO_u8_OUTPUT)))
     d04:	8a 81       	ldd	r24, Y+2	; 0x02
     d06:	84 30       	cpi	r24, 0x04	; 4
     d08:	08 f0       	brcs	.+2      	; 0xd0c <DIO_u8SetPinDirection+0x26>
     d0a:	0c c1       	rjmp	.+536    	; 0xf24 <DIO_u8SetPinDirection+0x23e>
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	88 30       	cpi	r24, 0x08	; 8
     d10:	08 f0       	brcs	.+2      	; 0xd14 <DIO_u8SetPinDirection+0x2e>
     d12:	08 c1       	rjmp	.+528    	; 0xf24 <DIO_u8SetPinDirection+0x23e>
     d14:	8c 81       	ldd	r24, Y+4	; 0x04
     d16:	88 23       	and	r24, r24
     d18:	21 f0       	breq	.+8      	; 0xd22 <DIO_u8SetPinDirection+0x3c>
     d1a:	8c 81       	ldd	r24, Y+4	; 0x04
     d1c:	81 30       	cpi	r24, 0x01	; 1
     d1e:	09 f0       	breq	.+2      	; 0xd22 <DIO_u8SetPinDirection+0x3c>
     d20:	01 c1       	rjmp	.+514    	; 0xf24 <DIO_u8SetPinDirection+0x23e>
	{
		switch(Copy_u8PortID)
     d22:	8a 81       	ldd	r24, Y+2	; 0x02
     d24:	28 2f       	mov	r18, r24
     d26:	30 e0       	ldi	r19, 0x00	; 0
     d28:	3e 87       	std	Y+14, r19	; 0x0e
     d2a:	2d 87       	std	Y+13, r18	; 0x0d
     d2c:	8d 85       	ldd	r24, Y+13	; 0x0d
     d2e:	9e 85       	ldd	r25, Y+14	; 0x0e
     d30:	81 30       	cpi	r24, 0x01	; 1
     d32:	91 05       	cpc	r25, r1
     d34:	09 f4       	brne	.+2      	; 0xd38 <DIO_u8SetPinDirection+0x52>
     d36:	4f c0       	rjmp	.+158    	; 0xdd6 <DIO_u8SetPinDirection+0xf0>
     d38:	2d 85       	ldd	r18, Y+13	; 0x0d
     d3a:	3e 85       	ldd	r19, Y+14	; 0x0e
     d3c:	22 30       	cpi	r18, 0x02	; 2
     d3e:	31 05       	cpc	r19, r1
     d40:	2c f4       	brge	.+10     	; 0xd4c <DIO_u8SetPinDirection+0x66>
     d42:	8d 85       	ldd	r24, Y+13	; 0x0d
     d44:	9e 85       	ldd	r25, Y+14	; 0x0e
     d46:	00 97       	sbiw	r24, 0x00	; 0
     d48:	71 f0       	breq	.+28     	; 0xd66 <DIO_u8SetPinDirection+0x80>
     d4a:	ed c0       	rjmp	.+474    	; 0xf26 <DIO_u8SetPinDirection+0x240>
     d4c:	2d 85       	ldd	r18, Y+13	; 0x0d
     d4e:	3e 85       	ldd	r19, Y+14	; 0x0e
     d50:	22 30       	cpi	r18, 0x02	; 2
     d52:	31 05       	cpc	r19, r1
     d54:	09 f4       	brne	.+2      	; 0xd58 <DIO_u8SetPinDirection+0x72>
     d56:	77 c0       	rjmp	.+238    	; 0xe46 <DIO_u8SetPinDirection+0x160>
     d58:	8d 85       	ldd	r24, Y+13	; 0x0d
     d5a:	9e 85       	ldd	r25, Y+14	; 0x0e
     d5c:	83 30       	cpi	r24, 0x03	; 3
     d5e:	91 05       	cpc	r25, r1
     d60:	09 f4       	brne	.+2      	; 0xd64 <DIO_u8SetPinDirection+0x7e>
     d62:	a9 c0       	rjmp	.+338    	; 0xeb6 <DIO_u8SetPinDirection+0x1d0>
     d64:	e0 c0       	rjmp	.+448    	; 0xf26 <DIO_u8SetPinDirection+0x240>
		{
			case DIO_u8_PORTA:
			switch(Copy_u8PinDirection)
     d66:	8c 81       	ldd	r24, Y+4	; 0x04
     d68:	28 2f       	mov	r18, r24
     d6a:	30 e0       	ldi	r19, 0x00	; 0
     d6c:	3c 87       	std	Y+12, r19	; 0x0c
     d6e:	2b 87       	std	Y+11, r18	; 0x0b
     d70:	8b 85       	ldd	r24, Y+11	; 0x0b
     d72:	9c 85       	ldd	r25, Y+12	; 0x0c
     d74:	00 97       	sbiw	r24, 0x00	; 0
     d76:	d1 f0       	breq	.+52     	; 0xdac <DIO_u8SetPinDirection+0xc6>
     d78:	2b 85       	ldd	r18, Y+11	; 0x0b
     d7a:	3c 85       	ldd	r19, Y+12	; 0x0c
     d7c:	21 30       	cpi	r18, 0x01	; 1
     d7e:	31 05       	cpc	r19, r1
     d80:	09 f0       	breq	.+2      	; 0xd84 <DIO_u8SetPinDirection+0x9e>
     d82:	d1 c0       	rjmp	.+418    	; 0xf26 <DIO_u8SetPinDirection+0x240>
			{
				case DIO_u8_OUTPUT:
				SET_BIT(DDRA_u8_REG,Copy_u8PinID);
     d84:	aa e3       	ldi	r26, 0x3A	; 58
     d86:	b0 e0       	ldi	r27, 0x00	; 0
     d88:	ea e3       	ldi	r30, 0x3A	; 58
     d8a:	f0 e0       	ldi	r31, 0x00	; 0
     d8c:	80 81       	ld	r24, Z
     d8e:	48 2f       	mov	r20, r24
     d90:	8b 81       	ldd	r24, Y+3	; 0x03
     d92:	28 2f       	mov	r18, r24
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	02 2e       	mov	r0, r18
     d9c:	02 c0       	rjmp	.+4      	; 0xda2 <DIO_u8SetPinDirection+0xbc>
     d9e:	88 0f       	add	r24, r24
     da0:	99 1f       	adc	r25, r25
     da2:	0a 94       	dec	r0
     da4:	e2 f7       	brpl	.-8      	; 0xd9e <DIO_u8SetPinDirection+0xb8>
     da6:	84 2b       	or	r24, r20
     da8:	8c 93       	st	X, r24
     daa:	bd c0       	rjmp	.+378    	; 0xf26 <DIO_u8SetPinDirection+0x240>
				break;
				case DIO_u8_INPUT:
				CLR_BIT(DDRA_u8_REG,Copy_u8PinID);
     dac:	aa e3       	ldi	r26, 0x3A	; 58
     dae:	b0 e0       	ldi	r27, 0x00	; 0
     db0:	ea e3       	ldi	r30, 0x3A	; 58
     db2:	f0 e0       	ldi	r31, 0x00	; 0
     db4:	80 81       	ld	r24, Z
     db6:	48 2f       	mov	r20, r24
     db8:	8b 81       	ldd	r24, Y+3	; 0x03
     dba:	28 2f       	mov	r18, r24
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	81 e0       	ldi	r24, 0x01	; 1
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	02 2e       	mov	r0, r18
     dc4:	02 c0       	rjmp	.+4      	; 0xdca <DIO_u8SetPinDirection+0xe4>
     dc6:	88 0f       	add	r24, r24
     dc8:	99 1f       	adc	r25, r25
     dca:	0a 94       	dec	r0
     dcc:	e2 f7       	brpl	.-8      	; 0xdc6 <DIO_u8SetPinDirection+0xe0>
     dce:	80 95       	com	r24
     dd0:	84 23       	and	r24, r20
     dd2:	8c 93       	st	X, r24
     dd4:	a8 c0       	rjmp	.+336    	; 0xf26 <DIO_u8SetPinDirection+0x240>
				break;
			}
			break;
			case DIO_u8_PORTB:
			switch(Copy_u8PinDirection)
     dd6:	8c 81       	ldd	r24, Y+4	; 0x04
     dd8:	28 2f       	mov	r18, r24
     dda:	30 e0       	ldi	r19, 0x00	; 0
     ddc:	3a 87       	std	Y+10, r19	; 0x0a
     dde:	29 87       	std	Y+9, r18	; 0x09
     de0:	89 85       	ldd	r24, Y+9	; 0x09
     de2:	9a 85       	ldd	r25, Y+10	; 0x0a
     de4:	00 97       	sbiw	r24, 0x00	; 0
     de6:	d1 f0       	breq	.+52     	; 0xe1c <DIO_u8SetPinDirection+0x136>
     de8:	29 85       	ldd	r18, Y+9	; 0x09
     dea:	3a 85       	ldd	r19, Y+10	; 0x0a
     dec:	21 30       	cpi	r18, 0x01	; 1
     dee:	31 05       	cpc	r19, r1
     df0:	09 f0       	breq	.+2      	; 0xdf4 <DIO_u8SetPinDirection+0x10e>
     df2:	99 c0       	rjmp	.+306    	; 0xf26 <DIO_u8SetPinDirection+0x240>
			{
				case DIO_u8_OUTPUT:
				SET_BIT(DDRB_u8_REG,Copy_u8PinID);
     df4:	a7 e3       	ldi	r26, 0x37	; 55
     df6:	b0 e0       	ldi	r27, 0x00	; 0
     df8:	e7 e3       	ldi	r30, 0x37	; 55
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	80 81       	ld	r24, Z
     dfe:	48 2f       	mov	r20, r24
     e00:	8b 81       	ldd	r24, Y+3	; 0x03
     e02:	28 2f       	mov	r18, r24
     e04:	30 e0       	ldi	r19, 0x00	; 0
     e06:	81 e0       	ldi	r24, 0x01	; 1
     e08:	90 e0       	ldi	r25, 0x00	; 0
     e0a:	02 2e       	mov	r0, r18
     e0c:	02 c0       	rjmp	.+4      	; 0xe12 <DIO_u8SetPinDirection+0x12c>
     e0e:	88 0f       	add	r24, r24
     e10:	99 1f       	adc	r25, r25
     e12:	0a 94       	dec	r0
     e14:	e2 f7       	brpl	.-8      	; 0xe0e <DIO_u8SetPinDirection+0x128>
     e16:	84 2b       	or	r24, r20
     e18:	8c 93       	st	X, r24
     e1a:	85 c0       	rjmp	.+266    	; 0xf26 <DIO_u8SetPinDirection+0x240>
				break;
				case DIO_u8_INPUT:
				CLR_BIT(DDRB_u8_REG,Copy_u8PinID);
     e1c:	a7 e3       	ldi	r26, 0x37	; 55
     e1e:	b0 e0       	ldi	r27, 0x00	; 0
     e20:	e7 e3       	ldi	r30, 0x37	; 55
     e22:	f0 e0       	ldi	r31, 0x00	; 0
     e24:	80 81       	ld	r24, Z
     e26:	48 2f       	mov	r20, r24
     e28:	8b 81       	ldd	r24, Y+3	; 0x03
     e2a:	28 2f       	mov	r18, r24
     e2c:	30 e0       	ldi	r19, 0x00	; 0
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	90 e0       	ldi	r25, 0x00	; 0
     e32:	02 2e       	mov	r0, r18
     e34:	02 c0       	rjmp	.+4      	; 0xe3a <DIO_u8SetPinDirection+0x154>
     e36:	88 0f       	add	r24, r24
     e38:	99 1f       	adc	r25, r25
     e3a:	0a 94       	dec	r0
     e3c:	e2 f7       	brpl	.-8      	; 0xe36 <DIO_u8SetPinDirection+0x150>
     e3e:	80 95       	com	r24
     e40:	84 23       	and	r24, r20
     e42:	8c 93       	st	X, r24
     e44:	70 c0       	rjmp	.+224    	; 0xf26 <DIO_u8SetPinDirection+0x240>
				break;
			}
			break;
			case DIO_u8_PORTC:
			switch(Copy_u8PinDirection)
     e46:	8c 81       	ldd	r24, Y+4	; 0x04
     e48:	28 2f       	mov	r18, r24
     e4a:	30 e0       	ldi	r19, 0x00	; 0
     e4c:	38 87       	std	Y+8, r19	; 0x08
     e4e:	2f 83       	std	Y+7, r18	; 0x07
     e50:	8f 81       	ldd	r24, Y+7	; 0x07
     e52:	98 85       	ldd	r25, Y+8	; 0x08
     e54:	00 97       	sbiw	r24, 0x00	; 0
     e56:	d1 f0       	breq	.+52     	; 0xe8c <DIO_u8SetPinDirection+0x1a6>
     e58:	2f 81       	ldd	r18, Y+7	; 0x07
     e5a:	38 85       	ldd	r19, Y+8	; 0x08
     e5c:	21 30       	cpi	r18, 0x01	; 1
     e5e:	31 05       	cpc	r19, r1
     e60:	09 f0       	breq	.+2      	; 0xe64 <DIO_u8SetPinDirection+0x17e>
     e62:	61 c0       	rjmp	.+194    	; 0xf26 <DIO_u8SetPinDirection+0x240>
			{
				case DIO_u8_OUTPUT:
				SET_BIT(DDRC_u8_REG,Copy_u8PinID);
     e64:	a4 e3       	ldi	r26, 0x34	; 52
     e66:	b0 e0       	ldi	r27, 0x00	; 0
     e68:	e4 e3       	ldi	r30, 0x34	; 52
     e6a:	f0 e0       	ldi	r31, 0x00	; 0
     e6c:	80 81       	ld	r24, Z
     e6e:	48 2f       	mov	r20, r24
     e70:	8b 81       	ldd	r24, Y+3	; 0x03
     e72:	28 2f       	mov	r18, r24
     e74:	30 e0       	ldi	r19, 0x00	; 0
     e76:	81 e0       	ldi	r24, 0x01	; 1
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	02 2e       	mov	r0, r18
     e7c:	02 c0       	rjmp	.+4      	; 0xe82 <DIO_u8SetPinDirection+0x19c>
     e7e:	88 0f       	add	r24, r24
     e80:	99 1f       	adc	r25, r25
     e82:	0a 94       	dec	r0
     e84:	e2 f7       	brpl	.-8      	; 0xe7e <DIO_u8SetPinDirection+0x198>
     e86:	84 2b       	or	r24, r20
     e88:	8c 93       	st	X, r24
     e8a:	4d c0       	rjmp	.+154    	; 0xf26 <DIO_u8SetPinDirection+0x240>
				break;
				case DIO_u8_INPUT:
				CLR_BIT(DDRC_u8_REG,Copy_u8PinID);
     e8c:	a4 e3       	ldi	r26, 0x34	; 52
     e8e:	b0 e0       	ldi	r27, 0x00	; 0
     e90:	e4 e3       	ldi	r30, 0x34	; 52
     e92:	f0 e0       	ldi	r31, 0x00	; 0
     e94:	80 81       	ld	r24, Z
     e96:	48 2f       	mov	r20, r24
     e98:	8b 81       	ldd	r24, Y+3	; 0x03
     e9a:	28 2f       	mov	r18, r24
     e9c:	30 e0       	ldi	r19, 0x00	; 0
     e9e:	81 e0       	ldi	r24, 0x01	; 1
     ea0:	90 e0       	ldi	r25, 0x00	; 0
     ea2:	02 2e       	mov	r0, r18
     ea4:	02 c0       	rjmp	.+4      	; 0xeaa <DIO_u8SetPinDirection+0x1c4>
     ea6:	88 0f       	add	r24, r24
     ea8:	99 1f       	adc	r25, r25
     eaa:	0a 94       	dec	r0
     eac:	e2 f7       	brpl	.-8      	; 0xea6 <DIO_u8SetPinDirection+0x1c0>
     eae:	80 95       	com	r24
     eb0:	84 23       	and	r24, r20
     eb2:	8c 93       	st	X, r24
     eb4:	38 c0       	rjmp	.+112    	; 0xf26 <DIO_u8SetPinDirection+0x240>
				break;
			}
			break;
			case DIO_u8_PORTD:
			switch(Copy_u8PinDirection)
     eb6:	8c 81       	ldd	r24, Y+4	; 0x04
     eb8:	28 2f       	mov	r18, r24
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	3e 83       	std	Y+6, r19	; 0x06
     ebe:	2d 83       	std	Y+5, r18	; 0x05
     ec0:	8d 81       	ldd	r24, Y+5	; 0x05
     ec2:	9e 81       	ldd	r25, Y+6	; 0x06
     ec4:	00 97       	sbiw	r24, 0x00	; 0
     ec6:	c9 f0       	breq	.+50     	; 0xefa <DIO_u8SetPinDirection+0x214>
     ec8:	2d 81       	ldd	r18, Y+5	; 0x05
     eca:	3e 81       	ldd	r19, Y+6	; 0x06
     ecc:	21 30       	cpi	r18, 0x01	; 1
     ece:	31 05       	cpc	r19, r1
     ed0:	51 f5       	brne	.+84     	; 0xf26 <DIO_u8SetPinDirection+0x240>
			{
				case DIO_u8_OUTPUT:
				SET_BIT(DDRD_u8_REG,Copy_u8PinID);
     ed2:	a1 e3       	ldi	r26, 0x31	; 49
     ed4:	b0 e0       	ldi	r27, 0x00	; 0
     ed6:	e1 e3       	ldi	r30, 0x31	; 49
     ed8:	f0 e0       	ldi	r31, 0x00	; 0
     eda:	80 81       	ld	r24, Z
     edc:	48 2f       	mov	r20, r24
     ede:	8b 81       	ldd	r24, Y+3	; 0x03
     ee0:	28 2f       	mov	r18, r24
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	02 2e       	mov	r0, r18
     eea:	02 c0       	rjmp	.+4      	; 0xef0 <DIO_u8SetPinDirection+0x20a>
     eec:	88 0f       	add	r24, r24
     eee:	99 1f       	adc	r25, r25
     ef0:	0a 94       	dec	r0
     ef2:	e2 f7       	brpl	.-8      	; 0xeec <DIO_u8SetPinDirection+0x206>
     ef4:	84 2b       	or	r24, r20
     ef6:	8c 93       	st	X, r24
     ef8:	16 c0       	rjmp	.+44     	; 0xf26 <DIO_u8SetPinDirection+0x240>
				break;
				case DIO_u8_INPUT:
				CLR_BIT(DDRD_u8_REG,Copy_u8PinID);
     efa:	a1 e3       	ldi	r26, 0x31	; 49
     efc:	b0 e0       	ldi	r27, 0x00	; 0
     efe:	e1 e3       	ldi	r30, 0x31	; 49
     f00:	f0 e0       	ldi	r31, 0x00	; 0
     f02:	80 81       	ld	r24, Z
     f04:	48 2f       	mov	r20, r24
     f06:	8b 81       	ldd	r24, Y+3	; 0x03
     f08:	28 2f       	mov	r18, r24
     f0a:	30 e0       	ldi	r19, 0x00	; 0
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	02 2e       	mov	r0, r18
     f12:	02 c0       	rjmp	.+4      	; 0xf18 <DIO_u8SetPinDirection+0x232>
     f14:	88 0f       	add	r24, r24
     f16:	99 1f       	adc	r25, r25
     f18:	0a 94       	dec	r0
     f1a:	e2 f7       	brpl	.-8      	; 0xf14 <DIO_u8SetPinDirection+0x22e>
     f1c:	80 95       	com	r24
     f1e:	84 23       	and	r24, r20
     f20:	8c 93       	st	X, r24
     f22:	01 c0       	rjmp	.+2      	; 0xf26 <DIO_u8SetPinDirection+0x240>
			break;
		}
	}
	else
	{
		Local_u8ReturnState = STD_TYPES_NOK;
     f24:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnState;
     f26:	89 81       	ldd	r24, Y+1	; 0x01
}
     f28:	2e 96       	adiw	r28, 0x0e	; 14
     f2a:	0f b6       	in	r0, 0x3f	; 63
     f2c:	f8 94       	cli
     f2e:	de bf       	out	0x3e, r29	; 62
     f30:	0f be       	out	0x3f, r0	; 63
     f32:	cd bf       	out	0x3d, r28	; 61
     f34:	cf 91       	pop	r28
     f36:	df 91       	pop	r29
     f38:	08 95       	ret

00000f3a <DIO_u8SetPinValue>:
u8 DIO_u8SetPinValue     (u8 Copy_u8PortID, u8 Copy_u8PinID, u8 Copy_u8PinValue)
{
     f3a:	df 93       	push	r29
     f3c:	cf 93       	push	r28
     f3e:	cd b7       	in	r28, 0x3d	; 61
     f40:	de b7       	in	r29, 0x3e	; 62
     f42:	2e 97       	sbiw	r28, 0x0e	; 14
     f44:	0f b6       	in	r0, 0x3f	; 63
     f46:	f8 94       	cli
     f48:	de bf       	out	0x3e, r29	; 62
     f4a:	0f be       	out	0x3f, r0	; 63
     f4c:	cd bf       	out	0x3d, r28	; 61
     f4e:	8a 83       	std	Y+2, r24	; 0x02
     f50:	6b 83       	std	Y+3, r22	; 0x03
     f52:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ReturnState = STD_TYPES_OK;
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	89 83       	std	Y+1, r24	; 0x01
	  if((Copy_u8PortID <= DIO_u8_PORTD)  && (Copy_u8PinID <= DIO_u8_PIN7) && ((Copy_u8PinValue == DIO_u8_HIGH) || (Copy_u8PinValue == DIO_u8_LOW)))
     f58:	8a 81       	ldd	r24, Y+2	; 0x02
     f5a:	84 30       	cpi	r24, 0x04	; 4
     f5c:	08 f0       	brcs	.+2      	; 0xf60 <DIO_u8SetPinValue+0x26>
     f5e:	0c c1       	rjmp	.+536    	; 0x1178 <DIO_u8SetPinValue+0x23e>
     f60:	8b 81       	ldd	r24, Y+3	; 0x03
     f62:	88 30       	cpi	r24, 0x08	; 8
     f64:	08 f0       	brcs	.+2      	; 0xf68 <DIO_u8SetPinValue+0x2e>
     f66:	08 c1       	rjmp	.+528    	; 0x1178 <DIO_u8SetPinValue+0x23e>
     f68:	8c 81       	ldd	r24, Y+4	; 0x04
     f6a:	81 30       	cpi	r24, 0x01	; 1
     f6c:	21 f0       	breq	.+8      	; 0xf76 <DIO_u8SetPinValue+0x3c>
     f6e:	8c 81       	ldd	r24, Y+4	; 0x04
     f70:	88 23       	and	r24, r24
     f72:	09 f0       	breq	.+2      	; 0xf76 <DIO_u8SetPinValue+0x3c>
     f74:	01 c1       	rjmp	.+514    	; 0x1178 <DIO_u8SetPinValue+0x23e>
	  {
		  switch (Copy_u8PortID)
     f76:	8a 81       	ldd	r24, Y+2	; 0x02
     f78:	28 2f       	mov	r18, r24
     f7a:	30 e0       	ldi	r19, 0x00	; 0
     f7c:	3e 87       	std	Y+14, r19	; 0x0e
     f7e:	2d 87       	std	Y+13, r18	; 0x0d
     f80:	8d 85       	ldd	r24, Y+13	; 0x0d
     f82:	9e 85       	ldd	r25, Y+14	; 0x0e
     f84:	81 30       	cpi	r24, 0x01	; 1
     f86:	91 05       	cpc	r25, r1
     f88:	09 f4       	brne	.+2      	; 0xf8c <DIO_u8SetPinValue+0x52>
     f8a:	4f c0       	rjmp	.+158    	; 0x102a <DIO_u8SetPinValue+0xf0>
     f8c:	2d 85       	ldd	r18, Y+13	; 0x0d
     f8e:	3e 85       	ldd	r19, Y+14	; 0x0e
     f90:	22 30       	cpi	r18, 0x02	; 2
     f92:	31 05       	cpc	r19, r1
     f94:	2c f4       	brge	.+10     	; 0xfa0 <DIO_u8SetPinValue+0x66>
     f96:	8d 85       	ldd	r24, Y+13	; 0x0d
     f98:	9e 85       	ldd	r25, Y+14	; 0x0e
     f9a:	00 97       	sbiw	r24, 0x00	; 0
     f9c:	71 f0       	breq	.+28     	; 0xfba <DIO_u8SetPinValue+0x80>
     f9e:	ed c0       	rjmp	.+474    	; 0x117a <DIO_u8SetPinValue+0x240>
     fa0:	2d 85       	ldd	r18, Y+13	; 0x0d
     fa2:	3e 85       	ldd	r19, Y+14	; 0x0e
     fa4:	22 30       	cpi	r18, 0x02	; 2
     fa6:	31 05       	cpc	r19, r1
     fa8:	09 f4       	brne	.+2      	; 0xfac <DIO_u8SetPinValue+0x72>
     faa:	77 c0       	rjmp	.+238    	; 0x109a <DIO_u8SetPinValue+0x160>
     fac:	8d 85       	ldd	r24, Y+13	; 0x0d
     fae:	9e 85       	ldd	r25, Y+14	; 0x0e
     fb0:	83 30       	cpi	r24, 0x03	; 3
     fb2:	91 05       	cpc	r25, r1
     fb4:	09 f4       	brne	.+2      	; 0xfb8 <DIO_u8SetPinValue+0x7e>
     fb6:	a9 c0       	rjmp	.+338    	; 0x110a <DIO_u8SetPinValue+0x1d0>
     fb8:	e0 c0       	rjmp	.+448    	; 0x117a <DIO_u8SetPinValue+0x240>
		  {
			  case DIO_u8_PORTA:
			     switch(Copy_u8PinValue)
     fba:	8c 81       	ldd	r24, Y+4	; 0x04
     fbc:	28 2f       	mov	r18, r24
     fbe:	30 e0       	ldi	r19, 0x00	; 0
     fc0:	3c 87       	std	Y+12, r19	; 0x0c
     fc2:	2b 87       	std	Y+11, r18	; 0x0b
     fc4:	8b 85       	ldd	r24, Y+11	; 0x0b
     fc6:	9c 85       	ldd	r25, Y+12	; 0x0c
     fc8:	00 97       	sbiw	r24, 0x00	; 0
     fca:	d1 f0       	breq	.+52     	; 0x1000 <DIO_u8SetPinValue+0xc6>
     fcc:	2b 85       	ldd	r18, Y+11	; 0x0b
     fce:	3c 85       	ldd	r19, Y+12	; 0x0c
     fd0:	21 30       	cpi	r18, 0x01	; 1
     fd2:	31 05       	cpc	r19, r1
     fd4:	09 f0       	breq	.+2      	; 0xfd8 <DIO_u8SetPinValue+0x9e>
     fd6:	d1 c0       	rjmp	.+418    	; 0x117a <DIO_u8SetPinValue+0x240>
				 {
					case DIO_u8_HIGH:
					 SET_BIT(PORTA_u8_REG,Copy_u8PinID);
     fd8:	ab e3       	ldi	r26, 0x3B	; 59
     fda:	b0 e0       	ldi	r27, 0x00	; 0
     fdc:	eb e3       	ldi	r30, 0x3B	; 59
     fde:	f0 e0       	ldi	r31, 0x00	; 0
     fe0:	80 81       	ld	r24, Z
     fe2:	48 2f       	mov	r20, r24
     fe4:	8b 81       	ldd	r24, Y+3	; 0x03
     fe6:	28 2f       	mov	r18, r24
     fe8:	30 e0       	ldi	r19, 0x00	; 0
     fea:	81 e0       	ldi	r24, 0x01	; 1
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	02 2e       	mov	r0, r18
     ff0:	02 c0       	rjmp	.+4      	; 0xff6 <DIO_u8SetPinValue+0xbc>
     ff2:	88 0f       	add	r24, r24
     ff4:	99 1f       	adc	r25, r25
     ff6:	0a 94       	dec	r0
     ff8:	e2 f7       	brpl	.-8      	; 0xff2 <DIO_u8SetPinValue+0xb8>
     ffa:	84 2b       	or	r24, r20
     ffc:	8c 93       	st	X, r24
     ffe:	bd c0       	rjmp	.+378    	; 0x117a <DIO_u8SetPinValue+0x240>
					break;
					case DIO_u8_LOW:
					 CLR_BIT(PORTA_u8_REG,Copy_u8PinID);
    1000:	ab e3       	ldi	r26, 0x3B	; 59
    1002:	b0 e0       	ldi	r27, 0x00	; 0
    1004:	eb e3       	ldi	r30, 0x3B	; 59
    1006:	f0 e0       	ldi	r31, 0x00	; 0
    1008:	80 81       	ld	r24, Z
    100a:	48 2f       	mov	r20, r24
    100c:	8b 81       	ldd	r24, Y+3	; 0x03
    100e:	28 2f       	mov	r18, r24
    1010:	30 e0       	ldi	r19, 0x00	; 0
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	02 2e       	mov	r0, r18
    1018:	02 c0       	rjmp	.+4      	; 0x101e <DIO_u8SetPinValue+0xe4>
    101a:	88 0f       	add	r24, r24
    101c:	99 1f       	adc	r25, r25
    101e:	0a 94       	dec	r0
    1020:	e2 f7       	brpl	.-8      	; 0x101a <DIO_u8SetPinValue+0xe0>
    1022:	80 95       	com	r24
    1024:	84 23       	and	r24, r20
    1026:	8c 93       	st	X, r24
    1028:	a8 c0       	rjmp	.+336    	; 0x117a <DIO_u8SetPinValue+0x240>
					break;   
				 }
			   break;
			   case DIO_u8_PORTB:
			     switch(Copy_u8PinValue)
    102a:	8c 81       	ldd	r24, Y+4	; 0x04
    102c:	28 2f       	mov	r18, r24
    102e:	30 e0       	ldi	r19, 0x00	; 0
    1030:	3a 87       	std	Y+10, r19	; 0x0a
    1032:	29 87       	std	Y+9, r18	; 0x09
    1034:	89 85       	ldd	r24, Y+9	; 0x09
    1036:	9a 85       	ldd	r25, Y+10	; 0x0a
    1038:	00 97       	sbiw	r24, 0x00	; 0
    103a:	d1 f0       	breq	.+52     	; 0x1070 <DIO_u8SetPinValue+0x136>
    103c:	29 85       	ldd	r18, Y+9	; 0x09
    103e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1040:	21 30       	cpi	r18, 0x01	; 1
    1042:	31 05       	cpc	r19, r1
    1044:	09 f0       	breq	.+2      	; 0x1048 <DIO_u8SetPinValue+0x10e>
    1046:	99 c0       	rjmp	.+306    	; 0x117a <DIO_u8SetPinValue+0x240>
				  {
					case DIO_u8_HIGH:
					 SET_BIT(PORTB_u8_REG,Copy_u8PinID);
    1048:	a8 e3       	ldi	r26, 0x38	; 56
    104a:	b0 e0       	ldi	r27, 0x00	; 0
    104c:	e8 e3       	ldi	r30, 0x38	; 56
    104e:	f0 e0       	ldi	r31, 0x00	; 0
    1050:	80 81       	ld	r24, Z
    1052:	48 2f       	mov	r20, r24
    1054:	8b 81       	ldd	r24, Y+3	; 0x03
    1056:	28 2f       	mov	r18, r24
    1058:	30 e0       	ldi	r19, 0x00	; 0
    105a:	81 e0       	ldi	r24, 0x01	; 1
    105c:	90 e0       	ldi	r25, 0x00	; 0
    105e:	02 2e       	mov	r0, r18
    1060:	02 c0       	rjmp	.+4      	; 0x1066 <DIO_u8SetPinValue+0x12c>
    1062:	88 0f       	add	r24, r24
    1064:	99 1f       	adc	r25, r25
    1066:	0a 94       	dec	r0
    1068:	e2 f7       	brpl	.-8      	; 0x1062 <DIO_u8SetPinValue+0x128>
    106a:	84 2b       	or	r24, r20
    106c:	8c 93       	st	X, r24
    106e:	85 c0       	rjmp	.+266    	; 0x117a <DIO_u8SetPinValue+0x240>
					break;
					case DIO_u8_LOW:
					 CLR_BIT(PORTB_u8_REG,Copy_u8PinID);
    1070:	a8 e3       	ldi	r26, 0x38	; 56
    1072:	b0 e0       	ldi	r27, 0x00	; 0
    1074:	e8 e3       	ldi	r30, 0x38	; 56
    1076:	f0 e0       	ldi	r31, 0x00	; 0
    1078:	80 81       	ld	r24, Z
    107a:	48 2f       	mov	r20, r24
    107c:	8b 81       	ldd	r24, Y+3	; 0x03
    107e:	28 2f       	mov	r18, r24
    1080:	30 e0       	ldi	r19, 0x00	; 0
    1082:	81 e0       	ldi	r24, 0x01	; 1
    1084:	90 e0       	ldi	r25, 0x00	; 0
    1086:	02 2e       	mov	r0, r18
    1088:	02 c0       	rjmp	.+4      	; 0x108e <DIO_u8SetPinValue+0x154>
    108a:	88 0f       	add	r24, r24
    108c:	99 1f       	adc	r25, r25
    108e:	0a 94       	dec	r0
    1090:	e2 f7       	brpl	.-8      	; 0x108a <DIO_u8SetPinValue+0x150>
    1092:	80 95       	com	r24
    1094:	84 23       	and	r24, r20
    1096:	8c 93       	st	X, r24
    1098:	70 c0       	rjmp	.+224    	; 0x117a <DIO_u8SetPinValue+0x240>
					break;
				  }
			   break;
			   case DIO_u8_PORTC:
			     switch(Copy_u8PinValue)
    109a:	8c 81       	ldd	r24, Y+4	; 0x04
    109c:	28 2f       	mov	r18, r24
    109e:	30 e0       	ldi	r19, 0x00	; 0
    10a0:	38 87       	std	Y+8, r19	; 0x08
    10a2:	2f 83       	std	Y+7, r18	; 0x07
    10a4:	8f 81       	ldd	r24, Y+7	; 0x07
    10a6:	98 85       	ldd	r25, Y+8	; 0x08
    10a8:	00 97       	sbiw	r24, 0x00	; 0
    10aa:	d1 f0       	breq	.+52     	; 0x10e0 <DIO_u8SetPinValue+0x1a6>
    10ac:	2f 81       	ldd	r18, Y+7	; 0x07
    10ae:	38 85       	ldd	r19, Y+8	; 0x08
    10b0:	21 30       	cpi	r18, 0x01	; 1
    10b2:	31 05       	cpc	r19, r1
    10b4:	09 f0       	breq	.+2      	; 0x10b8 <DIO_u8SetPinValue+0x17e>
    10b6:	61 c0       	rjmp	.+194    	; 0x117a <DIO_u8SetPinValue+0x240>
				  {
					case DIO_u8_HIGH:
					 SET_BIT(PORTC_u8_REG,Copy_u8PinID);
    10b8:	a5 e3       	ldi	r26, 0x35	; 53
    10ba:	b0 e0       	ldi	r27, 0x00	; 0
    10bc:	e5 e3       	ldi	r30, 0x35	; 53
    10be:	f0 e0       	ldi	r31, 0x00	; 0
    10c0:	80 81       	ld	r24, Z
    10c2:	48 2f       	mov	r20, r24
    10c4:	8b 81       	ldd	r24, Y+3	; 0x03
    10c6:	28 2f       	mov	r18, r24
    10c8:	30 e0       	ldi	r19, 0x00	; 0
    10ca:	81 e0       	ldi	r24, 0x01	; 1
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	02 2e       	mov	r0, r18
    10d0:	02 c0       	rjmp	.+4      	; 0x10d6 <DIO_u8SetPinValue+0x19c>
    10d2:	88 0f       	add	r24, r24
    10d4:	99 1f       	adc	r25, r25
    10d6:	0a 94       	dec	r0
    10d8:	e2 f7       	brpl	.-8      	; 0x10d2 <DIO_u8SetPinValue+0x198>
    10da:	84 2b       	or	r24, r20
    10dc:	8c 93       	st	X, r24
    10de:	4d c0       	rjmp	.+154    	; 0x117a <DIO_u8SetPinValue+0x240>
					break;
					case DIO_u8_LOW:
					 CLR_BIT(PORTC_u8_REG,Copy_u8PinID);
    10e0:	a5 e3       	ldi	r26, 0x35	; 53
    10e2:	b0 e0       	ldi	r27, 0x00	; 0
    10e4:	e5 e3       	ldi	r30, 0x35	; 53
    10e6:	f0 e0       	ldi	r31, 0x00	; 0
    10e8:	80 81       	ld	r24, Z
    10ea:	48 2f       	mov	r20, r24
    10ec:	8b 81       	ldd	r24, Y+3	; 0x03
    10ee:	28 2f       	mov	r18, r24
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	81 e0       	ldi	r24, 0x01	; 1
    10f4:	90 e0       	ldi	r25, 0x00	; 0
    10f6:	02 2e       	mov	r0, r18
    10f8:	02 c0       	rjmp	.+4      	; 0x10fe <DIO_u8SetPinValue+0x1c4>
    10fa:	88 0f       	add	r24, r24
    10fc:	99 1f       	adc	r25, r25
    10fe:	0a 94       	dec	r0
    1100:	e2 f7       	brpl	.-8      	; 0x10fa <DIO_u8SetPinValue+0x1c0>
    1102:	80 95       	com	r24
    1104:	84 23       	and	r24, r20
    1106:	8c 93       	st	X, r24
    1108:	38 c0       	rjmp	.+112    	; 0x117a <DIO_u8SetPinValue+0x240>
					break;
				  }
			   break;
			   case DIO_u8_PORTD:
			     switch(Copy_u8PinValue)
    110a:	8c 81       	ldd	r24, Y+4	; 0x04
    110c:	28 2f       	mov	r18, r24
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	3e 83       	std	Y+6, r19	; 0x06
    1112:	2d 83       	std	Y+5, r18	; 0x05
    1114:	8d 81       	ldd	r24, Y+5	; 0x05
    1116:	9e 81       	ldd	r25, Y+6	; 0x06
    1118:	00 97       	sbiw	r24, 0x00	; 0
    111a:	c9 f0       	breq	.+50     	; 0x114e <DIO_u8SetPinValue+0x214>
    111c:	2d 81       	ldd	r18, Y+5	; 0x05
    111e:	3e 81       	ldd	r19, Y+6	; 0x06
    1120:	21 30       	cpi	r18, 0x01	; 1
    1122:	31 05       	cpc	r19, r1
    1124:	51 f5       	brne	.+84     	; 0x117a <DIO_u8SetPinValue+0x240>
				  { 
					case DIO_u8_HIGH:
					 SET_BIT(PORTD_u8_REG,Copy_u8PinID);
    1126:	a2 e3       	ldi	r26, 0x32	; 50
    1128:	b0 e0       	ldi	r27, 0x00	; 0
    112a:	e2 e3       	ldi	r30, 0x32	; 50
    112c:	f0 e0       	ldi	r31, 0x00	; 0
    112e:	80 81       	ld	r24, Z
    1130:	48 2f       	mov	r20, r24
    1132:	8b 81       	ldd	r24, Y+3	; 0x03
    1134:	28 2f       	mov	r18, r24
    1136:	30 e0       	ldi	r19, 0x00	; 0
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	02 2e       	mov	r0, r18
    113e:	02 c0       	rjmp	.+4      	; 0x1144 <DIO_u8SetPinValue+0x20a>
    1140:	88 0f       	add	r24, r24
    1142:	99 1f       	adc	r25, r25
    1144:	0a 94       	dec	r0
    1146:	e2 f7       	brpl	.-8      	; 0x1140 <DIO_u8SetPinValue+0x206>
    1148:	84 2b       	or	r24, r20
    114a:	8c 93       	st	X, r24
    114c:	16 c0       	rjmp	.+44     	; 0x117a <DIO_u8SetPinValue+0x240>
					break;
					case DIO_u8_LOW:
					 CLR_BIT(PORTD_u8_REG,Copy_u8PinID);
    114e:	a2 e3       	ldi	r26, 0x32	; 50
    1150:	b0 e0       	ldi	r27, 0x00	; 0
    1152:	e2 e3       	ldi	r30, 0x32	; 50
    1154:	f0 e0       	ldi	r31, 0x00	; 0
    1156:	80 81       	ld	r24, Z
    1158:	48 2f       	mov	r20, r24
    115a:	8b 81       	ldd	r24, Y+3	; 0x03
    115c:	28 2f       	mov	r18, r24
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	81 e0       	ldi	r24, 0x01	; 1
    1162:	90 e0       	ldi	r25, 0x00	; 0
    1164:	02 2e       	mov	r0, r18
    1166:	02 c0       	rjmp	.+4      	; 0x116c <DIO_u8SetPinValue+0x232>
    1168:	88 0f       	add	r24, r24
    116a:	99 1f       	adc	r25, r25
    116c:	0a 94       	dec	r0
    116e:	e2 f7       	brpl	.-8      	; 0x1168 <DIO_u8SetPinValue+0x22e>
    1170:	80 95       	com	r24
    1172:	84 23       	and	r24, r20
    1174:	8c 93       	st	X, r24
    1176:	01 c0       	rjmp	.+2      	; 0x117a <DIO_u8SetPinValue+0x240>
			   break;
		   }
	  }
	  else
	  {
	      Local_u8ReturnState = STD_TYPES_NOK;
    1178:	19 82       	std	Y+1, r1	; 0x01
	  }
	return Local_u8ReturnState;
    117a:	89 81       	ldd	r24, Y+1	; 0x01
}
    117c:	2e 96       	adiw	r28, 0x0e	; 14
    117e:	0f b6       	in	r0, 0x3f	; 63
    1180:	f8 94       	cli
    1182:	de bf       	out	0x3e, r29	; 62
    1184:	0f be       	out	0x3f, r0	; 63
    1186:	cd bf       	out	0x3d, r28	; 61
    1188:	cf 91       	pop	r28
    118a:	df 91       	pop	r29
    118c:	08 95       	ret

0000118e <DIO_u8GetPinValue>:
u8 DIO_u8GetPinValue     (u8 Copy_u8PortID, u8 Copy_u8PinID, u8 * Copy_pu8ReturnedPinValue)
{
    118e:	df 93       	push	r29
    1190:	cf 93       	push	r28
    1192:	cd b7       	in	r28, 0x3d	; 61
    1194:	de b7       	in	r29, 0x3e	; 62
    1196:	27 97       	sbiw	r28, 0x07	; 7
    1198:	0f b6       	in	r0, 0x3f	; 63
    119a:	f8 94       	cli
    119c:	de bf       	out	0x3e, r29	; 62
    119e:	0f be       	out	0x3f, r0	; 63
    11a0:	cd bf       	out	0x3d, r28	; 61
    11a2:	8a 83       	std	Y+2, r24	; 0x02
    11a4:	6b 83       	std	Y+3, r22	; 0x03
    11a6:	5d 83       	std	Y+5, r21	; 0x05
    11a8:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ReturnState = STD_TYPES_OK;
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortID <= DIO_u8_PORTD)  && (Copy_u8PinID <= DIO_u8_PIN7) && (Copy_pu8ReturnedPinValue != NULL))
    11ae:	8a 81       	ldd	r24, Y+2	; 0x02
    11b0:	84 30       	cpi	r24, 0x04	; 4
    11b2:	08 f0       	brcs	.+2      	; 0x11b6 <DIO_u8GetPinValue+0x28>
    11b4:	ea c0       	rjmp	.+468    	; 0x138a <DIO_u8GetPinValue+0x1fc>
    11b6:	8b 81       	ldd	r24, Y+3	; 0x03
    11b8:	88 30       	cpi	r24, 0x08	; 8
    11ba:	08 f0       	brcs	.+2      	; 0x11be <DIO_u8GetPinValue+0x30>
    11bc:	e6 c0       	rjmp	.+460    	; 0x138a <DIO_u8GetPinValue+0x1fc>
    11be:	8c 81       	ldd	r24, Y+4	; 0x04
    11c0:	9d 81       	ldd	r25, Y+5	; 0x05
    11c2:	00 97       	sbiw	r24, 0x00	; 0
    11c4:	09 f4       	brne	.+2      	; 0x11c8 <DIO_u8GetPinValue+0x3a>
    11c6:	e1 c0       	rjmp	.+450    	; 0x138a <DIO_u8GetPinValue+0x1fc>
	{
		switch (Copy_u8PortID)
    11c8:	8a 81       	ldd	r24, Y+2	; 0x02
    11ca:	28 2f       	mov	r18, r24
    11cc:	30 e0       	ldi	r19, 0x00	; 0
    11ce:	3f 83       	std	Y+7, r19	; 0x07
    11d0:	2e 83       	std	Y+6, r18	; 0x06
    11d2:	4e 81       	ldd	r20, Y+6	; 0x06
    11d4:	5f 81       	ldd	r21, Y+7	; 0x07
    11d6:	41 30       	cpi	r20, 0x01	; 1
    11d8:	51 05       	cpc	r21, r1
    11da:	09 f4       	brne	.+2      	; 0x11de <DIO_u8GetPinValue+0x50>
    11dc:	48 c0       	rjmp	.+144    	; 0x126e <DIO_u8GetPinValue+0xe0>
    11de:	8e 81       	ldd	r24, Y+6	; 0x06
    11e0:	9f 81       	ldd	r25, Y+7	; 0x07
    11e2:	82 30       	cpi	r24, 0x02	; 2
    11e4:	91 05       	cpc	r25, r1
    11e6:	34 f4       	brge	.+12     	; 0x11f4 <DIO_u8GetPinValue+0x66>
    11e8:	2e 81       	ldd	r18, Y+6	; 0x06
    11ea:	3f 81       	ldd	r19, Y+7	; 0x07
    11ec:	21 15       	cp	r18, r1
    11ee:	31 05       	cpc	r19, r1
    11f0:	71 f0       	breq	.+28     	; 0x120e <DIO_u8GetPinValue+0x80>
    11f2:	cc c0       	rjmp	.+408    	; 0x138c <DIO_u8GetPinValue+0x1fe>
    11f4:	4e 81       	ldd	r20, Y+6	; 0x06
    11f6:	5f 81       	ldd	r21, Y+7	; 0x07
    11f8:	42 30       	cpi	r20, 0x02	; 2
    11fa:	51 05       	cpc	r21, r1
    11fc:	09 f4       	brne	.+2      	; 0x1200 <DIO_u8GetPinValue+0x72>
    11fe:	67 c0       	rjmp	.+206    	; 0x12ce <DIO_u8GetPinValue+0x140>
    1200:	8e 81       	ldd	r24, Y+6	; 0x06
    1202:	9f 81       	ldd	r25, Y+7	; 0x07
    1204:	83 30       	cpi	r24, 0x03	; 3
    1206:	91 05       	cpc	r25, r1
    1208:	09 f4       	brne	.+2      	; 0x120c <DIO_u8GetPinValue+0x7e>
    120a:	90 c0       	rjmp	.+288    	; 0x132c <DIO_u8GetPinValue+0x19e>
    120c:	bf c0       	rjmp	.+382    	; 0x138c <DIO_u8GetPinValue+0x1fe>
		{
			case DIO_u8_PORTA: 
			   if(GET_BIT(PINA_u8_REG,Copy_u8PinID)== 0)
    120e:	e9 e3       	ldi	r30, 0x39	; 57
    1210:	f0 e0       	ldi	r31, 0x00	; 0
    1212:	80 81       	ld	r24, Z
    1214:	28 2f       	mov	r18, r24
    1216:	30 e0       	ldi	r19, 0x00	; 0
    1218:	8b 81       	ldd	r24, Y+3	; 0x03
    121a:	88 2f       	mov	r24, r24
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	a9 01       	movw	r20, r18
    1220:	02 c0       	rjmp	.+4      	; 0x1226 <DIO_u8GetPinValue+0x98>
    1222:	55 95       	asr	r21
    1224:	47 95       	ror	r20
    1226:	8a 95       	dec	r24
    1228:	e2 f7       	brpl	.-8      	; 0x1222 <DIO_u8GetPinValue+0x94>
    122a:	ca 01       	movw	r24, r20
    122c:	81 70       	andi	r24, 0x01	; 1
    122e:	90 70       	andi	r25, 0x00	; 0
    1230:	00 97       	sbiw	r24, 0x00	; 0
    1232:	21 f4       	brne	.+8      	; 0x123c <DIO_u8GetPinValue+0xae>
			   {
				   *Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    1234:	ec 81       	ldd	r30, Y+4	; 0x04
    1236:	fd 81       	ldd	r31, Y+5	; 0x05
    1238:	10 82       	st	Z, r1
    123a:	a8 c0       	rjmp	.+336    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   }
			   else if(GET_BIT(PINA_u8_REG,Copy_u8PinID)!=0)
    123c:	e9 e3       	ldi	r30, 0x39	; 57
    123e:	f0 e0       	ldi	r31, 0x00	; 0
    1240:	80 81       	ld	r24, Z
    1242:	28 2f       	mov	r18, r24
    1244:	30 e0       	ldi	r19, 0x00	; 0
    1246:	8b 81       	ldd	r24, Y+3	; 0x03
    1248:	88 2f       	mov	r24, r24
    124a:	90 e0       	ldi	r25, 0x00	; 0
    124c:	a9 01       	movw	r20, r18
    124e:	02 c0       	rjmp	.+4      	; 0x1254 <DIO_u8GetPinValue+0xc6>
    1250:	55 95       	asr	r21
    1252:	47 95       	ror	r20
    1254:	8a 95       	dec	r24
    1256:	e2 f7       	brpl	.-8      	; 0x1250 <DIO_u8GetPinValue+0xc2>
    1258:	ca 01       	movw	r24, r20
    125a:	81 70       	andi	r24, 0x01	; 1
    125c:	90 70       	andi	r25, 0x00	; 0
    125e:	88 23       	and	r24, r24
    1260:	09 f4       	brne	.+2      	; 0x1264 <DIO_u8GetPinValue+0xd6>
    1262:	94 c0       	rjmp	.+296    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   {
				   *Copy_pu8ReturnedPinValue =DIO_u8_HIGH;
    1264:	ec 81       	ldd	r30, Y+4	; 0x04
    1266:	fd 81       	ldd	r31, Y+5	; 0x05
    1268:	81 e0       	ldi	r24, 0x01	; 1
    126a:	80 83       	st	Z, r24
    126c:	8f c0       	rjmp	.+286    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   }
			break;
			case DIO_u8_PORTB: 
			   if(GET_BIT(PINB_u8_REG,Copy_u8PinID)== 0)
    126e:	e6 e3       	ldi	r30, 0x36	; 54
    1270:	f0 e0       	ldi	r31, 0x00	; 0
    1272:	80 81       	ld	r24, Z
    1274:	28 2f       	mov	r18, r24
    1276:	30 e0       	ldi	r19, 0x00	; 0
    1278:	8b 81       	ldd	r24, Y+3	; 0x03
    127a:	88 2f       	mov	r24, r24
    127c:	90 e0       	ldi	r25, 0x00	; 0
    127e:	a9 01       	movw	r20, r18
    1280:	02 c0       	rjmp	.+4      	; 0x1286 <DIO_u8GetPinValue+0xf8>
    1282:	55 95       	asr	r21
    1284:	47 95       	ror	r20
    1286:	8a 95       	dec	r24
    1288:	e2 f7       	brpl	.-8      	; 0x1282 <DIO_u8GetPinValue+0xf4>
    128a:	ca 01       	movw	r24, r20
    128c:	81 70       	andi	r24, 0x01	; 1
    128e:	90 70       	andi	r25, 0x00	; 0
    1290:	00 97       	sbiw	r24, 0x00	; 0
    1292:	21 f4       	brne	.+8      	; 0x129c <DIO_u8GetPinValue+0x10e>
			    {
				   *Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    1294:	ec 81       	ldd	r30, Y+4	; 0x04
    1296:	fd 81       	ldd	r31, Y+5	; 0x05
    1298:	10 82       	st	Z, r1
    129a:	78 c0       	rjmp	.+240    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   }
			   else if(GET_BIT(PINB_u8_REG,Copy_u8PinID)!=0)
    129c:	e6 e3       	ldi	r30, 0x36	; 54
    129e:	f0 e0       	ldi	r31, 0x00	; 0
    12a0:	80 81       	ld	r24, Z
    12a2:	28 2f       	mov	r18, r24
    12a4:	30 e0       	ldi	r19, 0x00	; 0
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	88 2f       	mov	r24, r24
    12aa:	90 e0       	ldi	r25, 0x00	; 0
    12ac:	a9 01       	movw	r20, r18
    12ae:	02 c0       	rjmp	.+4      	; 0x12b4 <DIO_u8GetPinValue+0x126>
    12b0:	55 95       	asr	r21
    12b2:	47 95       	ror	r20
    12b4:	8a 95       	dec	r24
    12b6:	e2 f7       	brpl	.-8      	; 0x12b0 <DIO_u8GetPinValue+0x122>
    12b8:	ca 01       	movw	r24, r20
    12ba:	81 70       	andi	r24, 0x01	; 1
    12bc:	90 70       	andi	r25, 0x00	; 0
    12be:	88 23       	and	r24, r24
    12c0:	09 f4       	brne	.+2      	; 0x12c4 <DIO_u8GetPinValue+0x136>
    12c2:	64 c0       	rjmp	.+200    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   {
				   *Copy_pu8ReturnedPinValue =DIO_u8_HIGH;
    12c4:	ec 81       	ldd	r30, Y+4	; 0x04
    12c6:	fd 81       	ldd	r31, Y+5	; 0x05
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	80 83       	st	Z, r24
    12cc:	5f c0       	rjmp	.+190    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   }
			break;
			case DIO_u8_PORTC: 
			   if(GET_BIT(PINC_u8_REG,Copy_u8PinID)== 0)
    12ce:	e3 e3       	ldi	r30, 0x33	; 51
    12d0:	f0 e0       	ldi	r31, 0x00	; 0
    12d2:	80 81       	ld	r24, Z
    12d4:	28 2f       	mov	r18, r24
    12d6:	30 e0       	ldi	r19, 0x00	; 0
    12d8:	8b 81       	ldd	r24, Y+3	; 0x03
    12da:	88 2f       	mov	r24, r24
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	a9 01       	movw	r20, r18
    12e0:	02 c0       	rjmp	.+4      	; 0x12e6 <DIO_u8GetPinValue+0x158>
    12e2:	55 95       	asr	r21
    12e4:	47 95       	ror	r20
    12e6:	8a 95       	dec	r24
    12e8:	e2 f7       	brpl	.-8      	; 0x12e2 <DIO_u8GetPinValue+0x154>
    12ea:	ca 01       	movw	r24, r20
    12ec:	81 70       	andi	r24, 0x01	; 1
    12ee:	90 70       	andi	r25, 0x00	; 0
    12f0:	00 97       	sbiw	r24, 0x00	; 0
    12f2:	21 f4       	brne	.+8      	; 0x12fc <DIO_u8GetPinValue+0x16e>
			   {
				   *Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    12f4:	ec 81       	ldd	r30, Y+4	; 0x04
    12f6:	fd 81       	ldd	r31, Y+5	; 0x05
    12f8:	10 82       	st	Z, r1
    12fa:	48 c0       	rjmp	.+144    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   }
			   else if(GET_BIT(PINC_u8_REG,Copy_u8PinID)!=0)
    12fc:	e3 e3       	ldi	r30, 0x33	; 51
    12fe:	f0 e0       	ldi	r31, 0x00	; 0
    1300:	80 81       	ld	r24, Z
    1302:	28 2f       	mov	r18, r24
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	8b 81       	ldd	r24, Y+3	; 0x03
    1308:	88 2f       	mov	r24, r24
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	a9 01       	movw	r20, r18
    130e:	02 c0       	rjmp	.+4      	; 0x1314 <DIO_u8GetPinValue+0x186>
    1310:	55 95       	asr	r21
    1312:	47 95       	ror	r20
    1314:	8a 95       	dec	r24
    1316:	e2 f7       	brpl	.-8      	; 0x1310 <DIO_u8GetPinValue+0x182>
    1318:	ca 01       	movw	r24, r20
    131a:	81 70       	andi	r24, 0x01	; 1
    131c:	90 70       	andi	r25, 0x00	; 0
    131e:	88 23       	and	r24, r24
    1320:	a9 f1       	breq	.+106    	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   {
				   *Copy_pu8ReturnedPinValue =DIO_u8_HIGH;
    1322:	ec 81       	ldd	r30, Y+4	; 0x04
    1324:	fd 81       	ldd	r31, Y+5	; 0x05
    1326:	81 e0       	ldi	r24, 0x01	; 1
    1328:	80 83       	st	Z, r24
    132a:	30 c0       	rjmp	.+96     	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   }
			break;
			case DIO_u8_PORTD: 
			   if(GET_BIT(PIND_u8_REG,Copy_u8PinID)== 0)
    132c:	e0 e3       	ldi	r30, 0x30	; 48
    132e:	f0 e0       	ldi	r31, 0x00	; 0
    1330:	80 81       	ld	r24, Z
    1332:	28 2f       	mov	r18, r24
    1334:	30 e0       	ldi	r19, 0x00	; 0
    1336:	8b 81       	ldd	r24, Y+3	; 0x03
    1338:	88 2f       	mov	r24, r24
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	a9 01       	movw	r20, r18
    133e:	02 c0       	rjmp	.+4      	; 0x1344 <DIO_u8GetPinValue+0x1b6>
    1340:	55 95       	asr	r21
    1342:	47 95       	ror	r20
    1344:	8a 95       	dec	r24
    1346:	e2 f7       	brpl	.-8      	; 0x1340 <DIO_u8GetPinValue+0x1b2>
    1348:	ca 01       	movw	r24, r20
    134a:	81 70       	andi	r24, 0x01	; 1
    134c:	90 70       	andi	r25, 0x00	; 0
    134e:	00 97       	sbiw	r24, 0x00	; 0
    1350:	21 f4       	brne	.+8      	; 0x135a <DIO_u8GetPinValue+0x1cc>
			   {
				   *Copy_pu8ReturnedPinValue = DIO_u8_LOW;
    1352:	ec 81       	ldd	r30, Y+4	; 0x04
    1354:	fd 81       	ldd	r31, Y+5	; 0x05
    1356:	10 82       	st	Z, r1
    1358:	19 c0       	rjmp	.+50     	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   }
			   else if(GET_BIT(PIND_u8_REG,Copy_u8PinID)!=0)
    135a:	e0 e3       	ldi	r30, 0x30	; 48
    135c:	f0 e0       	ldi	r31, 0x00	; 0
    135e:	80 81       	ld	r24, Z
    1360:	28 2f       	mov	r18, r24
    1362:	30 e0       	ldi	r19, 0x00	; 0
    1364:	8b 81       	ldd	r24, Y+3	; 0x03
    1366:	88 2f       	mov	r24, r24
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	a9 01       	movw	r20, r18
    136c:	02 c0       	rjmp	.+4      	; 0x1372 <DIO_u8GetPinValue+0x1e4>
    136e:	55 95       	asr	r21
    1370:	47 95       	ror	r20
    1372:	8a 95       	dec	r24
    1374:	e2 f7       	brpl	.-8      	; 0x136e <DIO_u8GetPinValue+0x1e0>
    1376:	ca 01       	movw	r24, r20
    1378:	81 70       	andi	r24, 0x01	; 1
    137a:	90 70       	andi	r25, 0x00	; 0
    137c:	88 23       	and	r24, r24
    137e:	31 f0       	breq	.+12     	; 0x138c <DIO_u8GetPinValue+0x1fe>
			   {
				   *Copy_pu8ReturnedPinValue =DIO_u8_HIGH;
    1380:	ec 81       	ldd	r30, Y+4	; 0x04
    1382:	fd 81       	ldd	r31, Y+5	; 0x05
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	80 83       	st	Z, r24
    1388:	01 c0       	rjmp	.+2      	; 0x138c <DIO_u8GetPinValue+0x1fe>
			break;
		}
	}
	else
	{
		Local_u8ReturnState = STD_TYPES_NOK;
    138a:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnState;
    138c:	89 81       	ldd	r24, Y+1	; 0x01
}
    138e:	27 96       	adiw	r28, 0x07	; 7
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	de bf       	out	0x3e, r29	; 62
    1396:	0f be       	out	0x3f, r0	; 63
    1398:	cd bf       	out	0x3d, r28	; 61
    139a:	cf 91       	pop	r28
    139c:	df 91       	pop	r29
    139e:	08 95       	ret

000013a0 <DIO_u8SetPortDirection>:
u8 DIO_u8SetPortDirection(u8 Copy_u8PortID, u8 Copy_u8PortDirection )
{
    13a0:	df 93       	push	r29
    13a2:	cf 93       	push	r28
    13a4:	cd b7       	in	r28, 0x3d	; 61
    13a6:	de b7       	in	r29, 0x3e	; 62
    13a8:	2d 97       	sbiw	r28, 0x0d	; 13
    13aa:	0f b6       	in	r0, 0x3f	; 63
    13ac:	f8 94       	cli
    13ae:	de bf       	out	0x3e, r29	; 62
    13b0:	0f be       	out	0x3f, r0	; 63
    13b2:	cd bf       	out	0x3d, r28	; 61
    13b4:	8a 83       	std	Y+2, r24	; 0x02
    13b6:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ReturnState = STD_TYPES_OK;
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8PortID <= DIO_u8_PORTD) && ((Copy_u8PortDirection == DIO_u8_OUTPUT) || (Copy_u8PortDirection == DIO_u8_INPUT)))
    13bc:	8a 81       	ldd	r24, Y+2	; 0x02
    13be:	84 30       	cpi	r24, 0x04	; 4
    13c0:	08 f0       	brcs	.+2      	; 0x13c4 <DIO_u8SetPortDirection+0x24>
    13c2:	87 c0       	rjmp	.+270    	; 0x14d2 <DIO_u8SetPortDirection+0x132>
    13c4:	8b 81       	ldd	r24, Y+3	; 0x03
    13c6:	81 30       	cpi	r24, 0x01	; 1
    13c8:	21 f0       	breq	.+8      	; 0x13d2 <DIO_u8SetPortDirection+0x32>
    13ca:	8b 81       	ldd	r24, Y+3	; 0x03
    13cc:	88 23       	and	r24, r24
    13ce:	09 f0       	breq	.+2      	; 0x13d2 <DIO_u8SetPortDirection+0x32>
    13d0:	80 c0       	rjmp	.+256    	; 0x14d2 <DIO_u8SetPortDirection+0x132>
	{
		switch(Copy_u8PortID)
    13d2:	8a 81       	ldd	r24, Y+2	; 0x02
    13d4:	28 2f       	mov	r18, r24
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	3d 87       	std	Y+13, r19	; 0x0d
    13da:	2c 87       	std	Y+12, r18	; 0x0c
    13dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    13de:	9d 85       	ldd	r25, Y+13	; 0x0d
    13e0:	81 30       	cpi	r24, 0x01	; 1
    13e2:	91 05       	cpc	r25, r1
    13e4:	71 f1       	breq	.+92     	; 0x1442 <DIO_u8SetPortDirection+0xa2>
    13e6:	2c 85       	ldd	r18, Y+12	; 0x0c
    13e8:	3d 85       	ldd	r19, Y+13	; 0x0d
    13ea:	22 30       	cpi	r18, 0x02	; 2
    13ec:	31 05       	cpc	r19, r1
    13ee:	2c f4       	brge	.+10     	; 0x13fa <DIO_u8SetPortDirection+0x5a>
    13f0:	8c 85       	ldd	r24, Y+12	; 0x0c
    13f2:	9d 85       	ldd	r25, Y+13	; 0x0d
    13f4:	00 97       	sbiw	r24, 0x00	; 0
    13f6:	69 f0       	breq	.+26     	; 0x1412 <DIO_u8SetPortDirection+0x72>
    13f8:	6d c0       	rjmp	.+218    	; 0x14d4 <DIO_u8SetPortDirection+0x134>
    13fa:	2c 85       	ldd	r18, Y+12	; 0x0c
    13fc:	3d 85       	ldd	r19, Y+13	; 0x0d
    13fe:	22 30       	cpi	r18, 0x02	; 2
    1400:	31 05       	cpc	r19, r1
    1402:	b9 f1       	breq	.+110    	; 0x1472 <DIO_u8SetPortDirection+0xd2>
    1404:	8c 85       	ldd	r24, Y+12	; 0x0c
    1406:	9d 85       	ldd	r25, Y+13	; 0x0d
    1408:	83 30       	cpi	r24, 0x03	; 3
    140a:	91 05       	cpc	r25, r1
    140c:	09 f4       	brne	.+2      	; 0x1410 <DIO_u8SetPortDirection+0x70>
    140e:	49 c0       	rjmp	.+146    	; 0x14a2 <DIO_u8SetPortDirection+0x102>
    1410:	61 c0       	rjmp	.+194    	; 0x14d4 <DIO_u8SetPortDirection+0x134>
		{
			case DIO_u8_PORTA:
			switch(Copy_u8PortDirection)
    1412:	8b 81       	ldd	r24, Y+3	; 0x03
    1414:	28 2f       	mov	r18, r24
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	3b 87       	std	Y+11, r19	; 0x0b
    141a:	2a 87       	std	Y+10, r18	; 0x0a
    141c:	8a 85       	ldd	r24, Y+10	; 0x0a
    141e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1420:	00 97       	sbiw	r24, 0x00	; 0
    1422:	31 f0       	breq	.+12     	; 0x1430 <DIO_u8SetPortDirection+0x90>
    1424:	2a 85       	ldd	r18, Y+10	; 0x0a
    1426:	3b 85       	ldd	r19, Y+11	; 0x0b
    1428:	21 30       	cpi	r18, 0x01	; 1
    142a:	31 05       	cpc	r19, r1
    142c:	29 f0       	breq	.+10     	; 0x1438 <DIO_u8SetPortDirection+0x98>
    142e:	52 c0       	rjmp	.+164    	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			{
				case DIO_u8_INPUT: DDRA_u8_REG = 0x00;break;
    1430:	ea e3       	ldi	r30, 0x3A	; 58
    1432:	f0 e0       	ldi	r31, 0x00	; 0
    1434:	10 82       	st	Z, r1
    1436:	4e c0       	rjmp	.+156    	; 0x14d4 <DIO_u8SetPortDirection+0x134>
				case DIO_u8_OUTPUT:DDRA_u8_REG = 0xFF;break;
    1438:	ea e3       	ldi	r30, 0x3A	; 58
    143a:	f0 e0       	ldi	r31, 0x00	; 0
    143c:	8f ef       	ldi	r24, 0xFF	; 255
    143e:	80 83       	st	Z, r24
    1440:	49 c0       	rjmp	.+146    	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			}
			break;
			case DIO_u8_PORTB:
			switch(Copy_u8PortDirection)
    1442:	8b 81       	ldd	r24, Y+3	; 0x03
    1444:	28 2f       	mov	r18, r24
    1446:	30 e0       	ldi	r19, 0x00	; 0
    1448:	39 87       	std	Y+9, r19	; 0x09
    144a:	28 87       	std	Y+8, r18	; 0x08
    144c:	88 85       	ldd	r24, Y+8	; 0x08
    144e:	99 85       	ldd	r25, Y+9	; 0x09
    1450:	00 97       	sbiw	r24, 0x00	; 0
    1452:	31 f0       	breq	.+12     	; 0x1460 <DIO_u8SetPortDirection+0xc0>
    1454:	28 85       	ldd	r18, Y+8	; 0x08
    1456:	39 85       	ldd	r19, Y+9	; 0x09
    1458:	21 30       	cpi	r18, 0x01	; 1
    145a:	31 05       	cpc	r19, r1
    145c:	29 f0       	breq	.+10     	; 0x1468 <DIO_u8SetPortDirection+0xc8>
    145e:	3a c0       	rjmp	.+116    	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			{
				case DIO_u8_INPUT: DDRB_u8_REG = 0x00;break;
    1460:	e7 e3       	ldi	r30, 0x37	; 55
    1462:	f0 e0       	ldi	r31, 0x00	; 0
    1464:	10 82       	st	Z, r1
    1466:	36 c0       	rjmp	.+108    	; 0x14d4 <DIO_u8SetPortDirection+0x134>
				case DIO_u8_OUTPUT:DDRB_u8_REG = 0xFF;break;
    1468:	e7 e3       	ldi	r30, 0x37	; 55
    146a:	f0 e0       	ldi	r31, 0x00	; 0
    146c:	8f ef       	ldi	r24, 0xFF	; 255
    146e:	80 83       	st	Z, r24
    1470:	31 c0       	rjmp	.+98     	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			}
			break;
			case DIO_u8_PORTC:
			switch(Copy_u8PortDirection)
    1472:	8b 81       	ldd	r24, Y+3	; 0x03
    1474:	28 2f       	mov	r18, r24
    1476:	30 e0       	ldi	r19, 0x00	; 0
    1478:	3f 83       	std	Y+7, r19	; 0x07
    147a:	2e 83       	std	Y+6, r18	; 0x06
    147c:	8e 81       	ldd	r24, Y+6	; 0x06
    147e:	9f 81       	ldd	r25, Y+7	; 0x07
    1480:	00 97       	sbiw	r24, 0x00	; 0
    1482:	31 f0       	breq	.+12     	; 0x1490 <DIO_u8SetPortDirection+0xf0>
    1484:	2e 81       	ldd	r18, Y+6	; 0x06
    1486:	3f 81       	ldd	r19, Y+7	; 0x07
    1488:	21 30       	cpi	r18, 0x01	; 1
    148a:	31 05       	cpc	r19, r1
    148c:	29 f0       	breq	.+10     	; 0x1498 <DIO_u8SetPortDirection+0xf8>
    148e:	22 c0       	rjmp	.+68     	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			{
				case DIO_u8_INPUT: DDRC_u8_REG = 0x00;break;
    1490:	e4 e3       	ldi	r30, 0x34	; 52
    1492:	f0 e0       	ldi	r31, 0x00	; 0
    1494:	10 82       	st	Z, r1
    1496:	1e c0       	rjmp	.+60     	; 0x14d4 <DIO_u8SetPortDirection+0x134>
				case DIO_u8_OUTPUT:DDRC_u8_REG = 0xFF;break;
    1498:	e4 e3       	ldi	r30, 0x34	; 52
    149a:	f0 e0       	ldi	r31, 0x00	; 0
    149c:	8f ef       	ldi	r24, 0xFF	; 255
    149e:	80 83       	st	Z, r24
    14a0:	19 c0       	rjmp	.+50     	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			}
			break;
			case DIO_u8_PORTD:
			switch(Copy_u8PortDirection)
    14a2:	8b 81       	ldd	r24, Y+3	; 0x03
    14a4:	28 2f       	mov	r18, r24
    14a6:	30 e0       	ldi	r19, 0x00	; 0
    14a8:	3d 83       	std	Y+5, r19	; 0x05
    14aa:	2c 83       	std	Y+4, r18	; 0x04
    14ac:	8c 81       	ldd	r24, Y+4	; 0x04
    14ae:	9d 81       	ldd	r25, Y+5	; 0x05
    14b0:	00 97       	sbiw	r24, 0x00	; 0
    14b2:	31 f0       	breq	.+12     	; 0x14c0 <DIO_u8SetPortDirection+0x120>
    14b4:	2c 81       	ldd	r18, Y+4	; 0x04
    14b6:	3d 81       	ldd	r19, Y+5	; 0x05
    14b8:	21 30       	cpi	r18, 0x01	; 1
    14ba:	31 05       	cpc	r19, r1
    14bc:	29 f0       	breq	.+10     	; 0x14c8 <DIO_u8SetPortDirection+0x128>
    14be:	0a c0       	rjmp	.+20     	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			{
				case DIO_u8_INPUT: DDRD_u8_REG = 0x00;break;
    14c0:	e1 e3       	ldi	r30, 0x31	; 49
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	10 82       	st	Z, r1
    14c6:	06 c0       	rjmp	.+12     	; 0x14d4 <DIO_u8SetPortDirection+0x134>
				case DIO_u8_OUTPUT:DDRD_u8_REG = 0xFF;break;
    14c8:	e1 e3       	ldi	r30, 0x31	; 49
    14ca:	f0 e0       	ldi	r31, 0x00	; 0
    14cc:	8f ef       	ldi	r24, 0xFF	; 255
    14ce:	80 83       	st	Z, r24
    14d0:	01 c0       	rjmp	.+2      	; 0x14d4 <DIO_u8SetPortDirection+0x134>
			break;
		}
	}
	else
	{
		Local_u8ReturnState = STD_TYPES_NOK;
    14d2:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnState;
    14d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    14d6:	2d 96       	adiw	r28, 0x0d	; 13
    14d8:	0f b6       	in	r0, 0x3f	; 63
    14da:	f8 94       	cli
    14dc:	de bf       	out	0x3e, r29	; 62
    14de:	0f be       	out	0x3f, r0	; 63
    14e0:	cd bf       	out	0x3d, r28	; 61
    14e2:	cf 91       	pop	r28
    14e4:	df 91       	pop	r29
    14e6:	08 95       	ret

000014e8 <DIO_u8SetPortValue>:

u8 DIO_u8SetPortValue    (u8 Copy_u8PortID, u8 Copy_u8PortValue)
{
    14e8:	df 93       	push	r29
    14ea:	cf 93       	push	r28
    14ec:	00 d0       	rcall	.+0      	; 0x14ee <DIO_u8SetPortValue+0x6>
    14ee:	00 d0       	rcall	.+0      	; 0x14f0 <DIO_u8SetPortValue+0x8>
    14f0:	0f 92       	push	r0
    14f2:	cd b7       	in	r28, 0x3d	; 61
    14f4:	de b7       	in	r29, 0x3e	; 62
    14f6:	8a 83       	std	Y+2, r24	; 0x02
    14f8:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ReturnState = STD_TYPES_OK;
    14fa:	81 e0       	ldi	r24, 0x01	; 1
    14fc:	89 83       	std	Y+1, r24	; 0x01
	switch(Copy_u8PortID)
    14fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1500:	28 2f       	mov	r18, r24
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	3d 83       	std	Y+5, r19	; 0x05
    1506:	2c 83       	std	Y+4, r18	; 0x04
    1508:	8c 81       	ldd	r24, Y+4	; 0x04
    150a:	9d 81       	ldd	r25, Y+5	; 0x05
    150c:	81 30       	cpi	r24, 0x01	; 1
    150e:	91 05       	cpc	r25, r1
    1510:	d1 f0       	breq	.+52     	; 0x1546 <DIO_u8SetPortValue+0x5e>
    1512:	2c 81       	ldd	r18, Y+4	; 0x04
    1514:	3d 81       	ldd	r19, Y+5	; 0x05
    1516:	22 30       	cpi	r18, 0x02	; 2
    1518:	31 05       	cpc	r19, r1
    151a:	2c f4       	brge	.+10     	; 0x1526 <DIO_u8SetPortValue+0x3e>
    151c:	8c 81       	ldd	r24, Y+4	; 0x04
    151e:	9d 81       	ldd	r25, Y+5	; 0x05
    1520:	00 97       	sbiw	r24, 0x00	; 0
    1522:	61 f0       	breq	.+24     	; 0x153c <DIO_u8SetPortValue+0x54>
    1524:	1f c0       	rjmp	.+62     	; 0x1564 <DIO_u8SetPortValue+0x7c>
    1526:	2c 81       	ldd	r18, Y+4	; 0x04
    1528:	3d 81       	ldd	r19, Y+5	; 0x05
    152a:	22 30       	cpi	r18, 0x02	; 2
    152c:	31 05       	cpc	r19, r1
    152e:	81 f0       	breq	.+32     	; 0x1550 <DIO_u8SetPortValue+0x68>
    1530:	8c 81       	ldd	r24, Y+4	; 0x04
    1532:	9d 81       	ldd	r25, Y+5	; 0x05
    1534:	83 30       	cpi	r24, 0x03	; 3
    1536:	91 05       	cpc	r25, r1
    1538:	81 f0       	breq	.+32     	; 0x155a <DIO_u8SetPortValue+0x72>
    153a:	14 c0       	rjmp	.+40     	; 0x1564 <DIO_u8SetPortValue+0x7c>
	{
		case DIO_u8_PORTA:PORTA_u8_REG = Copy_u8PortValue; break;
    153c:	eb e3       	ldi	r30, 0x3B	; 59
    153e:	f0 e0       	ldi	r31, 0x00	; 0
    1540:	8b 81       	ldd	r24, Y+3	; 0x03
    1542:	80 83       	st	Z, r24
    1544:	10 c0       	rjmp	.+32     	; 0x1566 <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTB:PORTB_u8_REG = Copy_u8PortValue; break;
    1546:	e8 e3       	ldi	r30, 0x38	; 56
    1548:	f0 e0       	ldi	r31, 0x00	; 0
    154a:	8b 81       	ldd	r24, Y+3	; 0x03
    154c:	80 83       	st	Z, r24
    154e:	0b c0       	rjmp	.+22     	; 0x1566 <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTC:PORTC_u8_REG = Copy_u8PortValue; break;
    1550:	e5 e3       	ldi	r30, 0x35	; 53
    1552:	f0 e0       	ldi	r31, 0x00	; 0
    1554:	8b 81       	ldd	r24, Y+3	; 0x03
    1556:	80 83       	st	Z, r24
    1558:	06 c0       	rjmp	.+12     	; 0x1566 <DIO_u8SetPortValue+0x7e>
		case DIO_u8_PORTD:PORTD_u8_REG = Copy_u8PortValue; break;
    155a:	e2 e3       	ldi	r30, 0x32	; 50
    155c:	f0 e0       	ldi	r31, 0x00	; 0
    155e:	8b 81       	ldd	r24, Y+3	; 0x03
    1560:	80 83       	st	Z, r24
    1562:	01 c0       	rjmp	.+2      	; 0x1566 <DIO_u8SetPortValue+0x7e>
		default : Local_u8ReturnState = STD_TYPES_NOK;
    1564:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnState;
    1566:	89 81       	ldd	r24, Y+1	; 0x01
}
    1568:	0f 90       	pop	r0
    156a:	0f 90       	pop	r0
    156c:	0f 90       	pop	r0
    156e:	0f 90       	pop	r0
    1570:	0f 90       	pop	r0
    1572:	cf 91       	pop	r28
    1574:	df 91       	pop	r29
    1576:	08 95       	ret

00001578 <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue    (u8 Copy_u8PortID, u8 * Copy_pu8ReturnedPortValue)
{
    1578:	df 93       	push	r29
    157a:	cf 93       	push	r28
    157c:	00 d0       	rcall	.+0      	; 0x157e <DIO_u8GetPortValue+0x6>
    157e:	00 d0       	rcall	.+0      	; 0x1580 <DIO_u8GetPortValue+0x8>
    1580:	00 d0       	rcall	.+0      	; 0x1582 <DIO_u8GetPortValue+0xa>
    1582:	cd b7       	in	r28, 0x3d	; 61
    1584:	de b7       	in	r29, 0x3e	; 62
    1586:	8a 83       	std	Y+2, r24	; 0x02
    1588:	7c 83       	std	Y+4, r23	; 0x04
    158a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ReturnState = STD_TYPES_OK;
    158c:	81 e0       	ldi	r24, 0x01	; 1
    158e:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_pu8ReturnedPortValue != NULL)
    1590:	8b 81       	ldd	r24, Y+3	; 0x03
    1592:	9c 81       	ldd	r25, Y+4	; 0x04
    1594:	00 97       	sbiw	r24, 0x00	; 0
    1596:	e9 f1       	breq	.+122    	; 0x1612 <DIO_u8GetPortValue+0x9a>
	{
		switch(Copy_u8PortID)
    1598:	8a 81       	ldd	r24, Y+2	; 0x02
    159a:	28 2f       	mov	r18, r24
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	3e 83       	std	Y+6, r19	; 0x06
    15a0:	2d 83       	std	Y+5, r18	; 0x05
    15a2:	8d 81       	ldd	r24, Y+5	; 0x05
    15a4:	9e 81       	ldd	r25, Y+6	; 0x06
    15a6:	81 30       	cpi	r24, 0x01	; 1
    15a8:	91 05       	cpc	r25, r1
    15aa:	e1 f0       	breq	.+56     	; 0x15e4 <DIO_u8GetPortValue+0x6c>
    15ac:	2d 81       	ldd	r18, Y+5	; 0x05
    15ae:	3e 81       	ldd	r19, Y+6	; 0x06
    15b0:	22 30       	cpi	r18, 0x02	; 2
    15b2:	31 05       	cpc	r19, r1
    15b4:	2c f4       	brge	.+10     	; 0x15c0 <DIO_u8GetPortValue+0x48>
    15b6:	8d 81       	ldd	r24, Y+5	; 0x05
    15b8:	9e 81       	ldd	r25, Y+6	; 0x06
    15ba:	00 97       	sbiw	r24, 0x00	; 0
    15bc:	61 f0       	breq	.+24     	; 0x15d6 <DIO_u8GetPortValue+0x5e>
    15be:	27 c0       	rjmp	.+78     	; 0x160e <DIO_u8GetPortValue+0x96>
    15c0:	2d 81       	ldd	r18, Y+5	; 0x05
    15c2:	3e 81       	ldd	r19, Y+6	; 0x06
    15c4:	22 30       	cpi	r18, 0x02	; 2
    15c6:	31 05       	cpc	r19, r1
    15c8:	a1 f0       	breq	.+40     	; 0x15f2 <DIO_u8GetPortValue+0x7a>
    15ca:	8d 81       	ldd	r24, Y+5	; 0x05
    15cc:	9e 81       	ldd	r25, Y+6	; 0x06
    15ce:	83 30       	cpi	r24, 0x03	; 3
    15d0:	91 05       	cpc	r25, r1
    15d2:	b1 f0       	breq	.+44     	; 0x1600 <DIO_u8GetPortValue+0x88>
    15d4:	1c c0       	rjmp	.+56     	; 0x160e <DIO_u8GetPortValue+0x96>
		{
		   case DIO_u8_PORTA: *Copy_pu8ReturnedPortValue = PINA_u8_REG; break;
    15d6:	e9 e3       	ldi	r30, 0x39	; 57
    15d8:	f0 e0       	ldi	r31, 0x00	; 0
    15da:	80 81       	ld	r24, Z
    15dc:	eb 81       	ldd	r30, Y+3	; 0x03
    15de:	fc 81       	ldd	r31, Y+4	; 0x04
    15e0:	80 83       	st	Z, r24
    15e2:	18 c0       	rjmp	.+48     	; 0x1614 <DIO_u8GetPortValue+0x9c>
		   case DIO_u8_PORTB: *Copy_pu8ReturnedPortValue = PINB_u8_REG; break;
    15e4:	e6 e3       	ldi	r30, 0x36	; 54
    15e6:	f0 e0       	ldi	r31, 0x00	; 0
    15e8:	80 81       	ld	r24, Z
    15ea:	eb 81       	ldd	r30, Y+3	; 0x03
    15ec:	fc 81       	ldd	r31, Y+4	; 0x04
    15ee:	80 83       	st	Z, r24
    15f0:	11 c0       	rjmp	.+34     	; 0x1614 <DIO_u8GetPortValue+0x9c>
		   case DIO_u8_PORTC: *Copy_pu8ReturnedPortValue = PINC_u8_REG; break;
    15f2:	e3 e3       	ldi	r30, 0x33	; 51
    15f4:	f0 e0       	ldi	r31, 0x00	; 0
    15f6:	80 81       	ld	r24, Z
    15f8:	eb 81       	ldd	r30, Y+3	; 0x03
    15fa:	fc 81       	ldd	r31, Y+4	; 0x04
    15fc:	80 83       	st	Z, r24
    15fe:	0a c0       	rjmp	.+20     	; 0x1614 <DIO_u8GetPortValue+0x9c>
		   case DIO_u8_PORTD: *Copy_pu8ReturnedPortValue = PIND_u8_REG; break;
    1600:	e0 e3       	ldi	r30, 0x30	; 48
    1602:	f0 e0       	ldi	r31, 0x00	; 0
    1604:	80 81       	ld	r24, Z
    1606:	eb 81       	ldd	r30, Y+3	; 0x03
    1608:	fc 81       	ldd	r31, Y+4	; 0x04
    160a:	80 83       	st	Z, r24
    160c:	03 c0       	rjmp	.+6      	; 0x1614 <DIO_u8GetPortValue+0x9c>
		   default : Local_u8ReturnState = STD_TYPES_NOK;
    160e:	19 82       	std	Y+1, r1	; 0x01
    1610:	01 c0       	rjmp	.+2      	; 0x1614 <DIO_u8GetPortValue+0x9c>
		}
	}
	else
	{
		Local_u8ReturnState = STD_TYPES_NOK;
    1612:	19 82       	std	Y+1, r1	; 0x01
	}
	return Local_u8ReturnState;
    1614:	89 81       	ldd	r24, Y+1	; 0x01
    1616:	26 96       	adiw	r28, 0x06	; 6
    1618:	0f b6       	in	r0, 0x3f	; 63
    161a:	f8 94       	cli
    161c:	de bf       	out	0x3e, r29	; 62
    161e:	0f be       	out	0x3f, r0	; 63
    1620:	cd bf       	out	0x3d, r28	; 61
    1622:	cf 91       	pop	r28
    1624:	df 91       	pop	r29
    1626:	08 95       	ret

00001628 <LCD_voidInit>:
#include "LCD_interface.h"
#include "LCD_private.h"
#include "LCD_config.h"

void LCD_voidInit     (void)
{
    1628:	0f 93       	push	r16
    162a:	1f 93       	push	r17
    162c:	df 93       	push	r29
    162e:	cf 93       	push	r28
    1630:	cd b7       	in	r28, 0x3d	; 61
    1632:	de b7       	in	r29, 0x3e	; 62
    1634:	cc 54       	subi	r28, 0x4C	; 76
    1636:	d0 40       	sbci	r29, 0x00	; 0
    1638:	0f b6       	in	r0, 0x3f	; 63
    163a:	f8 94       	cli
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	cd bf       	out	0x3d, r28	; 61
    1642:	fe 01       	movw	r30, r28
    1644:	e7 5b       	subi	r30, 0xB7	; 183
    1646:	ff 4f       	sbci	r31, 0xFF	; 255
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	ac e0       	ldi	r26, 0x0C	; 12
    164e:	b2 e4       	ldi	r27, 0x42	; 66
    1650:	80 83       	st	Z, r24
    1652:	91 83       	std	Z+1, r25	; 0x01
    1654:	a2 83       	std	Z+2, r26	; 0x02
    1656:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1658:	8e 01       	movw	r16, r28
    165a:	0b 5b       	subi	r16, 0xBB	; 187
    165c:	1f 4f       	sbci	r17, 0xFF	; 255
    165e:	fe 01       	movw	r30, r28
    1660:	e7 5b       	subi	r30, 0xB7	; 183
    1662:	ff 4f       	sbci	r31, 0xFF	; 255
    1664:	60 81       	ld	r22, Z
    1666:	71 81       	ldd	r23, Z+1	; 0x01
    1668:	82 81       	ldd	r24, Z+2	; 0x02
    166a:	93 81       	ldd	r25, Z+3	; 0x03
    166c:	20 e0       	ldi	r18, 0x00	; 0
    166e:	30 e0       	ldi	r19, 0x00	; 0
    1670:	4a ef       	ldi	r20, 0xFA	; 250
    1672:	54 e4       	ldi	r21, 0x44	; 68
    1674:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1678:	dc 01       	movw	r26, r24
    167a:	cb 01       	movw	r24, r22
    167c:	f8 01       	movw	r30, r16
    167e:	80 83       	st	Z, r24
    1680:	91 83       	std	Z+1, r25	; 0x01
    1682:	a2 83       	std	Z+2, r26	; 0x02
    1684:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1686:	fe 01       	movw	r30, r28
    1688:	eb 5b       	subi	r30, 0xBB	; 187
    168a:	ff 4f       	sbci	r31, 0xFF	; 255
    168c:	60 81       	ld	r22, Z
    168e:	71 81       	ldd	r23, Z+1	; 0x01
    1690:	82 81       	ldd	r24, Z+2	; 0x02
    1692:	93 81       	ldd	r25, Z+3	; 0x03
    1694:	20 e0       	ldi	r18, 0x00	; 0
    1696:	30 e0       	ldi	r19, 0x00	; 0
    1698:	40 e8       	ldi	r20, 0x80	; 128
    169a:	5f e3       	ldi	r21, 0x3F	; 63
    169c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    16a0:	88 23       	and	r24, r24
    16a2:	44 f4       	brge	.+16     	; 0x16b4 <LCD_voidInit+0x8c>
		__ticks = 1;
    16a4:	fe 01       	movw	r30, r28
    16a6:	ed 5b       	subi	r30, 0xBD	; 189
    16a8:	ff 4f       	sbci	r31, 0xFF	; 255
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	91 83       	std	Z+1, r25	; 0x01
    16b0:	80 83       	st	Z, r24
    16b2:	64 c0       	rjmp	.+200    	; 0x177c <LCD_voidInit+0x154>
	else if (__tmp > 65535)
    16b4:	fe 01       	movw	r30, r28
    16b6:	eb 5b       	subi	r30, 0xBB	; 187
    16b8:	ff 4f       	sbci	r31, 0xFF	; 255
    16ba:	60 81       	ld	r22, Z
    16bc:	71 81       	ldd	r23, Z+1	; 0x01
    16be:	82 81       	ldd	r24, Z+2	; 0x02
    16c0:	93 81       	ldd	r25, Z+3	; 0x03
    16c2:	20 e0       	ldi	r18, 0x00	; 0
    16c4:	3f ef       	ldi	r19, 0xFF	; 255
    16c6:	4f e7       	ldi	r20, 0x7F	; 127
    16c8:	57 e4       	ldi	r21, 0x47	; 71
    16ca:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    16ce:	18 16       	cp	r1, r24
    16d0:	0c f0       	brlt	.+2      	; 0x16d4 <LCD_voidInit+0xac>
    16d2:	43 c0       	rjmp	.+134    	; 0x175a <LCD_voidInit+0x132>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    16d4:	fe 01       	movw	r30, r28
    16d6:	e7 5b       	subi	r30, 0xB7	; 183
    16d8:	ff 4f       	sbci	r31, 0xFF	; 255
    16da:	60 81       	ld	r22, Z
    16dc:	71 81       	ldd	r23, Z+1	; 0x01
    16de:	82 81       	ldd	r24, Z+2	; 0x02
    16e0:	93 81       	ldd	r25, Z+3	; 0x03
    16e2:	20 e0       	ldi	r18, 0x00	; 0
    16e4:	30 e0       	ldi	r19, 0x00	; 0
    16e6:	40 e2       	ldi	r20, 0x20	; 32
    16e8:	51 e4       	ldi	r21, 0x41	; 65
    16ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16ee:	dc 01       	movw	r26, r24
    16f0:	cb 01       	movw	r24, r22
    16f2:	8e 01       	movw	r16, r28
    16f4:	0d 5b       	subi	r16, 0xBD	; 189
    16f6:	1f 4f       	sbci	r17, 0xFF	; 255
    16f8:	bc 01       	movw	r22, r24
    16fa:	cd 01       	movw	r24, r26
    16fc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1700:	dc 01       	movw	r26, r24
    1702:	cb 01       	movw	r24, r22
    1704:	f8 01       	movw	r30, r16
    1706:	91 83       	std	Z+1, r25	; 0x01
    1708:	80 83       	st	Z, r24
    170a:	1f c0       	rjmp	.+62     	; 0x174a <LCD_voidInit+0x122>
    170c:	fe 01       	movw	r30, r28
    170e:	ef 5b       	subi	r30, 0xBF	; 191
    1710:	ff 4f       	sbci	r31, 0xFF	; 255
    1712:	88 ec       	ldi	r24, 0xC8	; 200
    1714:	90 e0       	ldi	r25, 0x00	; 0
    1716:	91 83       	std	Z+1, r25	; 0x01
    1718:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    171a:	fe 01       	movw	r30, r28
    171c:	ef 5b       	subi	r30, 0xBF	; 191
    171e:	ff 4f       	sbci	r31, 0xFF	; 255
    1720:	80 81       	ld	r24, Z
    1722:	91 81       	ldd	r25, Z+1	; 0x01
    1724:	01 97       	sbiw	r24, 0x01	; 1
    1726:	f1 f7       	brne	.-4      	; 0x1724 <LCD_voidInit+0xfc>
    1728:	fe 01       	movw	r30, r28
    172a:	ef 5b       	subi	r30, 0xBF	; 191
    172c:	ff 4f       	sbci	r31, 0xFF	; 255
    172e:	91 83       	std	Z+1, r25	; 0x01
    1730:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1732:	de 01       	movw	r26, r28
    1734:	ad 5b       	subi	r26, 0xBD	; 189
    1736:	bf 4f       	sbci	r27, 0xFF	; 255
    1738:	fe 01       	movw	r30, r28
    173a:	ed 5b       	subi	r30, 0xBD	; 189
    173c:	ff 4f       	sbci	r31, 0xFF	; 255
    173e:	80 81       	ld	r24, Z
    1740:	91 81       	ldd	r25, Z+1	; 0x01
    1742:	01 97       	sbiw	r24, 0x01	; 1
    1744:	11 96       	adiw	r26, 0x01	; 1
    1746:	9c 93       	st	X, r25
    1748:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    174a:	fe 01       	movw	r30, r28
    174c:	ed 5b       	subi	r30, 0xBD	; 189
    174e:	ff 4f       	sbci	r31, 0xFF	; 255
    1750:	80 81       	ld	r24, Z
    1752:	91 81       	ldd	r25, Z+1	; 0x01
    1754:	00 97       	sbiw	r24, 0x00	; 0
    1756:	d1 f6       	brne	.-76     	; 0x170c <LCD_voidInit+0xe4>
    1758:	24 c0       	rjmp	.+72     	; 0x17a2 <LCD_voidInit+0x17a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    175a:	8e 01       	movw	r16, r28
    175c:	0d 5b       	subi	r16, 0xBD	; 189
    175e:	1f 4f       	sbci	r17, 0xFF	; 255
    1760:	fe 01       	movw	r30, r28
    1762:	eb 5b       	subi	r30, 0xBB	; 187
    1764:	ff 4f       	sbci	r31, 0xFF	; 255
    1766:	60 81       	ld	r22, Z
    1768:	71 81       	ldd	r23, Z+1	; 0x01
    176a:	82 81       	ldd	r24, Z+2	; 0x02
    176c:	93 81       	ldd	r25, Z+3	; 0x03
    176e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1772:	dc 01       	movw	r26, r24
    1774:	cb 01       	movw	r24, r22
    1776:	f8 01       	movw	r30, r16
    1778:	91 83       	std	Z+1, r25	; 0x01
    177a:	80 83       	st	Z, r24
    177c:	fe 01       	movw	r30, r28
    177e:	ed 5b       	subi	r30, 0xBD	; 189
    1780:	ff 4f       	sbci	r31, 0xFF	; 255
    1782:	80 81       	ld	r24, Z
    1784:	91 81       	ldd	r25, Z+1	; 0x01
    1786:	fe 01       	movw	r30, r28
    1788:	ff 96       	adiw	r30, 0x3f	; 63
    178a:	91 83       	std	Z+1, r25	; 0x01
    178c:	80 83       	st	Z, r24
    178e:	fe 01       	movw	r30, r28
    1790:	ff 96       	adiw	r30, 0x3f	; 63
    1792:	80 81       	ld	r24, Z
    1794:	91 81       	ldd	r25, Z+1	; 0x01
    1796:	01 97       	sbiw	r24, 0x01	; 1
    1798:	f1 f7       	brne	.-4      	; 0x1796 <LCD_voidInit+0x16e>
    179a:	fe 01       	movw	r30, r28
    179c:	ff 96       	adiw	r30, 0x3f	; 63
    179e:	91 83       	std	Z+1, r25	; 0x01
    17a0:	80 83       	st	Z, r24
	_delay_ms(35);
	/* Function Set Cmnd 0b00111000 */
	LCD_voidSendCmnd(0b00111000);
    17a2:	88 e3       	ldi	r24, 0x38	; 56
    17a4:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    17a8:	80 e0       	ldi	r24, 0x00	; 0
    17aa:	90 e0       	ldi	r25, 0x00	; 0
    17ac:	a0 e2       	ldi	r26, 0x20	; 32
    17ae:	b2 e4       	ldi	r27, 0x42	; 66
    17b0:	8b af       	std	Y+59, r24	; 0x3b
    17b2:	9c af       	std	Y+60, r25	; 0x3c
    17b4:	ad af       	std	Y+61, r26	; 0x3d
    17b6:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    17b8:	6b ad       	ldd	r22, Y+59	; 0x3b
    17ba:	7c ad       	ldd	r23, Y+60	; 0x3c
    17bc:	8d ad       	ldd	r24, Y+61	; 0x3d
    17be:	9e ad       	ldd	r25, Y+62	; 0x3e
    17c0:	2b ea       	ldi	r18, 0xAB	; 171
    17c2:	3a ea       	ldi	r19, 0xAA	; 170
    17c4:	4a e2       	ldi	r20, 0x2A	; 42
    17c6:	50 e4       	ldi	r21, 0x40	; 64
    17c8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17cc:	dc 01       	movw	r26, r24
    17ce:	cb 01       	movw	r24, r22
    17d0:	8f ab       	std	Y+55, r24	; 0x37
    17d2:	98 af       	std	Y+56, r25	; 0x38
    17d4:	a9 af       	std	Y+57, r26	; 0x39
    17d6:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    17d8:	6f a9       	ldd	r22, Y+55	; 0x37
    17da:	78 ad       	ldd	r23, Y+56	; 0x38
    17dc:	89 ad       	ldd	r24, Y+57	; 0x39
    17de:	9a ad       	ldd	r25, Y+58	; 0x3a
    17e0:	20 e0       	ldi	r18, 0x00	; 0
    17e2:	30 e0       	ldi	r19, 0x00	; 0
    17e4:	40 e8       	ldi	r20, 0x80	; 128
    17e6:	5f e3       	ldi	r21, 0x3F	; 63
    17e8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    17ec:	88 23       	and	r24, r24
    17ee:	1c f4       	brge	.+6      	; 0x17f6 <LCD_voidInit+0x1ce>
		__ticks = 1;
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	8e ab       	std	Y+54, r24	; 0x36
    17f4:	91 c0       	rjmp	.+290    	; 0x1918 <LCD_voidInit+0x2f0>
	else if (__tmp > 255)
    17f6:	6f a9       	ldd	r22, Y+55	; 0x37
    17f8:	78 ad       	ldd	r23, Y+56	; 0x38
    17fa:	89 ad       	ldd	r24, Y+57	; 0x39
    17fc:	9a ad       	ldd	r25, Y+58	; 0x3a
    17fe:	20 e0       	ldi	r18, 0x00	; 0
    1800:	30 e0       	ldi	r19, 0x00	; 0
    1802:	4f e7       	ldi	r20, 0x7F	; 127
    1804:	53 e4       	ldi	r21, 0x43	; 67
    1806:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    180a:	18 16       	cp	r1, r24
    180c:	0c f0       	brlt	.+2      	; 0x1810 <LCD_voidInit+0x1e8>
    180e:	7b c0       	rjmp	.+246    	; 0x1906 <LCD_voidInit+0x2de>
	{
		_delay_ms(__us / 1000.0);
    1810:	6b ad       	ldd	r22, Y+59	; 0x3b
    1812:	7c ad       	ldd	r23, Y+60	; 0x3c
    1814:	8d ad       	ldd	r24, Y+61	; 0x3d
    1816:	9e ad       	ldd	r25, Y+62	; 0x3e
    1818:	20 e0       	ldi	r18, 0x00	; 0
    181a:	30 e0       	ldi	r19, 0x00	; 0
    181c:	4a e7       	ldi	r20, 0x7A	; 122
    181e:	54 e4       	ldi	r21, 0x44	; 68
    1820:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1824:	dc 01       	movw	r26, r24
    1826:	cb 01       	movw	r24, r22
    1828:	8a ab       	std	Y+50, r24	; 0x32
    182a:	9b ab       	std	Y+51, r25	; 0x33
    182c:	ac ab       	std	Y+52, r26	; 0x34
    182e:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1830:	6a a9       	ldd	r22, Y+50	; 0x32
    1832:	7b a9       	ldd	r23, Y+51	; 0x33
    1834:	8c a9       	ldd	r24, Y+52	; 0x34
    1836:	9d a9       	ldd	r25, Y+53	; 0x35
    1838:	20 e0       	ldi	r18, 0x00	; 0
    183a:	30 e0       	ldi	r19, 0x00	; 0
    183c:	4a ef       	ldi	r20, 0xFA	; 250
    183e:	54 e4       	ldi	r21, 0x44	; 68
    1840:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1844:	dc 01       	movw	r26, r24
    1846:	cb 01       	movw	r24, r22
    1848:	8e a7       	std	Y+46, r24	; 0x2e
    184a:	9f a7       	std	Y+47, r25	; 0x2f
    184c:	a8 ab       	std	Y+48, r26	; 0x30
    184e:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    1850:	6e a5       	ldd	r22, Y+46	; 0x2e
    1852:	7f a5       	ldd	r23, Y+47	; 0x2f
    1854:	88 a9       	ldd	r24, Y+48	; 0x30
    1856:	99 a9       	ldd	r25, Y+49	; 0x31
    1858:	20 e0       	ldi	r18, 0x00	; 0
    185a:	30 e0       	ldi	r19, 0x00	; 0
    185c:	40 e8       	ldi	r20, 0x80	; 128
    185e:	5f e3       	ldi	r21, 0x3F	; 63
    1860:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1864:	88 23       	and	r24, r24
    1866:	2c f4       	brge	.+10     	; 0x1872 <LCD_voidInit+0x24a>
		__ticks = 1;
    1868:	81 e0       	ldi	r24, 0x01	; 1
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	9d a7       	std	Y+45, r25	; 0x2d
    186e:	8c a7       	std	Y+44, r24	; 0x2c
    1870:	3f c0       	rjmp	.+126    	; 0x18f0 <LCD_voidInit+0x2c8>
	else if (__tmp > 65535)
    1872:	6e a5       	ldd	r22, Y+46	; 0x2e
    1874:	7f a5       	ldd	r23, Y+47	; 0x2f
    1876:	88 a9       	ldd	r24, Y+48	; 0x30
    1878:	99 a9       	ldd	r25, Y+49	; 0x31
    187a:	20 e0       	ldi	r18, 0x00	; 0
    187c:	3f ef       	ldi	r19, 0xFF	; 255
    187e:	4f e7       	ldi	r20, 0x7F	; 127
    1880:	57 e4       	ldi	r21, 0x47	; 71
    1882:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1886:	18 16       	cp	r1, r24
    1888:	4c f5       	brge	.+82     	; 0x18dc <LCD_voidInit+0x2b4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    188a:	6a a9       	ldd	r22, Y+50	; 0x32
    188c:	7b a9       	ldd	r23, Y+51	; 0x33
    188e:	8c a9       	ldd	r24, Y+52	; 0x34
    1890:	9d a9       	ldd	r25, Y+53	; 0x35
    1892:	20 e0       	ldi	r18, 0x00	; 0
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	40 e2       	ldi	r20, 0x20	; 32
    1898:	51 e4       	ldi	r21, 0x41	; 65
    189a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    189e:	dc 01       	movw	r26, r24
    18a0:	cb 01       	movw	r24, r22
    18a2:	bc 01       	movw	r22, r24
    18a4:	cd 01       	movw	r24, r26
    18a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18aa:	dc 01       	movw	r26, r24
    18ac:	cb 01       	movw	r24, r22
    18ae:	9d a7       	std	Y+45, r25	; 0x2d
    18b0:	8c a7       	std	Y+44, r24	; 0x2c
    18b2:	0f c0       	rjmp	.+30     	; 0x18d2 <LCD_voidInit+0x2aa>
    18b4:	88 ec       	ldi	r24, 0xC8	; 200
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	9b a7       	std	Y+43, r25	; 0x2b
    18ba:	8a a7       	std	Y+42, r24	; 0x2a
    18bc:	8a a5       	ldd	r24, Y+42	; 0x2a
    18be:	9b a5       	ldd	r25, Y+43	; 0x2b
    18c0:	01 97       	sbiw	r24, 0x01	; 1
    18c2:	f1 f7       	brne	.-4      	; 0x18c0 <LCD_voidInit+0x298>
    18c4:	9b a7       	std	Y+43, r25	; 0x2b
    18c6:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18c8:	8c a5       	ldd	r24, Y+44	; 0x2c
    18ca:	9d a5       	ldd	r25, Y+45	; 0x2d
    18cc:	01 97       	sbiw	r24, 0x01	; 1
    18ce:	9d a7       	std	Y+45, r25	; 0x2d
    18d0:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18d2:	8c a5       	ldd	r24, Y+44	; 0x2c
    18d4:	9d a5       	ldd	r25, Y+45	; 0x2d
    18d6:	00 97       	sbiw	r24, 0x00	; 0
    18d8:	69 f7       	brne	.-38     	; 0x18b4 <LCD_voidInit+0x28c>
    18da:	24 c0       	rjmp	.+72     	; 0x1924 <LCD_voidInit+0x2fc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18dc:	6e a5       	ldd	r22, Y+46	; 0x2e
    18de:	7f a5       	ldd	r23, Y+47	; 0x2f
    18e0:	88 a9       	ldd	r24, Y+48	; 0x30
    18e2:	99 a9       	ldd	r25, Y+49	; 0x31
    18e4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18e8:	dc 01       	movw	r26, r24
    18ea:	cb 01       	movw	r24, r22
    18ec:	9d a7       	std	Y+45, r25	; 0x2d
    18ee:	8c a7       	std	Y+44, r24	; 0x2c
    18f0:	8c a5       	ldd	r24, Y+44	; 0x2c
    18f2:	9d a5       	ldd	r25, Y+45	; 0x2d
    18f4:	99 a7       	std	Y+41, r25	; 0x29
    18f6:	88 a7       	std	Y+40, r24	; 0x28
    18f8:	88 a5       	ldd	r24, Y+40	; 0x28
    18fa:	99 a5       	ldd	r25, Y+41	; 0x29
    18fc:	01 97       	sbiw	r24, 0x01	; 1
    18fe:	f1 f7       	brne	.-4      	; 0x18fc <LCD_voidInit+0x2d4>
    1900:	99 a7       	std	Y+41, r25	; 0x29
    1902:	88 a7       	std	Y+40, r24	; 0x28
    1904:	0f c0       	rjmp	.+30     	; 0x1924 <LCD_voidInit+0x2fc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1906:	6f a9       	ldd	r22, Y+55	; 0x37
    1908:	78 ad       	ldd	r23, Y+56	; 0x38
    190a:	89 ad       	ldd	r24, Y+57	; 0x39
    190c:	9a ad       	ldd	r25, Y+58	; 0x3a
    190e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1912:	dc 01       	movw	r26, r24
    1914:	cb 01       	movw	r24, r22
    1916:	8e ab       	std	Y+54, r24	; 0x36
    1918:	8e a9       	ldd	r24, Y+54	; 0x36
    191a:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    191c:	8f a1       	ldd	r24, Y+39	; 0x27
    191e:	8a 95       	dec	r24
    1920:	f1 f7       	brne	.-4      	; 0x191e <LCD_voidInit+0x2f6>
    1922:	8f a3       	std	Y+39, r24	; 0x27
	_delay_us(40);
	LCD_voidSendCmnd(0b00001111);
    1924:	8f e0       	ldi	r24, 0x0F	; 15
    1926:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    192a:	80 e0       	ldi	r24, 0x00	; 0
    192c:	90 e0       	ldi	r25, 0x00	; 0
    192e:	a0 e2       	ldi	r26, 0x20	; 32
    1930:	b2 e4       	ldi	r27, 0x42	; 66
    1932:	8b a3       	std	Y+35, r24	; 0x23
    1934:	9c a3       	std	Y+36, r25	; 0x24
    1936:	ad a3       	std	Y+37, r26	; 0x25
    1938:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    193a:	6b a1       	ldd	r22, Y+35	; 0x23
    193c:	7c a1       	ldd	r23, Y+36	; 0x24
    193e:	8d a1       	ldd	r24, Y+37	; 0x25
    1940:	9e a1       	ldd	r25, Y+38	; 0x26
    1942:	2b ea       	ldi	r18, 0xAB	; 171
    1944:	3a ea       	ldi	r19, 0xAA	; 170
    1946:	4a e2       	ldi	r20, 0x2A	; 42
    1948:	50 e4       	ldi	r21, 0x40	; 64
    194a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    194e:	dc 01       	movw	r26, r24
    1950:	cb 01       	movw	r24, r22
    1952:	8f 8f       	std	Y+31, r24	; 0x1f
    1954:	98 a3       	std	Y+32, r25	; 0x20
    1956:	a9 a3       	std	Y+33, r26	; 0x21
    1958:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    195a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    195c:	78 a1       	ldd	r23, Y+32	; 0x20
    195e:	89 a1       	ldd	r24, Y+33	; 0x21
    1960:	9a a1       	ldd	r25, Y+34	; 0x22
    1962:	20 e0       	ldi	r18, 0x00	; 0
    1964:	30 e0       	ldi	r19, 0x00	; 0
    1966:	40 e8       	ldi	r20, 0x80	; 128
    1968:	5f e3       	ldi	r21, 0x3F	; 63
    196a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    196e:	88 23       	and	r24, r24
    1970:	1c f4       	brge	.+6      	; 0x1978 <LCD_voidInit+0x350>
		__ticks = 1;
    1972:	81 e0       	ldi	r24, 0x01	; 1
    1974:	8e 8f       	std	Y+30, r24	; 0x1e
    1976:	91 c0       	rjmp	.+290    	; 0x1a9a <LCD_voidInit+0x472>
	else if (__tmp > 255)
    1978:	6f 8d       	ldd	r22, Y+31	; 0x1f
    197a:	78 a1       	ldd	r23, Y+32	; 0x20
    197c:	89 a1       	ldd	r24, Y+33	; 0x21
    197e:	9a a1       	ldd	r25, Y+34	; 0x22
    1980:	20 e0       	ldi	r18, 0x00	; 0
    1982:	30 e0       	ldi	r19, 0x00	; 0
    1984:	4f e7       	ldi	r20, 0x7F	; 127
    1986:	53 e4       	ldi	r21, 0x43	; 67
    1988:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    198c:	18 16       	cp	r1, r24
    198e:	0c f0       	brlt	.+2      	; 0x1992 <LCD_voidInit+0x36a>
    1990:	7b c0       	rjmp	.+246    	; 0x1a88 <LCD_voidInit+0x460>
	{
		_delay_ms(__us / 1000.0);
    1992:	6b a1       	ldd	r22, Y+35	; 0x23
    1994:	7c a1       	ldd	r23, Y+36	; 0x24
    1996:	8d a1       	ldd	r24, Y+37	; 0x25
    1998:	9e a1       	ldd	r25, Y+38	; 0x26
    199a:	20 e0       	ldi	r18, 0x00	; 0
    199c:	30 e0       	ldi	r19, 0x00	; 0
    199e:	4a e7       	ldi	r20, 0x7A	; 122
    19a0:	54 e4       	ldi	r21, 0x44	; 68
    19a2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    19a6:	dc 01       	movw	r26, r24
    19a8:	cb 01       	movw	r24, r22
    19aa:	8a 8f       	std	Y+26, r24	; 0x1a
    19ac:	9b 8f       	std	Y+27, r25	; 0x1b
    19ae:	ac 8f       	std	Y+28, r26	; 0x1c
    19b0:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    19b2:	6a 8d       	ldd	r22, Y+26	; 0x1a
    19b4:	7b 8d       	ldd	r23, Y+27	; 0x1b
    19b6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    19b8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    19ba:	20 e0       	ldi	r18, 0x00	; 0
    19bc:	30 e0       	ldi	r19, 0x00	; 0
    19be:	4a ef       	ldi	r20, 0xFA	; 250
    19c0:	54 e4       	ldi	r21, 0x44	; 68
    19c2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19c6:	dc 01       	movw	r26, r24
    19c8:	cb 01       	movw	r24, r22
    19ca:	8e 8b       	std	Y+22, r24	; 0x16
    19cc:	9f 8b       	std	Y+23, r25	; 0x17
    19ce:	a8 8f       	std	Y+24, r26	; 0x18
    19d0:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    19d2:	6e 89       	ldd	r22, Y+22	; 0x16
    19d4:	7f 89       	ldd	r23, Y+23	; 0x17
    19d6:	88 8d       	ldd	r24, Y+24	; 0x18
    19d8:	99 8d       	ldd	r25, Y+25	; 0x19
    19da:	20 e0       	ldi	r18, 0x00	; 0
    19dc:	30 e0       	ldi	r19, 0x00	; 0
    19de:	40 e8       	ldi	r20, 0x80	; 128
    19e0:	5f e3       	ldi	r21, 0x3F	; 63
    19e2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    19e6:	88 23       	and	r24, r24
    19e8:	2c f4       	brge	.+10     	; 0x19f4 <LCD_voidInit+0x3cc>
		__ticks = 1;
    19ea:	81 e0       	ldi	r24, 0x01	; 1
    19ec:	90 e0       	ldi	r25, 0x00	; 0
    19ee:	9d 8b       	std	Y+21, r25	; 0x15
    19f0:	8c 8b       	std	Y+20, r24	; 0x14
    19f2:	3f c0       	rjmp	.+126    	; 0x1a72 <LCD_voidInit+0x44a>
	else if (__tmp > 65535)
    19f4:	6e 89       	ldd	r22, Y+22	; 0x16
    19f6:	7f 89       	ldd	r23, Y+23	; 0x17
    19f8:	88 8d       	ldd	r24, Y+24	; 0x18
    19fa:	99 8d       	ldd	r25, Y+25	; 0x19
    19fc:	20 e0       	ldi	r18, 0x00	; 0
    19fe:	3f ef       	ldi	r19, 0xFF	; 255
    1a00:	4f e7       	ldi	r20, 0x7F	; 127
    1a02:	57 e4       	ldi	r21, 0x47	; 71
    1a04:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1a08:	18 16       	cp	r1, r24
    1a0a:	4c f5       	brge	.+82     	; 0x1a5e <LCD_voidInit+0x436>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1a0c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1a0e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1a10:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a12:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1a14:	20 e0       	ldi	r18, 0x00	; 0
    1a16:	30 e0       	ldi	r19, 0x00	; 0
    1a18:	40 e2       	ldi	r20, 0x20	; 32
    1a1a:	51 e4       	ldi	r21, 0x41	; 65
    1a1c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1a20:	dc 01       	movw	r26, r24
    1a22:	cb 01       	movw	r24, r22
    1a24:	bc 01       	movw	r22, r24
    1a26:	cd 01       	movw	r24, r26
    1a28:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a2c:	dc 01       	movw	r26, r24
    1a2e:	cb 01       	movw	r24, r22
    1a30:	9d 8b       	std	Y+21, r25	; 0x15
    1a32:	8c 8b       	std	Y+20, r24	; 0x14
    1a34:	0f c0       	rjmp	.+30     	; 0x1a54 <LCD_voidInit+0x42c>
    1a36:	88 ec       	ldi	r24, 0xC8	; 200
    1a38:	90 e0       	ldi	r25, 0x00	; 0
    1a3a:	9b 8b       	std	Y+19, r25	; 0x13
    1a3c:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1a3e:	8a 89       	ldd	r24, Y+18	; 0x12
    1a40:	9b 89       	ldd	r25, Y+19	; 0x13
    1a42:	01 97       	sbiw	r24, 0x01	; 1
    1a44:	f1 f7       	brne	.-4      	; 0x1a42 <LCD_voidInit+0x41a>
    1a46:	9b 8b       	std	Y+19, r25	; 0x13
    1a48:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a4a:	8c 89       	ldd	r24, Y+20	; 0x14
    1a4c:	9d 89       	ldd	r25, Y+21	; 0x15
    1a4e:	01 97       	sbiw	r24, 0x01	; 1
    1a50:	9d 8b       	std	Y+21, r25	; 0x15
    1a52:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a54:	8c 89       	ldd	r24, Y+20	; 0x14
    1a56:	9d 89       	ldd	r25, Y+21	; 0x15
    1a58:	00 97       	sbiw	r24, 0x00	; 0
    1a5a:	69 f7       	brne	.-38     	; 0x1a36 <LCD_voidInit+0x40e>
    1a5c:	24 c0       	rjmp	.+72     	; 0x1aa6 <LCD_voidInit+0x47e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a5e:	6e 89       	ldd	r22, Y+22	; 0x16
    1a60:	7f 89       	ldd	r23, Y+23	; 0x17
    1a62:	88 8d       	ldd	r24, Y+24	; 0x18
    1a64:	99 8d       	ldd	r25, Y+25	; 0x19
    1a66:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a6a:	dc 01       	movw	r26, r24
    1a6c:	cb 01       	movw	r24, r22
    1a6e:	9d 8b       	std	Y+21, r25	; 0x15
    1a70:	8c 8b       	std	Y+20, r24	; 0x14
    1a72:	8c 89       	ldd	r24, Y+20	; 0x14
    1a74:	9d 89       	ldd	r25, Y+21	; 0x15
    1a76:	99 8b       	std	Y+17, r25	; 0x11
    1a78:	88 8b       	std	Y+16, r24	; 0x10
    1a7a:	88 89       	ldd	r24, Y+16	; 0x10
    1a7c:	99 89       	ldd	r25, Y+17	; 0x11
    1a7e:	01 97       	sbiw	r24, 0x01	; 1
    1a80:	f1 f7       	brne	.-4      	; 0x1a7e <LCD_voidInit+0x456>
    1a82:	99 8b       	std	Y+17, r25	; 0x11
    1a84:	88 8b       	std	Y+16, r24	; 0x10
    1a86:	0f c0       	rjmp	.+30     	; 0x1aa6 <LCD_voidInit+0x47e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1a88:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a8a:	78 a1       	ldd	r23, Y+32	; 0x20
    1a8c:	89 a1       	ldd	r24, Y+33	; 0x21
    1a8e:	9a a1       	ldd	r25, Y+34	; 0x22
    1a90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a94:	dc 01       	movw	r26, r24
    1a96:	cb 01       	movw	r24, r22
    1a98:	8e 8f       	std	Y+30, r24	; 0x1e
    1a9a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a9c:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1a9e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1aa0:	8a 95       	dec	r24
    1aa2:	f1 f7       	brne	.-4      	; 0x1aa0 <LCD_voidInit+0x478>
    1aa4:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_us(40);
	LCD_voidSendCmnd(0b00000001);
    1aa6:	81 e0       	ldi	r24, 0x01	; 1
    1aa8:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    1aac:	80 e0       	ldi	r24, 0x00	; 0
    1aae:	90 e0       	ldi	r25, 0x00	; 0
    1ab0:	a0 e0       	ldi	r26, 0x00	; 0
    1ab2:	b0 e4       	ldi	r27, 0x40	; 64
    1ab4:	8b 87       	std	Y+11, r24	; 0x0b
    1ab6:	9c 87       	std	Y+12, r25	; 0x0c
    1ab8:	ad 87       	std	Y+13, r26	; 0x0d
    1aba:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1abc:	6b 85       	ldd	r22, Y+11	; 0x0b
    1abe:	7c 85       	ldd	r23, Y+12	; 0x0c
    1ac0:	8d 85       	ldd	r24, Y+13	; 0x0d
    1ac2:	9e 85       	ldd	r25, Y+14	; 0x0e
    1ac4:	20 e0       	ldi	r18, 0x00	; 0
    1ac6:	30 e0       	ldi	r19, 0x00	; 0
    1ac8:	4a ef       	ldi	r20, 0xFA	; 250
    1aca:	54 e4       	ldi	r21, 0x44	; 68
    1acc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ad0:	dc 01       	movw	r26, r24
    1ad2:	cb 01       	movw	r24, r22
    1ad4:	8f 83       	std	Y+7, r24	; 0x07
    1ad6:	98 87       	std	Y+8, r25	; 0x08
    1ad8:	a9 87       	std	Y+9, r26	; 0x09
    1ada:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1adc:	6f 81       	ldd	r22, Y+7	; 0x07
    1ade:	78 85       	ldd	r23, Y+8	; 0x08
    1ae0:	89 85       	ldd	r24, Y+9	; 0x09
    1ae2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ae4:	20 e0       	ldi	r18, 0x00	; 0
    1ae6:	30 e0       	ldi	r19, 0x00	; 0
    1ae8:	40 e8       	ldi	r20, 0x80	; 128
    1aea:	5f e3       	ldi	r21, 0x3F	; 63
    1aec:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1af0:	88 23       	and	r24, r24
    1af2:	2c f4       	brge	.+10     	; 0x1afe <LCD_voidInit+0x4d6>
		__ticks = 1;
    1af4:	81 e0       	ldi	r24, 0x01	; 1
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	9e 83       	std	Y+6, r25	; 0x06
    1afa:	8d 83       	std	Y+5, r24	; 0x05
    1afc:	3f c0       	rjmp	.+126    	; 0x1b7c <LCD_voidInit+0x554>
	else if (__tmp > 65535)
    1afe:	6f 81       	ldd	r22, Y+7	; 0x07
    1b00:	78 85       	ldd	r23, Y+8	; 0x08
    1b02:	89 85       	ldd	r24, Y+9	; 0x09
    1b04:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b06:	20 e0       	ldi	r18, 0x00	; 0
    1b08:	3f ef       	ldi	r19, 0xFF	; 255
    1b0a:	4f e7       	ldi	r20, 0x7F	; 127
    1b0c:	57 e4       	ldi	r21, 0x47	; 71
    1b0e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1b12:	18 16       	cp	r1, r24
    1b14:	4c f5       	brge	.+82     	; 0x1b68 <LCD_voidInit+0x540>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b16:	6b 85       	ldd	r22, Y+11	; 0x0b
    1b18:	7c 85       	ldd	r23, Y+12	; 0x0c
    1b1a:	8d 85       	ldd	r24, Y+13	; 0x0d
    1b1c:	9e 85       	ldd	r25, Y+14	; 0x0e
    1b1e:	20 e0       	ldi	r18, 0x00	; 0
    1b20:	30 e0       	ldi	r19, 0x00	; 0
    1b22:	40 e2       	ldi	r20, 0x20	; 32
    1b24:	51 e4       	ldi	r21, 0x41	; 65
    1b26:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b2a:	dc 01       	movw	r26, r24
    1b2c:	cb 01       	movw	r24, r22
    1b2e:	bc 01       	movw	r22, r24
    1b30:	cd 01       	movw	r24, r26
    1b32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b36:	dc 01       	movw	r26, r24
    1b38:	cb 01       	movw	r24, r22
    1b3a:	9e 83       	std	Y+6, r25	; 0x06
    1b3c:	8d 83       	std	Y+5, r24	; 0x05
    1b3e:	0f c0       	rjmp	.+30     	; 0x1b5e <LCD_voidInit+0x536>
    1b40:	88 ec       	ldi	r24, 0xC8	; 200
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	9c 83       	std	Y+4, r25	; 0x04
    1b46:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4c:	01 97       	sbiw	r24, 0x01	; 1
    1b4e:	f1 f7       	brne	.-4      	; 0x1b4c <LCD_voidInit+0x524>
    1b50:	9c 83       	std	Y+4, r25	; 0x04
    1b52:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b54:	8d 81       	ldd	r24, Y+5	; 0x05
    1b56:	9e 81       	ldd	r25, Y+6	; 0x06
    1b58:	01 97       	sbiw	r24, 0x01	; 1
    1b5a:	9e 83       	std	Y+6, r25	; 0x06
    1b5c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1b60:	9e 81       	ldd	r25, Y+6	; 0x06
    1b62:	00 97       	sbiw	r24, 0x00	; 0
    1b64:	69 f7       	brne	.-38     	; 0x1b40 <LCD_voidInit+0x518>
    1b66:	14 c0       	rjmp	.+40     	; 0x1b90 <LCD_voidInit+0x568>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1b68:	6f 81       	ldd	r22, Y+7	; 0x07
    1b6a:	78 85       	ldd	r23, Y+8	; 0x08
    1b6c:	89 85       	ldd	r24, Y+9	; 0x09
    1b6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b74:	dc 01       	movw	r26, r24
    1b76:	cb 01       	movw	r24, r22
    1b78:	9e 83       	std	Y+6, r25	; 0x06
    1b7a:	8d 83       	std	Y+5, r24	; 0x05
    1b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1b80:	9a 83       	std	Y+2, r25	; 0x02
    1b82:	89 83       	std	Y+1, r24	; 0x01
    1b84:	89 81       	ldd	r24, Y+1	; 0x01
    1b86:	9a 81       	ldd	r25, Y+2	; 0x02
    1b88:	01 97       	sbiw	r24, 0x01	; 1
    1b8a:	f1 f7       	brne	.-4      	; 0x1b88 <LCD_voidInit+0x560>
    1b8c:	9a 83       	std	Y+2, r25	; 0x02
    1b8e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	LCD_voidSendCmnd(0b00000110);
    1b90:	86 e0       	ldi	r24, 0x06	; 6
    1b92:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
	
}
    1b96:	c4 5b       	subi	r28, 0xB4	; 180
    1b98:	df 4f       	sbci	r29, 0xFF	; 255
    1b9a:	0f b6       	in	r0, 0x3f	; 63
    1b9c:	f8 94       	cli
    1b9e:	de bf       	out	0x3e, r29	; 62
    1ba0:	0f be       	out	0x3f, r0	; 63
    1ba2:	cd bf       	out	0x3d, r28	; 61
    1ba4:	cf 91       	pop	r28
    1ba6:	df 91       	pop	r29
    1ba8:	1f 91       	pop	r17
    1baa:	0f 91       	pop	r16
    1bac:	08 95       	ret

00001bae <LCD_voidClear>:

void LCD_voidClear       (void)
{
    1bae:	df 93       	push	r29
    1bb0:	cf 93       	push	r28
    1bb2:	cd b7       	in	r28, 0x3d	; 61
    1bb4:	de b7       	in	r29, 0x3e	; 62
    1bb6:	2e 97       	sbiw	r28, 0x0e	; 14
    1bb8:	0f b6       	in	r0, 0x3f	; 63
    1bba:	f8 94       	cli
    1bbc:	de bf       	out	0x3e, r29	; 62
    1bbe:	0f be       	out	0x3f, r0	; 63
    1bc0:	cd bf       	out	0x3d, r28	; 61
	LCD_voidSendCmnd(0b00000001);
    1bc2:	81 e0       	ldi	r24, 0x01	; 1
    1bc4:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    1bc8:	80 e0       	ldi	r24, 0x00	; 0
    1bca:	90 e0       	ldi	r25, 0x00	; 0
    1bcc:	a0 ea       	ldi	r26, 0xA0	; 160
    1bce:	b1 e4       	ldi	r27, 0x41	; 65
    1bd0:	8b 87       	std	Y+11, r24	; 0x0b
    1bd2:	9c 87       	std	Y+12, r25	; 0x0c
    1bd4:	ad 87       	std	Y+13, r26	; 0x0d
    1bd6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1bd8:	6b 85       	ldd	r22, Y+11	; 0x0b
    1bda:	7c 85       	ldd	r23, Y+12	; 0x0c
    1bdc:	8d 85       	ldd	r24, Y+13	; 0x0d
    1bde:	9e 85       	ldd	r25, Y+14	; 0x0e
    1be0:	20 e0       	ldi	r18, 0x00	; 0
    1be2:	30 e0       	ldi	r19, 0x00	; 0
    1be4:	4a ef       	ldi	r20, 0xFA	; 250
    1be6:	54 e4       	ldi	r21, 0x44	; 68
    1be8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bec:	dc 01       	movw	r26, r24
    1bee:	cb 01       	movw	r24, r22
    1bf0:	8f 83       	std	Y+7, r24	; 0x07
    1bf2:	98 87       	std	Y+8, r25	; 0x08
    1bf4:	a9 87       	std	Y+9, r26	; 0x09
    1bf6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1bf8:	6f 81       	ldd	r22, Y+7	; 0x07
    1bfa:	78 85       	ldd	r23, Y+8	; 0x08
    1bfc:	89 85       	ldd	r24, Y+9	; 0x09
    1bfe:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c00:	20 e0       	ldi	r18, 0x00	; 0
    1c02:	30 e0       	ldi	r19, 0x00	; 0
    1c04:	40 e8       	ldi	r20, 0x80	; 128
    1c06:	5f e3       	ldi	r21, 0x3F	; 63
    1c08:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1c0c:	88 23       	and	r24, r24
    1c0e:	2c f4       	brge	.+10     	; 0x1c1a <LCD_voidClear+0x6c>
		__ticks = 1;
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	9e 83       	std	Y+6, r25	; 0x06
    1c16:	8d 83       	std	Y+5, r24	; 0x05
    1c18:	3f c0       	rjmp	.+126    	; 0x1c98 <LCD_voidClear+0xea>
	else if (__tmp > 65535)
    1c1a:	6f 81       	ldd	r22, Y+7	; 0x07
    1c1c:	78 85       	ldd	r23, Y+8	; 0x08
    1c1e:	89 85       	ldd	r24, Y+9	; 0x09
    1c20:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c22:	20 e0       	ldi	r18, 0x00	; 0
    1c24:	3f ef       	ldi	r19, 0xFF	; 255
    1c26:	4f e7       	ldi	r20, 0x7F	; 127
    1c28:	57 e4       	ldi	r21, 0x47	; 71
    1c2a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1c2e:	18 16       	cp	r1, r24
    1c30:	4c f5       	brge	.+82     	; 0x1c84 <LCD_voidClear+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c32:	6b 85       	ldd	r22, Y+11	; 0x0b
    1c34:	7c 85       	ldd	r23, Y+12	; 0x0c
    1c36:	8d 85       	ldd	r24, Y+13	; 0x0d
    1c38:	9e 85       	ldd	r25, Y+14	; 0x0e
    1c3a:	20 e0       	ldi	r18, 0x00	; 0
    1c3c:	30 e0       	ldi	r19, 0x00	; 0
    1c3e:	40 e2       	ldi	r20, 0x20	; 32
    1c40:	51 e4       	ldi	r21, 0x41	; 65
    1c42:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1c46:	dc 01       	movw	r26, r24
    1c48:	cb 01       	movw	r24, r22
    1c4a:	bc 01       	movw	r22, r24
    1c4c:	cd 01       	movw	r24, r26
    1c4e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c52:	dc 01       	movw	r26, r24
    1c54:	cb 01       	movw	r24, r22
    1c56:	9e 83       	std	Y+6, r25	; 0x06
    1c58:	8d 83       	std	Y+5, r24	; 0x05
    1c5a:	0f c0       	rjmp	.+30     	; 0x1c7a <LCD_voidClear+0xcc>
    1c5c:	88 ec       	ldi	r24, 0xC8	; 200
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	9c 83       	std	Y+4, r25	; 0x04
    1c62:	8b 83       	std	Y+3, r24	; 0x03
    1c64:	8b 81       	ldd	r24, Y+3	; 0x03
    1c66:	9c 81       	ldd	r25, Y+4	; 0x04
    1c68:	01 97       	sbiw	r24, 0x01	; 1
    1c6a:	f1 f7       	brne	.-4      	; 0x1c68 <LCD_voidClear+0xba>
    1c6c:	9c 83       	std	Y+4, r25	; 0x04
    1c6e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c70:	8d 81       	ldd	r24, Y+5	; 0x05
    1c72:	9e 81       	ldd	r25, Y+6	; 0x06
    1c74:	01 97       	sbiw	r24, 0x01	; 1
    1c76:	9e 83       	std	Y+6, r25	; 0x06
    1c78:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c7a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c7c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c7e:	00 97       	sbiw	r24, 0x00	; 0
    1c80:	69 f7       	brne	.-38     	; 0x1c5c <LCD_voidClear+0xae>
    1c82:	14 c0       	rjmp	.+40     	; 0x1cac <LCD_voidClear+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c84:	6f 81       	ldd	r22, Y+7	; 0x07
    1c86:	78 85       	ldd	r23, Y+8	; 0x08
    1c88:	89 85       	ldd	r24, Y+9	; 0x09
    1c8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1c8c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c90:	dc 01       	movw	r26, r24
    1c92:	cb 01       	movw	r24, r22
    1c94:	9e 83       	std	Y+6, r25	; 0x06
    1c96:	8d 83       	std	Y+5, r24	; 0x05
    1c98:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9c:	9a 83       	std	Y+2, r25	; 0x02
    1c9e:	89 83       	std	Y+1, r24	; 0x01
    1ca0:	89 81       	ldd	r24, Y+1	; 0x01
    1ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    1ca4:	01 97       	sbiw	r24, 0x01	; 1
    1ca6:	f1 f7       	brne	.-4      	; 0x1ca4 <LCD_voidClear+0xf6>
    1ca8:	9a 83       	std	Y+2, r25	; 0x02
    1caa:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(20);
}
    1cac:	2e 96       	adiw	r28, 0x0e	; 14
    1cae:	0f b6       	in	r0, 0x3f	; 63
    1cb0:	f8 94       	cli
    1cb2:	de bf       	out	0x3e, r29	; 62
    1cb4:	0f be       	out	0x3f, r0	; 63
    1cb6:	cd bf       	out	0x3d, r28	; 61
    1cb8:	cf 91       	pop	r28
    1cba:	df 91       	pop	r29
    1cbc:	08 95       	ret

00001cbe <LCD_voidCursorBlinkerOff>:

void LCD_voidCursorBlinkerOff(void)
{
    1cbe:	df 93       	push	r29
    1cc0:	cf 93       	push	r28
    1cc2:	cd b7       	in	r28, 0x3d	; 61
    1cc4:	de b7       	in	r29, 0x3e	; 62
    1cc6:	2e 97       	sbiw	r28, 0x0e	; 14
    1cc8:	0f b6       	in	r0, 0x3f	; 63
    1cca:	f8 94       	cli
    1ccc:	de bf       	out	0x3e, r29	; 62
    1cce:	0f be       	out	0x3f, r0	; 63
    1cd0:	cd bf       	out	0x3d, r28	; 61
	LCD_voidSendCmnd(0b00001100);
    1cd2:	8c e0       	ldi	r24, 0x0C	; 12
    1cd4:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    1cd8:	80 e0       	ldi	r24, 0x00	; 0
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	a0 ea       	ldi	r26, 0xA0	; 160
    1cde:	b1 e4       	ldi	r27, 0x41	; 65
    1ce0:	8b 87       	std	Y+11, r24	; 0x0b
    1ce2:	9c 87       	std	Y+12, r25	; 0x0c
    1ce4:	ad 87       	std	Y+13, r26	; 0x0d
    1ce6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1ce8:	6b 85       	ldd	r22, Y+11	; 0x0b
    1cea:	7c 85       	ldd	r23, Y+12	; 0x0c
    1cec:	8d 85       	ldd	r24, Y+13	; 0x0d
    1cee:	9e 85       	ldd	r25, Y+14	; 0x0e
    1cf0:	20 e0       	ldi	r18, 0x00	; 0
    1cf2:	30 e0       	ldi	r19, 0x00	; 0
    1cf4:	4a ef       	ldi	r20, 0xFA	; 250
    1cf6:	54 e4       	ldi	r21, 0x44	; 68
    1cf8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1cfc:	dc 01       	movw	r26, r24
    1cfe:	cb 01       	movw	r24, r22
    1d00:	8f 83       	std	Y+7, r24	; 0x07
    1d02:	98 87       	std	Y+8, r25	; 0x08
    1d04:	a9 87       	std	Y+9, r26	; 0x09
    1d06:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1d08:	6f 81       	ldd	r22, Y+7	; 0x07
    1d0a:	78 85       	ldd	r23, Y+8	; 0x08
    1d0c:	89 85       	ldd	r24, Y+9	; 0x09
    1d0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d10:	20 e0       	ldi	r18, 0x00	; 0
    1d12:	30 e0       	ldi	r19, 0x00	; 0
    1d14:	40 e8       	ldi	r20, 0x80	; 128
    1d16:	5f e3       	ldi	r21, 0x3F	; 63
    1d18:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1d1c:	88 23       	and	r24, r24
    1d1e:	2c f4       	brge	.+10     	; 0x1d2a <LCD_voidCursorBlinkerOff+0x6c>
		__ticks = 1;
    1d20:	81 e0       	ldi	r24, 0x01	; 1
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	9e 83       	std	Y+6, r25	; 0x06
    1d26:	8d 83       	std	Y+5, r24	; 0x05
    1d28:	3f c0       	rjmp	.+126    	; 0x1da8 <LCD_voidCursorBlinkerOff+0xea>
	else if (__tmp > 65535)
    1d2a:	6f 81       	ldd	r22, Y+7	; 0x07
    1d2c:	78 85       	ldd	r23, Y+8	; 0x08
    1d2e:	89 85       	ldd	r24, Y+9	; 0x09
    1d30:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d32:	20 e0       	ldi	r18, 0x00	; 0
    1d34:	3f ef       	ldi	r19, 0xFF	; 255
    1d36:	4f e7       	ldi	r20, 0x7F	; 127
    1d38:	57 e4       	ldi	r21, 0x47	; 71
    1d3a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1d3e:	18 16       	cp	r1, r24
    1d40:	4c f5       	brge	.+82     	; 0x1d94 <LCD_voidCursorBlinkerOff+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1d42:	6b 85       	ldd	r22, Y+11	; 0x0b
    1d44:	7c 85       	ldd	r23, Y+12	; 0x0c
    1d46:	8d 85       	ldd	r24, Y+13	; 0x0d
    1d48:	9e 85       	ldd	r25, Y+14	; 0x0e
    1d4a:	20 e0       	ldi	r18, 0x00	; 0
    1d4c:	30 e0       	ldi	r19, 0x00	; 0
    1d4e:	40 e2       	ldi	r20, 0x20	; 32
    1d50:	51 e4       	ldi	r21, 0x41	; 65
    1d52:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d56:	dc 01       	movw	r26, r24
    1d58:	cb 01       	movw	r24, r22
    1d5a:	bc 01       	movw	r22, r24
    1d5c:	cd 01       	movw	r24, r26
    1d5e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1d62:	dc 01       	movw	r26, r24
    1d64:	cb 01       	movw	r24, r22
    1d66:	9e 83       	std	Y+6, r25	; 0x06
    1d68:	8d 83       	std	Y+5, r24	; 0x05
    1d6a:	0f c0       	rjmp	.+30     	; 0x1d8a <LCD_voidCursorBlinkerOff+0xcc>
    1d6c:	88 ec       	ldi	r24, 0xC8	; 200
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	9c 83       	std	Y+4, r25	; 0x04
    1d72:	8b 83       	std	Y+3, r24	; 0x03
    1d74:	8b 81       	ldd	r24, Y+3	; 0x03
    1d76:	9c 81       	ldd	r25, Y+4	; 0x04
    1d78:	01 97       	sbiw	r24, 0x01	; 1
    1d7a:	f1 f7       	brne	.-4      	; 0x1d78 <LCD_voidCursorBlinkerOff+0xba>
    1d7c:	9c 83       	std	Y+4, r25	; 0x04
    1d7e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d80:	8d 81       	ldd	r24, Y+5	; 0x05
    1d82:	9e 81       	ldd	r25, Y+6	; 0x06
    1d84:	01 97       	sbiw	r24, 0x01	; 1
    1d86:	9e 83       	std	Y+6, r25	; 0x06
    1d88:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1d8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1d8e:	00 97       	sbiw	r24, 0x00	; 0
    1d90:	69 f7       	brne	.-38     	; 0x1d6c <LCD_voidCursorBlinkerOff+0xae>
    1d92:	14 c0       	rjmp	.+40     	; 0x1dbc <LCD_voidCursorBlinkerOff+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d94:	6f 81       	ldd	r22, Y+7	; 0x07
    1d96:	78 85       	ldd	r23, Y+8	; 0x08
    1d98:	89 85       	ldd	r24, Y+9	; 0x09
    1d9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1d9c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1da0:	dc 01       	movw	r26, r24
    1da2:	cb 01       	movw	r24, r22
    1da4:	9e 83       	std	Y+6, r25	; 0x06
    1da6:	8d 83       	std	Y+5, r24	; 0x05
    1da8:	8d 81       	ldd	r24, Y+5	; 0x05
    1daa:	9e 81       	ldd	r25, Y+6	; 0x06
    1dac:	9a 83       	std	Y+2, r25	; 0x02
    1dae:	89 83       	std	Y+1, r24	; 0x01
    1db0:	89 81       	ldd	r24, Y+1	; 0x01
    1db2:	9a 81       	ldd	r25, Y+2	; 0x02
    1db4:	01 97       	sbiw	r24, 0x01	; 1
    1db6:	f1 f7       	brne	.-4      	; 0x1db4 <LCD_voidCursorBlinkerOff+0xf6>
    1db8:	9a 83       	std	Y+2, r25	; 0x02
    1dba:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(20);
}
    1dbc:	2e 96       	adiw	r28, 0x0e	; 14
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	de bf       	out	0x3e, r29	; 62
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	cf 91       	pop	r28
    1dca:	df 91       	pop	r29
    1dcc:	08 95       	ret

00001dce <LCD_voidSendCmnd>:

void LCD_voidSendCmnd (u8 Copy_u8Cmnd)
{
    1dce:	df 93       	push	r29
    1dd0:	cf 93       	push	r28
    1dd2:	cd b7       	in	r28, 0x3d	; 61
    1dd4:	de b7       	in	r29, 0x3e	; 62
    1dd6:	e1 97       	sbiw	r28, 0x31	; 49
    1dd8:	0f b6       	in	r0, 0x3f	; 63
    1dda:	f8 94       	cli
    1ddc:	de bf       	out	0x3e, r29	; 62
    1dde:	0f be       	out	0x3f, r0	; 63
    1de0:	cd bf       	out	0x3d, r28	; 61
    1de2:	89 ab       	std	Y+49, r24	; 0x31
	/* Rs = 0 */
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_RS_PIN,DIO_u8_LOW);
    1de4:	82 e0       	ldi	r24, 0x02	; 2
    1de6:	65 e0       	ldi	r22, 0x05	; 5
    1de8:	40 e0       	ldi	r20, 0x00	; 0
    1dea:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
	/* Rw = 0 */
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    1dee:	82 e0       	ldi	r24, 0x02	; 2
    1df0:	66 e0       	ldi	r22, 0x06	; 6
    1df2:	40 e0       	ldi	r20, 0x00	; 0
    1df4:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
	/* Send Cmnd byte to the Data Pins of LCD */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8Cmnd);
    1df8:	83 e0       	ldi	r24, 0x03	; 3
    1dfa:	69 a9       	ldd	r22, Y+49	; 0x31
    1dfc:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <DIO_u8SetPortValue>
	/* Pulse of Enable E = 1 , E = 0 */
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    1e00:	82 e0       	ldi	r24, 0x02	; 2
    1e02:	67 e0       	ldi	r22, 0x07	; 7
    1e04:	41 e0       	ldi	r20, 0x01	; 1
    1e06:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
    1e0a:	80 e0       	ldi	r24, 0x00	; 0
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	a0 e8       	ldi	r26, 0x80	; 128
    1e10:	bf e3       	ldi	r27, 0x3F	; 63
    1e12:	8d a7       	std	Y+45, r24	; 0x2d
    1e14:	9e a7       	std	Y+46, r25	; 0x2e
    1e16:	af a7       	std	Y+47, r26	; 0x2f
    1e18:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1e1a:	6d a5       	ldd	r22, Y+45	; 0x2d
    1e1c:	7e a5       	ldd	r23, Y+46	; 0x2e
    1e1e:	8f a5       	ldd	r24, Y+47	; 0x2f
    1e20:	98 a9       	ldd	r25, Y+48	; 0x30
    1e22:	2b ea       	ldi	r18, 0xAB	; 171
    1e24:	3a ea       	ldi	r19, 0xAA	; 170
    1e26:	4a e2       	ldi	r20, 0x2A	; 42
    1e28:	50 e4       	ldi	r21, 0x40	; 64
    1e2a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e2e:	dc 01       	movw	r26, r24
    1e30:	cb 01       	movw	r24, r22
    1e32:	89 a7       	std	Y+41, r24	; 0x29
    1e34:	9a a7       	std	Y+42, r25	; 0x2a
    1e36:	ab a7       	std	Y+43, r26	; 0x2b
    1e38:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1e3a:	69 a5       	ldd	r22, Y+41	; 0x29
    1e3c:	7a a5       	ldd	r23, Y+42	; 0x2a
    1e3e:	8b a5       	ldd	r24, Y+43	; 0x2b
    1e40:	9c a5       	ldd	r25, Y+44	; 0x2c
    1e42:	20 e0       	ldi	r18, 0x00	; 0
    1e44:	30 e0       	ldi	r19, 0x00	; 0
    1e46:	40 e8       	ldi	r20, 0x80	; 128
    1e48:	5f e3       	ldi	r21, 0x3F	; 63
    1e4a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1e4e:	88 23       	and	r24, r24
    1e50:	1c f4       	brge	.+6      	; 0x1e58 <LCD_voidSendCmnd+0x8a>
		__ticks = 1;
    1e52:	81 e0       	ldi	r24, 0x01	; 1
    1e54:	88 a7       	std	Y+40, r24	; 0x28
    1e56:	91 c0       	rjmp	.+290    	; 0x1f7a <LCD_voidSendCmnd+0x1ac>
	else if (__tmp > 255)
    1e58:	69 a5       	ldd	r22, Y+41	; 0x29
    1e5a:	7a a5       	ldd	r23, Y+42	; 0x2a
    1e5c:	8b a5       	ldd	r24, Y+43	; 0x2b
    1e5e:	9c a5       	ldd	r25, Y+44	; 0x2c
    1e60:	20 e0       	ldi	r18, 0x00	; 0
    1e62:	30 e0       	ldi	r19, 0x00	; 0
    1e64:	4f e7       	ldi	r20, 0x7F	; 127
    1e66:	53 e4       	ldi	r21, 0x43	; 67
    1e68:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1e6c:	18 16       	cp	r1, r24
    1e6e:	0c f0       	brlt	.+2      	; 0x1e72 <LCD_voidSendCmnd+0xa4>
    1e70:	7b c0       	rjmp	.+246    	; 0x1f68 <LCD_voidSendCmnd+0x19a>
	{
		_delay_ms(__us / 1000.0);
    1e72:	6d a5       	ldd	r22, Y+45	; 0x2d
    1e74:	7e a5       	ldd	r23, Y+46	; 0x2e
    1e76:	8f a5       	ldd	r24, Y+47	; 0x2f
    1e78:	98 a9       	ldd	r25, Y+48	; 0x30
    1e7a:	20 e0       	ldi	r18, 0x00	; 0
    1e7c:	30 e0       	ldi	r19, 0x00	; 0
    1e7e:	4a e7       	ldi	r20, 0x7A	; 122
    1e80:	54 e4       	ldi	r21, 0x44	; 68
    1e82:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1e86:	dc 01       	movw	r26, r24
    1e88:	cb 01       	movw	r24, r22
    1e8a:	8c a3       	std	Y+36, r24	; 0x24
    1e8c:	9d a3       	std	Y+37, r25	; 0x25
    1e8e:	ae a3       	std	Y+38, r26	; 0x26
    1e90:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1e92:	6c a1       	ldd	r22, Y+36	; 0x24
    1e94:	7d a1       	ldd	r23, Y+37	; 0x25
    1e96:	8e a1       	ldd	r24, Y+38	; 0x26
    1e98:	9f a1       	ldd	r25, Y+39	; 0x27
    1e9a:	20 e0       	ldi	r18, 0x00	; 0
    1e9c:	30 e0       	ldi	r19, 0x00	; 0
    1e9e:	4a ef       	ldi	r20, 0xFA	; 250
    1ea0:	54 e4       	ldi	r21, 0x44	; 68
    1ea2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ea6:	dc 01       	movw	r26, r24
    1ea8:	cb 01       	movw	r24, r22
    1eaa:	88 a3       	std	Y+32, r24	; 0x20
    1eac:	99 a3       	std	Y+33, r25	; 0x21
    1eae:	aa a3       	std	Y+34, r26	; 0x22
    1eb0:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1eb2:	68 a1       	ldd	r22, Y+32	; 0x20
    1eb4:	79 a1       	ldd	r23, Y+33	; 0x21
    1eb6:	8a a1       	ldd	r24, Y+34	; 0x22
    1eb8:	9b a1       	ldd	r25, Y+35	; 0x23
    1eba:	20 e0       	ldi	r18, 0x00	; 0
    1ebc:	30 e0       	ldi	r19, 0x00	; 0
    1ebe:	40 e8       	ldi	r20, 0x80	; 128
    1ec0:	5f e3       	ldi	r21, 0x3F	; 63
    1ec2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1ec6:	88 23       	and	r24, r24
    1ec8:	2c f4       	brge	.+10     	; 0x1ed4 <LCD_voidSendCmnd+0x106>
		__ticks = 1;
    1eca:	81 e0       	ldi	r24, 0x01	; 1
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	9f 8f       	std	Y+31, r25	; 0x1f
    1ed0:	8e 8f       	std	Y+30, r24	; 0x1e
    1ed2:	3f c0       	rjmp	.+126    	; 0x1f52 <LCD_voidSendCmnd+0x184>
	else if (__tmp > 65535)
    1ed4:	68 a1       	ldd	r22, Y+32	; 0x20
    1ed6:	79 a1       	ldd	r23, Y+33	; 0x21
    1ed8:	8a a1       	ldd	r24, Y+34	; 0x22
    1eda:	9b a1       	ldd	r25, Y+35	; 0x23
    1edc:	20 e0       	ldi	r18, 0x00	; 0
    1ede:	3f ef       	ldi	r19, 0xFF	; 255
    1ee0:	4f e7       	ldi	r20, 0x7F	; 127
    1ee2:	57 e4       	ldi	r21, 0x47	; 71
    1ee4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1ee8:	18 16       	cp	r1, r24
    1eea:	4c f5       	brge	.+82     	; 0x1f3e <LCD_voidSendCmnd+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1eec:	6c a1       	ldd	r22, Y+36	; 0x24
    1eee:	7d a1       	ldd	r23, Y+37	; 0x25
    1ef0:	8e a1       	ldd	r24, Y+38	; 0x26
    1ef2:	9f a1       	ldd	r25, Y+39	; 0x27
    1ef4:	20 e0       	ldi	r18, 0x00	; 0
    1ef6:	30 e0       	ldi	r19, 0x00	; 0
    1ef8:	40 e2       	ldi	r20, 0x20	; 32
    1efa:	51 e4       	ldi	r21, 0x41	; 65
    1efc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f00:	dc 01       	movw	r26, r24
    1f02:	cb 01       	movw	r24, r22
    1f04:	bc 01       	movw	r22, r24
    1f06:	cd 01       	movw	r24, r26
    1f08:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f0c:	dc 01       	movw	r26, r24
    1f0e:	cb 01       	movw	r24, r22
    1f10:	9f 8f       	std	Y+31, r25	; 0x1f
    1f12:	8e 8f       	std	Y+30, r24	; 0x1e
    1f14:	0f c0       	rjmp	.+30     	; 0x1f34 <LCD_voidSendCmnd+0x166>
    1f16:	88 ec       	ldi	r24, 0xC8	; 200
    1f18:	90 e0       	ldi	r25, 0x00	; 0
    1f1a:	9d 8f       	std	Y+29, r25	; 0x1d
    1f1c:	8c 8f       	std	Y+28, r24	; 0x1c
    1f1e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1f20:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1f22:	01 97       	sbiw	r24, 0x01	; 1
    1f24:	f1 f7       	brne	.-4      	; 0x1f22 <LCD_voidSendCmnd+0x154>
    1f26:	9d 8f       	std	Y+29, r25	; 0x1d
    1f28:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f2a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f2c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1f2e:	01 97       	sbiw	r24, 0x01	; 1
    1f30:	9f 8f       	std	Y+31, r25	; 0x1f
    1f32:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1f34:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f36:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1f38:	00 97       	sbiw	r24, 0x00	; 0
    1f3a:	69 f7       	brne	.-38     	; 0x1f16 <LCD_voidSendCmnd+0x148>
    1f3c:	24 c0       	rjmp	.+72     	; 0x1f86 <LCD_voidSendCmnd+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1f3e:	68 a1       	ldd	r22, Y+32	; 0x20
    1f40:	79 a1       	ldd	r23, Y+33	; 0x21
    1f42:	8a a1       	ldd	r24, Y+34	; 0x22
    1f44:	9b a1       	ldd	r25, Y+35	; 0x23
    1f46:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f4a:	dc 01       	movw	r26, r24
    1f4c:	cb 01       	movw	r24, r22
    1f4e:	9f 8f       	std	Y+31, r25	; 0x1f
    1f50:	8e 8f       	std	Y+30, r24	; 0x1e
    1f52:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f54:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1f56:	9b 8f       	std	Y+27, r25	; 0x1b
    1f58:	8a 8f       	std	Y+26, r24	; 0x1a
    1f5a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f5c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1f5e:	01 97       	sbiw	r24, 0x01	; 1
    1f60:	f1 f7       	brne	.-4      	; 0x1f5e <LCD_voidSendCmnd+0x190>
    1f62:	9b 8f       	std	Y+27, r25	; 0x1b
    1f64:	8a 8f       	std	Y+26, r24	; 0x1a
    1f66:	0f c0       	rjmp	.+30     	; 0x1f86 <LCD_voidSendCmnd+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1f68:	69 a5       	ldd	r22, Y+41	; 0x29
    1f6a:	7a a5       	ldd	r23, Y+42	; 0x2a
    1f6c:	8b a5       	ldd	r24, Y+43	; 0x2b
    1f6e:	9c a5       	ldd	r25, Y+44	; 0x2c
    1f70:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f74:	dc 01       	movw	r26, r24
    1f76:	cb 01       	movw	r24, r22
    1f78:	88 a7       	std	Y+40, r24	; 0x28
    1f7a:	88 a5       	ldd	r24, Y+40	; 0x28
    1f7c:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1f7e:	89 8d       	ldd	r24, Y+25	; 0x19
    1f80:	8a 95       	dec	r24
    1f82:	f1 f7       	brne	.-4      	; 0x1f80 <LCD_voidSendCmnd+0x1b2>
    1f84:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1);
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    1f86:	82 e0       	ldi	r24, 0x02	; 2
    1f88:	67 e0       	ldi	r22, 0x07	; 7
    1f8a:	40 e0       	ldi	r20, 0x00	; 0
    1f8c:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
    1f90:	80 e0       	ldi	r24, 0x00	; 0
    1f92:	90 e0       	ldi	r25, 0x00	; 0
    1f94:	a0 e8       	ldi	r26, 0x80	; 128
    1f96:	bf e3       	ldi	r27, 0x3F	; 63
    1f98:	8d 8b       	std	Y+21, r24	; 0x15
    1f9a:	9e 8b       	std	Y+22, r25	; 0x16
    1f9c:	af 8b       	std	Y+23, r26	; 0x17
    1f9e:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1fa0:	6d 89       	ldd	r22, Y+21	; 0x15
    1fa2:	7e 89       	ldd	r23, Y+22	; 0x16
    1fa4:	8f 89       	ldd	r24, Y+23	; 0x17
    1fa6:	98 8d       	ldd	r25, Y+24	; 0x18
    1fa8:	2b ea       	ldi	r18, 0xAB	; 171
    1faa:	3a ea       	ldi	r19, 0xAA	; 170
    1fac:	4a e2       	ldi	r20, 0x2A	; 42
    1fae:	50 e4       	ldi	r21, 0x40	; 64
    1fb0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fb4:	dc 01       	movw	r26, r24
    1fb6:	cb 01       	movw	r24, r22
    1fb8:	89 8b       	std	Y+17, r24	; 0x11
    1fba:	9a 8b       	std	Y+18, r25	; 0x12
    1fbc:	ab 8b       	std	Y+19, r26	; 0x13
    1fbe:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1fc0:	69 89       	ldd	r22, Y+17	; 0x11
    1fc2:	7a 89       	ldd	r23, Y+18	; 0x12
    1fc4:	8b 89       	ldd	r24, Y+19	; 0x13
    1fc6:	9c 89       	ldd	r25, Y+20	; 0x14
    1fc8:	20 e0       	ldi	r18, 0x00	; 0
    1fca:	30 e0       	ldi	r19, 0x00	; 0
    1fcc:	40 e8       	ldi	r20, 0x80	; 128
    1fce:	5f e3       	ldi	r21, 0x3F	; 63
    1fd0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1fd4:	88 23       	and	r24, r24
    1fd6:	1c f4       	brge	.+6      	; 0x1fde <LCD_voidSendCmnd+0x210>
		__ticks = 1;
    1fd8:	81 e0       	ldi	r24, 0x01	; 1
    1fda:	88 8b       	std	Y+16, r24	; 0x10
    1fdc:	91 c0       	rjmp	.+290    	; 0x2100 <LCD_voidSendCmnd+0x332>
	else if (__tmp > 255)
    1fde:	69 89       	ldd	r22, Y+17	; 0x11
    1fe0:	7a 89       	ldd	r23, Y+18	; 0x12
    1fe2:	8b 89       	ldd	r24, Y+19	; 0x13
    1fe4:	9c 89       	ldd	r25, Y+20	; 0x14
    1fe6:	20 e0       	ldi	r18, 0x00	; 0
    1fe8:	30 e0       	ldi	r19, 0x00	; 0
    1fea:	4f e7       	ldi	r20, 0x7F	; 127
    1fec:	53 e4       	ldi	r21, 0x43	; 67
    1fee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1ff2:	18 16       	cp	r1, r24
    1ff4:	0c f0       	brlt	.+2      	; 0x1ff8 <LCD_voidSendCmnd+0x22a>
    1ff6:	7b c0       	rjmp	.+246    	; 0x20ee <LCD_voidSendCmnd+0x320>
	{
		_delay_ms(__us / 1000.0);
    1ff8:	6d 89       	ldd	r22, Y+21	; 0x15
    1ffa:	7e 89       	ldd	r23, Y+22	; 0x16
    1ffc:	8f 89       	ldd	r24, Y+23	; 0x17
    1ffe:	98 8d       	ldd	r25, Y+24	; 0x18
    2000:	20 e0       	ldi	r18, 0x00	; 0
    2002:	30 e0       	ldi	r19, 0x00	; 0
    2004:	4a e7       	ldi	r20, 0x7A	; 122
    2006:	54 e4       	ldi	r21, 0x44	; 68
    2008:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    200c:	dc 01       	movw	r26, r24
    200e:	cb 01       	movw	r24, r22
    2010:	8c 87       	std	Y+12, r24	; 0x0c
    2012:	9d 87       	std	Y+13, r25	; 0x0d
    2014:	ae 87       	std	Y+14, r26	; 0x0e
    2016:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2018:	6c 85       	ldd	r22, Y+12	; 0x0c
    201a:	7d 85       	ldd	r23, Y+13	; 0x0d
    201c:	8e 85       	ldd	r24, Y+14	; 0x0e
    201e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2020:	20 e0       	ldi	r18, 0x00	; 0
    2022:	30 e0       	ldi	r19, 0x00	; 0
    2024:	4a ef       	ldi	r20, 0xFA	; 250
    2026:	54 e4       	ldi	r21, 0x44	; 68
    2028:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    202c:	dc 01       	movw	r26, r24
    202e:	cb 01       	movw	r24, r22
    2030:	88 87       	std	Y+8, r24	; 0x08
    2032:	99 87       	std	Y+9, r25	; 0x09
    2034:	aa 87       	std	Y+10, r26	; 0x0a
    2036:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    2038:	68 85       	ldd	r22, Y+8	; 0x08
    203a:	79 85       	ldd	r23, Y+9	; 0x09
    203c:	8a 85       	ldd	r24, Y+10	; 0x0a
    203e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2040:	20 e0       	ldi	r18, 0x00	; 0
    2042:	30 e0       	ldi	r19, 0x00	; 0
    2044:	40 e8       	ldi	r20, 0x80	; 128
    2046:	5f e3       	ldi	r21, 0x3F	; 63
    2048:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    204c:	88 23       	and	r24, r24
    204e:	2c f4       	brge	.+10     	; 0x205a <LCD_voidSendCmnd+0x28c>
		__ticks = 1;
    2050:	81 e0       	ldi	r24, 0x01	; 1
    2052:	90 e0       	ldi	r25, 0x00	; 0
    2054:	9f 83       	std	Y+7, r25	; 0x07
    2056:	8e 83       	std	Y+6, r24	; 0x06
    2058:	3f c0       	rjmp	.+126    	; 0x20d8 <LCD_voidSendCmnd+0x30a>
	else if (__tmp > 65535)
    205a:	68 85       	ldd	r22, Y+8	; 0x08
    205c:	79 85       	ldd	r23, Y+9	; 0x09
    205e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2060:	9b 85       	ldd	r25, Y+11	; 0x0b
    2062:	20 e0       	ldi	r18, 0x00	; 0
    2064:	3f ef       	ldi	r19, 0xFF	; 255
    2066:	4f e7       	ldi	r20, 0x7F	; 127
    2068:	57 e4       	ldi	r21, 0x47	; 71
    206a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    206e:	18 16       	cp	r1, r24
    2070:	4c f5       	brge	.+82     	; 0x20c4 <LCD_voidSendCmnd+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2072:	6c 85       	ldd	r22, Y+12	; 0x0c
    2074:	7d 85       	ldd	r23, Y+13	; 0x0d
    2076:	8e 85       	ldd	r24, Y+14	; 0x0e
    2078:	9f 85       	ldd	r25, Y+15	; 0x0f
    207a:	20 e0       	ldi	r18, 0x00	; 0
    207c:	30 e0       	ldi	r19, 0x00	; 0
    207e:	40 e2       	ldi	r20, 0x20	; 32
    2080:	51 e4       	ldi	r21, 0x41	; 65
    2082:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2086:	dc 01       	movw	r26, r24
    2088:	cb 01       	movw	r24, r22
    208a:	bc 01       	movw	r22, r24
    208c:	cd 01       	movw	r24, r26
    208e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2092:	dc 01       	movw	r26, r24
    2094:	cb 01       	movw	r24, r22
    2096:	9f 83       	std	Y+7, r25	; 0x07
    2098:	8e 83       	std	Y+6, r24	; 0x06
    209a:	0f c0       	rjmp	.+30     	; 0x20ba <LCD_voidSendCmnd+0x2ec>
    209c:	88 ec       	ldi	r24, 0xC8	; 200
    209e:	90 e0       	ldi	r25, 0x00	; 0
    20a0:	9d 83       	std	Y+5, r25	; 0x05
    20a2:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    20a4:	8c 81       	ldd	r24, Y+4	; 0x04
    20a6:	9d 81       	ldd	r25, Y+5	; 0x05
    20a8:	01 97       	sbiw	r24, 0x01	; 1
    20aa:	f1 f7       	brne	.-4      	; 0x20a8 <LCD_voidSendCmnd+0x2da>
    20ac:	9d 83       	std	Y+5, r25	; 0x05
    20ae:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    20b0:	8e 81       	ldd	r24, Y+6	; 0x06
    20b2:	9f 81       	ldd	r25, Y+7	; 0x07
    20b4:	01 97       	sbiw	r24, 0x01	; 1
    20b6:	9f 83       	std	Y+7, r25	; 0x07
    20b8:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    20ba:	8e 81       	ldd	r24, Y+6	; 0x06
    20bc:	9f 81       	ldd	r25, Y+7	; 0x07
    20be:	00 97       	sbiw	r24, 0x00	; 0
    20c0:	69 f7       	brne	.-38     	; 0x209c <LCD_voidSendCmnd+0x2ce>
    20c2:	24 c0       	rjmp	.+72     	; 0x210c <LCD_voidSendCmnd+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    20c4:	68 85       	ldd	r22, Y+8	; 0x08
    20c6:	79 85       	ldd	r23, Y+9	; 0x09
    20c8:	8a 85       	ldd	r24, Y+10	; 0x0a
    20ca:	9b 85       	ldd	r25, Y+11	; 0x0b
    20cc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20d0:	dc 01       	movw	r26, r24
    20d2:	cb 01       	movw	r24, r22
    20d4:	9f 83       	std	Y+7, r25	; 0x07
    20d6:	8e 83       	std	Y+6, r24	; 0x06
    20d8:	8e 81       	ldd	r24, Y+6	; 0x06
    20da:	9f 81       	ldd	r25, Y+7	; 0x07
    20dc:	9b 83       	std	Y+3, r25	; 0x03
    20de:	8a 83       	std	Y+2, r24	; 0x02
    20e0:	8a 81       	ldd	r24, Y+2	; 0x02
    20e2:	9b 81       	ldd	r25, Y+3	; 0x03
    20e4:	01 97       	sbiw	r24, 0x01	; 1
    20e6:	f1 f7       	brne	.-4      	; 0x20e4 <LCD_voidSendCmnd+0x316>
    20e8:	9b 83       	std	Y+3, r25	; 0x03
    20ea:	8a 83       	std	Y+2, r24	; 0x02
    20ec:	0f c0       	rjmp	.+30     	; 0x210c <LCD_voidSendCmnd+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    20ee:	69 89       	ldd	r22, Y+17	; 0x11
    20f0:	7a 89       	ldd	r23, Y+18	; 0x12
    20f2:	8b 89       	ldd	r24, Y+19	; 0x13
    20f4:	9c 89       	ldd	r25, Y+20	; 0x14
    20f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20fa:	dc 01       	movw	r26, r24
    20fc:	cb 01       	movw	r24, r22
    20fe:	88 8b       	std	Y+16, r24	; 0x10
    2100:	88 89       	ldd	r24, Y+16	; 0x10
    2102:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2104:	89 81       	ldd	r24, Y+1	; 0x01
    2106:	8a 95       	dec	r24
    2108:	f1 f7       	brne	.-4      	; 0x2106 <LCD_voidSendCmnd+0x338>
    210a:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
}
    210c:	e1 96       	adiw	r28, 0x31	; 49
    210e:	0f b6       	in	r0, 0x3f	; 63
    2110:	f8 94       	cli
    2112:	de bf       	out	0x3e, r29	; 62
    2114:	0f be       	out	0x3f, r0	; 63
    2116:	cd bf       	out	0x3d, r28	; 61
    2118:	cf 91       	pop	r28
    211a:	df 91       	pop	r29
    211c:	08 95       	ret

0000211e <LCD_voidSendChar>:
void LCD_voidSendChar (u8 Copy_u8Char)
{
    211e:	df 93       	push	r29
    2120:	cf 93       	push	r28
    2122:	cd b7       	in	r28, 0x3d	; 61
    2124:	de b7       	in	r29, 0x3e	; 62
    2126:	e1 97       	sbiw	r28, 0x31	; 49
    2128:	0f b6       	in	r0, 0x3f	; 63
    212a:	f8 94       	cli
    212c:	de bf       	out	0x3e, r29	; 62
    212e:	0f be       	out	0x3f, r0	; 63
    2130:	cd bf       	out	0x3d, r28	; 61
    2132:	89 ab       	std	Y+49, r24	; 0x31
	/* Rs = 1 */
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_RS_PIN,DIO_u8_HIGH);
    2134:	82 e0       	ldi	r24, 0x02	; 2
    2136:	65 e0       	ldi	r22, 0x05	; 5
    2138:	41 e0       	ldi	r20, 0x01	; 1
    213a:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
	/* Rw = 0 */
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_RW_PIN,DIO_u8_LOW);
    213e:	82 e0       	ldi	r24, 0x02	; 2
    2140:	66 e0       	ldi	r22, 0x06	; 6
    2142:	40 e0       	ldi	r20, 0x00	; 0
    2144:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
	/* Send Char byte to the Data Pins of LCD */
	DIO_u8SetPortValue(LCD_u8_DATA_PORT,Copy_u8Char);
    2148:	83 e0       	ldi	r24, 0x03	; 3
    214a:	69 a9       	ldd	r22, Y+49	; 0x31
    214c:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <DIO_u8SetPortValue>
	/* Pulse of Enable E = 1 , E = 0 */
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_E_PIN,DIO_u8_HIGH);
    2150:	82 e0       	ldi	r24, 0x02	; 2
    2152:	67 e0       	ldi	r22, 0x07	; 7
    2154:	41 e0       	ldi	r20, 0x01	; 1
    2156:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
    215a:	80 e0       	ldi	r24, 0x00	; 0
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	a0 e8       	ldi	r26, 0x80	; 128
    2160:	bf e3       	ldi	r27, 0x3F	; 63
    2162:	8d a7       	std	Y+45, r24	; 0x2d
    2164:	9e a7       	std	Y+46, r25	; 0x2e
    2166:	af a7       	std	Y+47, r26	; 0x2f
    2168:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    216a:	6d a5       	ldd	r22, Y+45	; 0x2d
    216c:	7e a5       	ldd	r23, Y+46	; 0x2e
    216e:	8f a5       	ldd	r24, Y+47	; 0x2f
    2170:	98 a9       	ldd	r25, Y+48	; 0x30
    2172:	2b ea       	ldi	r18, 0xAB	; 171
    2174:	3a ea       	ldi	r19, 0xAA	; 170
    2176:	4a e2       	ldi	r20, 0x2A	; 42
    2178:	50 e4       	ldi	r21, 0x40	; 64
    217a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    217e:	dc 01       	movw	r26, r24
    2180:	cb 01       	movw	r24, r22
    2182:	89 a7       	std	Y+41, r24	; 0x29
    2184:	9a a7       	std	Y+42, r25	; 0x2a
    2186:	ab a7       	std	Y+43, r26	; 0x2b
    2188:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    218a:	69 a5       	ldd	r22, Y+41	; 0x29
    218c:	7a a5       	ldd	r23, Y+42	; 0x2a
    218e:	8b a5       	ldd	r24, Y+43	; 0x2b
    2190:	9c a5       	ldd	r25, Y+44	; 0x2c
    2192:	20 e0       	ldi	r18, 0x00	; 0
    2194:	30 e0       	ldi	r19, 0x00	; 0
    2196:	40 e8       	ldi	r20, 0x80	; 128
    2198:	5f e3       	ldi	r21, 0x3F	; 63
    219a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    219e:	88 23       	and	r24, r24
    21a0:	1c f4       	brge	.+6      	; 0x21a8 <LCD_voidSendChar+0x8a>
		__ticks = 1;
    21a2:	81 e0       	ldi	r24, 0x01	; 1
    21a4:	88 a7       	std	Y+40, r24	; 0x28
    21a6:	91 c0       	rjmp	.+290    	; 0x22ca <LCD_voidSendChar+0x1ac>
	else if (__tmp > 255)
    21a8:	69 a5       	ldd	r22, Y+41	; 0x29
    21aa:	7a a5       	ldd	r23, Y+42	; 0x2a
    21ac:	8b a5       	ldd	r24, Y+43	; 0x2b
    21ae:	9c a5       	ldd	r25, Y+44	; 0x2c
    21b0:	20 e0       	ldi	r18, 0x00	; 0
    21b2:	30 e0       	ldi	r19, 0x00	; 0
    21b4:	4f e7       	ldi	r20, 0x7F	; 127
    21b6:	53 e4       	ldi	r21, 0x43	; 67
    21b8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    21bc:	18 16       	cp	r1, r24
    21be:	0c f0       	brlt	.+2      	; 0x21c2 <LCD_voidSendChar+0xa4>
    21c0:	7b c0       	rjmp	.+246    	; 0x22b8 <LCD_voidSendChar+0x19a>
	{
		_delay_ms(__us / 1000.0);
    21c2:	6d a5       	ldd	r22, Y+45	; 0x2d
    21c4:	7e a5       	ldd	r23, Y+46	; 0x2e
    21c6:	8f a5       	ldd	r24, Y+47	; 0x2f
    21c8:	98 a9       	ldd	r25, Y+48	; 0x30
    21ca:	20 e0       	ldi	r18, 0x00	; 0
    21cc:	30 e0       	ldi	r19, 0x00	; 0
    21ce:	4a e7       	ldi	r20, 0x7A	; 122
    21d0:	54 e4       	ldi	r21, 0x44	; 68
    21d2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    21d6:	dc 01       	movw	r26, r24
    21d8:	cb 01       	movw	r24, r22
    21da:	8c a3       	std	Y+36, r24	; 0x24
    21dc:	9d a3       	std	Y+37, r25	; 0x25
    21de:	ae a3       	std	Y+38, r26	; 0x26
    21e0:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    21e2:	6c a1       	ldd	r22, Y+36	; 0x24
    21e4:	7d a1       	ldd	r23, Y+37	; 0x25
    21e6:	8e a1       	ldd	r24, Y+38	; 0x26
    21e8:	9f a1       	ldd	r25, Y+39	; 0x27
    21ea:	20 e0       	ldi	r18, 0x00	; 0
    21ec:	30 e0       	ldi	r19, 0x00	; 0
    21ee:	4a ef       	ldi	r20, 0xFA	; 250
    21f0:	54 e4       	ldi	r21, 0x44	; 68
    21f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21f6:	dc 01       	movw	r26, r24
    21f8:	cb 01       	movw	r24, r22
    21fa:	88 a3       	std	Y+32, r24	; 0x20
    21fc:	99 a3       	std	Y+33, r25	; 0x21
    21fe:	aa a3       	std	Y+34, r26	; 0x22
    2200:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    2202:	68 a1       	ldd	r22, Y+32	; 0x20
    2204:	79 a1       	ldd	r23, Y+33	; 0x21
    2206:	8a a1       	ldd	r24, Y+34	; 0x22
    2208:	9b a1       	ldd	r25, Y+35	; 0x23
    220a:	20 e0       	ldi	r18, 0x00	; 0
    220c:	30 e0       	ldi	r19, 0x00	; 0
    220e:	40 e8       	ldi	r20, 0x80	; 128
    2210:	5f e3       	ldi	r21, 0x3F	; 63
    2212:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2216:	88 23       	and	r24, r24
    2218:	2c f4       	brge	.+10     	; 0x2224 <LCD_voidSendChar+0x106>
		__ticks = 1;
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	9f 8f       	std	Y+31, r25	; 0x1f
    2220:	8e 8f       	std	Y+30, r24	; 0x1e
    2222:	3f c0       	rjmp	.+126    	; 0x22a2 <LCD_voidSendChar+0x184>
	else if (__tmp > 65535)
    2224:	68 a1       	ldd	r22, Y+32	; 0x20
    2226:	79 a1       	ldd	r23, Y+33	; 0x21
    2228:	8a a1       	ldd	r24, Y+34	; 0x22
    222a:	9b a1       	ldd	r25, Y+35	; 0x23
    222c:	20 e0       	ldi	r18, 0x00	; 0
    222e:	3f ef       	ldi	r19, 0xFF	; 255
    2230:	4f e7       	ldi	r20, 0x7F	; 127
    2232:	57 e4       	ldi	r21, 0x47	; 71
    2234:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2238:	18 16       	cp	r1, r24
    223a:	4c f5       	brge	.+82     	; 0x228e <LCD_voidSendChar+0x170>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    223c:	6c a1       	ldd	r22, Y+36	; 0x24
    223e:	7d a1       	ldd	r23, Y+37	; 0x25
    2240:	8e a1       	ldd	r24, Y+38	; 0x26
    2242:	9f a1       	ldd	r25, Y+39	; 0x27
    2244:	20 e0       	ldi	r18, 0x00	; 0
    2246:	30 e0       	ldi	r19, 0x00	; 0
    2248:	40 e2       	ldi	r20, 0x20	; 32
    224a:	51 e4       	ldi	r21, 0x41	; 65
    224c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2250:	dc 01       	movw	r26, r24
    2252:	cb 01       	movw	r24, r22
    2254:	bc 01       	movw	r22, r24
    2256:	cd 01       	movw	r24, r26
    2258:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    225c:	dc 01       	movw	r26, r24
    225e:	cb 01       	movw	r24, r22
    2260:	9f 8f       	std	Y+31, r25	; 0x1f
    2262:	8e 8f       	std	Y+30, r24	; 0x1e
    2264:	0f c0       	rjmp	.+30     	; 0x2284 <LCD_voidSendChar+0x166>
    2266:	88 ec       	ldi	r24, 0xC8	; 200
    2268:	90 e0       	ldi	r25, 0x00	; 0
    226a:	9d 8f       	std	Y+29, r25	; 0x1d
    226c:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    226e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2270:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2272:	01 97       	sbiw	r24, 0x01	; 1
    2274:	f1 f7       	brne	.-4      	; 0x2272 <LCD_voidSendChar+0x154>
    2276:	9d 8f       	std	Y+29, r25	; 0x1d
    2278:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    227a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    227c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    227e:	01 97       	sbiw	r24, 0x01	; 1
    2280:	9f 8f       	std	Y+31, r25	; 0x1f
    2282:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2284:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2286:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2288:	00 97       	sbiw	r24, 0x00	; 0
    228a:	69 f7       	brne	.-38     	; 0x2266 <LCD_voidSendChar+0x148>
    228c:	24 c0       	rjmp	.+72     	; 0x22d6 <LCD_voidSendChar+0x1b8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    228e:	68 a1       	ldd	r22, Y+32	; 0x20
    2290:	79 a1       	ldd	r23, Y+33	; 0x21
    2292:	8a a1       	ldd	r24, Y+34	; 0x22
    2294:	9b a1       	ldd	r25, Y+35	; 0x23
    2296:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    229a:	dc 01       	movw	r26, r24
    229c:	cb 01       	movw	r24, r22
    229e:	9f 8f       	std	Y+31, r25	; 0x1f
    22a0:	8e 8f       	std	Y+30, r24	; 0x1e
    22a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    22a4:	9f 8d       	ldd	r25, Y+31	; 0x1f
    22a6:	9b 8f       	std	Y+27, r25	; 0x1b
    22a8:	8a 8f       	std	Y+26, r24	; 0x1a
    22aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    22ac:	9b 8d       	ldd	r25, Y+27	; 0x1b
    22ae:	01 97       	sbiw	r24, 0x01	; 1
    22b0:	f1 f7       	brne	.-4      	; 0x22ae <LCD_voidSendChar+0x190>
    22b2:	9b 8f       	std	Y+27, r25	; 0x1b
    22b4:	8a 8f       	std	Y+26, r24	; 0x1a
    22b6:	0f c0       	rjmp	.+30     	; 0x22d6 <LCD_voidSendChar+0x1b8>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    22b8:	69 a5       	ldd	r22, Y+41	; 0x29
    22ba:	7a a5       	ldd	r23, Y+42	; 0x2a
    22bc:	8b a5       	ldd	r24, Y+43	; 0x2b
    22be:	9c a5       	ldd	r25, Y+44	; 0x2c
    22c0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    22c4:	dc 01       	movw	r26, r24
    22c6:	cb 01       	movw	r24, r22
    22c8:	88 a7       	std	Y+40, r24	; 0x28
    22ca:	88 a5       	ldd	r24, Y+40	; 0x28
    22cc:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    22ce:	89 8d       	ldd	r24, Y+25	; 0x19
    22d0:	8a 95       	dec	r24
    22d2:	f1 f7       	brne	.-4      	; 0x22d0 <LCD_voidSendChar+0x1b2>
    22d4:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1);
	DIO_u8SetPinValue(LCD_u8_CONTROL_PORT,LCD_u8_E_PIN,DIO_u8_LOW);
    22d6:	82 e0       	ldi	r24, 0x02	; 2
    22d8:	67 e0       	ldi	r22, 0x07	; 7
    22da:	40 e0       	ldi	r20, 0x00	; 0
    22dc:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
    22e0:	80 e0       	ldi	r24, 0x00	; 0
    22e2:	90 e0       	ldi	r25, 0x00	; 0
    22e4:	a0 e8       	ldi	r26, 0x80	; 128
    22e6:	bf e3       	ldi	r27, 0x3F	; 63
    22e8:	8d 8b       	std	Y+21, r24	; 0x15
    22ea:	9e 8b       	std	Y+22, r25	; 0x16
    22ec:	af 8b       	std	Y+23, r26	; 0x17
    22ee:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    22f0:	6d 89       	ldd	r22, Y+21	; 0x15
    22f2:	7e 89       	ldd	r23, Y+22	; 0x16
    22f4:	8f 89       	ldd	r24, Y+23	; 0x17
    22f6:	98 8d       	ldd	r25, Y+24	; 0x18
    22f8:	2b ea       	ldi	r18, 0xAB	; 171
    22fa:	3a ea       	ldi	r19, 0xAA	; 170
    22fc:	4a e2       	ldi	r20, 0x2A	; 42
    22fe:	50 e4       	ldi	r21, 0x40	; 64
    2300:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2304:	dc 01       	movw	r26, r24
    2306:	cb 01       	movw	r24, r22
    2308:	89 8b       	std	Y+17, r24	; 0x11
    230a:	9a 8b       	std	Y+18, r25	; 0x12
    230c:	ab 8b       	std	Y+19, r26	; 0x13
    230e:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    2310:	69 89       	ldd	r22, Y+17	; 0x11
    2312:	7a 89       	ldd	r23, Y+18	; 0x12
    2314:	8b 89       	ldd	r24, Y+19	; 0x13
    2316:	9c 89       	ldd	r25, Y+20	; 0x14
    2318:	20 e0       	ldi	r18, 0x00	; 0
    231a:	30 e0       	ldi	r19, 0x00	; 0
    231c:	40 e8       	ldi	r20, 0x80	; 128
    231e:	5f e3       	ldi	r21, 0x3F	; 63
    2320:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2324:	88 23       	and	r24, r24
    2326:	1c f4       	brge	.+6      	; 0x232e <LCD_voidSendChar+0x210>
		__ticks = 1;
    2328:	81 e0       	ldi	r24, 0x01	; 1
    232a:	88 8b       	std	Y+16, r24	; 0x10
    232c:	91 c0       	rjmp	.+290    	; 0x2450 <LCD_voidSendChar+0x332>
	else if (__tmp > 255)
    232e:	69 89       	ldd	r22, Y+17	; 0x11
    2330:	7a 89       	ldd	r23, Y+18	; 0x12
    2332:	8b 89       	ldd	r24, Y+19	; 0x13
    2334:	9c 89       	ldd	r25, Y+20	; 0x14
    2336:	20 e0       	ldi	r18, 0x00	; 0
    2338:	30 e0       	ldi	r19, 0x00	; 0
    233a:	4f e7       	ldi	r20, 0x7F	; 127
    233c:	53 e4       	ldi	r21, 0x43	; 67
    233e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2342:	18 16       	cp	r1, r24
    2344:	0c f0       	brlt	.+2      	; 0x2348 <LCD_voidSendChar+0x22a>
    2346:	7b c0       	rjmp	.+246    	; 0x243e <LCD_voidSendChar+0x320>
	{
		_delay_ms(__us / 1000.0);
    2348:	6d 89       	ldd	r22, Y+21	; 0x15
    234a:	7e 89       	ldd	r23, Y+22	; 0x16
    234c:	8f 89       	ldd	r24, Y+23	; 0x17
    234e:	98 8d       	ldd	r25, Y+24	; 0x18
    2350:	20 e0       	ldi	r18, 0x00	; 0
    2352:	30 e0       	ldi	r19, 0x00	; 0
    2354:	4a e7       	ldi	r20, 0x7A	; 122
    2356:	54 e4       	ldi	r21, 0x44	; 68
    2358:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    235c:	dc 01       	movw	r26, r24
    235e:	cb 01       	movw	r24, r22
    2360:	8c 87       	std	Y+12, r24	; 0x0c
    2362:	9d 87       	std	Y+13, r25	; 0x0d
    2364:	ae 87       	std	Y+14, r26	; 0x0e
    2366:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2368:	6c 85       	ldd	r22, Y+12	; 0x0c
    236a:	7d 85       	ldd	r23, Y+13	; 0x0d
    236c:	8e 85       	ldd	r24, Y+14	; 0x0e
    236e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2370:	20 e0       	ldi	r18, 0x00	; 0
    2372:	30 e0       	ldi	r19, 0x00	; 0
    2374:	4a ef       	ldi	r20, 0xFA	; 250
    2376:	54 e4       	ldi	r21, 0x44	; 68
    2378:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    237c:	dc 01       	movw	r26, r24
    237e:	cb 01       	movw	r24, r22
    2380:	88 87       	std	Y+8, r24	; 0x08
    2382:	99 87       	std	Y+9, r25	; 0x09
    2384:	aa 87       	std	Y+10, r26	; 0x0a
    2386:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    2388:	68 85       	ldd	r22, Y+8	; 0x08
    238a:	79 85       	ldd	r23, Y+9	; 0x09
    238c:	8a 85       	ldd	r24, Y+10	; 0x0a
    238e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2390:	20 e0       	ldi	r18, 0x00	; 0
    2392:	30 e0       	ldi	r19, 0x00	; 0
    2394:	40 e8       	ldi	r20, 0x80	; 128
    2396:	5f e3       	ldi	r21, 0x3F	; 63
    2398:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    239c:	88 23       	and	r24, r24
    239e:	2c f4       	brge	.+10     	; 0x23aa <LCD_voidSendChar+0x28c>
		__ticks = 1;
    23a0:	81 e0       	ldi	r24, 0x01	; 1
    23a2:	90 e0       	ldi	r25, 0x00	; 0
    23a4:	9f 83       	std	Y+7, r25	; 0x07
    23a6:	8e 83       	std	Y+6, r24	; 0x06
    23a8:	3f c0       	rjmp	.+126    	; 0x2428 <LCD_voidSendChar+0x30a>
	else if (__tmp > 65535)
    23aa:	68 85       	ldd	r22, Y+8	; 0x08
    23ac:	79 85       	ldd	r23, Y+9	; 0x09
    23ae:	8a 85       	ldd	r24, Y+10	; 0x0a
    23b0:	9b 85       	ldd	r25, Y+11	; 0x0b
    23b2:	20 e0       	ldi	r18, 0x00	; 0
    23b4:	3f ef       	ldi	r19, 0xFF	; 255
    23b6:	4f e7       	ldi	r20, 0x7F	; 127
    23b8:	57 e4       	ldi	r21, 0x47	; 71
    23ba:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    23be:	18 16       	cp	r1, r24
    23c0:	4c f5       	brge	.+82     	; 0x2414 <LCD_voidSendChar+0x2f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    23c2:	6c 85       	ldd	r22, Y+12	; 0x0c
    23c4:	7d 85       	ldd	r23, Y+13	; 0x0d
    23c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    23c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    23ca:	20 e0       	ldi	r18, 0x00	; 0
    23cc:	30 e0       	ldi	r19, 0x00	; 0
    23ce:	40 e2       	ldi	r20, 0x20	; 32
    23d0:	51 e4       	ldi	r21, 0x41	; 65
    23d2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23d6:	dc 01       	movw	r26, r24
    23d8:	cb 01       	movw	r24, r22
    23da:	bc 01       	movw	r22, r24
    23dc:	cd 01       	movw	r24, r26
    23de:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    23e2:	dc 01       	movw	r26, r24
    23e4:	cb 01       	movw	r24, r22
    23e6:	9f 83       	std	Y+7, r25	; 0x07
    23e8:	8e 83       	std	Y+6, r24	; 0x06
    23ea:	0f c0       	rjmp	.+30     	; 0x240a <LCD_voidSendChar+0x2ec>
    23ec:	88 ec       	ldi	r24, 0xC8	; 200
    23ee:	90 e0       	ldi	r25, 0x00	; 0
    23f0:	9d 83       	std	Y+5, r25	; 0x05
    23f2:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    23f4:	8c 81       	ldd	r24, Y+4	; 0x04
    23f6:	9d 81       	ldd	r25, Y+5	; 0x05
    23f8:	01 97       	sbiw	r24, 0x01	; 1
    23fa:	f1 f7       	brne	.-4      	; 0x23f8 <LCD_voidSendChar+0x2da>
    23fc:	9d 83       	std	Y+5, r25	; 0x05
    23fe:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2400:	8e 81       	ldd	r24, Y+6	; 0x06
    2402:	9f 81       	ldd	r25, Y+7	; 0x07
    2404:	01 97       	sbiw	r24, 0x01	; 1
    2406:	9f 83       	std	Y+7, r25	; 0x07
    2408:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    240a:	8e 81       	ldd	r24, Y+6	; 0x06
    240c:	9f 81       	ldd	r25, Y+7	; 0x07
    240e:	00 97       	sbiw	r24, 0x00	; 0
    2410:	69 f7       	brne	.-38     	; 0x23ec <LCD_voidSendChar+0x2ce>
    2412:	24 c0       	rjmp	.+72     	; 0x245c <LCD_voidSendChar+0x33e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2414:	68 85       	ldd	r22, Y+8	; 0x08
    2416:	79 85       	ldd	r23, Y+9	; 0x09
    2418:	8a 85       	ldd	r24, Y+10	; 0x0a
    241a:	9b 85       	ldd	r25, Y+11	; 0x0b
    241c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2420:	dc 01       	movw	r26, r24
    2422:	cb 01       	movw	r24, r22
    2424:	9f 83       	std	Y+7, r25	; 0x07
    2426:	8e 83       	std	Y+6, r24	; 0x06
    2428:	8e 81       	ldd	r24, Y+6	; 0x06
    242a:	9f 81       	ldd	r25, Y+7	; 0x07
    242c:	9b 83       	std	Y+3, r25	; 0x03
    242e:	8a 83       	std	Y+2, r24	; 0x02
    2430:	8a 81       	ldd	r24, Y+2	; 0x02
    2432:	9b 81       	ldd	r25, Y+3	; 0x03
    2434:	01 97       	sbiw	r24, 0x01	; 1
    2436:	f1 f7       	brne	.-4      	; 0x2434 <LCD_voidSendChar+0x316>
    2438:	9b 83       	std	Y+3, r25	; 0x03
    243a:	8a 83       	std	Y+2, r24	; 0x02
    243c:	0f c0       	rjmp	.+30     	; 0x245c <LCD_voidSendChar+0x33e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    243e:	69 89       	ldd	r22, Y+17	; 0x11
    2440:	7a 89       	ldd	r23, Y+18	; 0x12
    2442:	8b 89       	ldd	r24, Y+19	; 0x13
    2444:	9c 89       	ldd	r25, Y+20	; 0x14
    2446:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    244a:	dc 01       	movw	r26, r24
    244c:	cb 01       	movw	r24, r22
    244e:	88 8b       	std	Y+16, r24	; 0x10
    2450:	88 89       	ldd	r24, Y+16	; 0x10
    2452:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	8a 95       	dec	r24
    2458:	f1 f7       	brne	.-4      	; 0x2456 <LCD_voidSendChar+0x338>
    245a:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
}
    245c:	e1 96       	adiw	r28, 0x31	; 49
    245e:	0f b6       	in	r0, 0x3f	; 63
    2460:	f8 94       	cli
    2462:	de bf       	out	0x3e, r29	; 62
    2464:	0f be       	out	0x3f, r0	; 63
    2466:	cd bf       	out	0x3d, r28	; 61
    2468:	cf 91       	pop	r28
    246a:	df 91       	pop	r29
    246c:	08 95       	ret

0000246e <LCD_voidWriteString>:
void LCD_voidWriteString (u8 * Copy_pu8String)
{
    246e:	df 93       	push	r29
    2470:	cf 93       	push	r28
    2472:	00 d0       	rcall	.+0      	; 0x2474 <LCD_voidWriteString+0x6>
    2474:	00 d0       	rcall	.+0      	; 0x2476 <LCD_voidWriteString+0x8>
    2476:	cd b7       	in	r28, 0x3d	; 61
    2478:	de b7       	in	r29, 0x3e	; 62
    247a:	9c 83       	std	Y+4, r25	; 0x04
    247c:	8b 83       	std	Y+3, r24	; 0x03
	if(Copy_pu8String != NULL )
    247e:	8b 81       	ldd	r24, Y+3	; 0x03
    2480:	9c 81       	ldd	r25, Y+4	; 0x04
    2482:	00 97       	sbiw	r24, 0x00	; 0
    2484:	21 f1       	breq	.+72     	; 0x24ce <LCD_voidWriteString+0x60>
	{
	    u8 x = 0;
    2486:	1a 82       	std	Y+2, r1	; 0x02
	    u8 i = 0;
    2488:	19 82       	std	Y+1, r1	; 0x01
    248a:	16 c0       	rjmp	.+44     	; 0x24b8 <LCD_voidWriteString+0x4a>
		while(Copy_pu8String[x] != '\0')
		{
		 x++ ;
    248c:	8a 81       	ldd	r24, Y+2	; 0x02
    248e:	8f 5f       	subi	r24, 0xFF	; 255
    2490:	8a 83       	std	Y+2, r24	; 0x02
    2492:	0e c0       	rjmp	.+28     	; 0x24b0 <LCD_voidWriteString+0x42>
		 for(  ; i < x; i++)
		 {
		  /* Write Character on LCD */
		  LCD_voidSendChar (Copy_pu8String[i]);
    2494:	89 81       	ldd	r24, Y+1	; 0x01
    2496:	28 2f       	mov	r18, r24
    2498:	30 e0       	ldi	r19, 0x00	; 0
    249a:	8b 81       	ldd	r24, Y+3	; 0x03
    249c:	9c 81       	ldd	r25, Y+4	; 0x04
    249e:	fc 01       	movw	r30, r24
    24a0:	e2 0f       	add	r30, r18
    24a2:	f3 1f       	adc	r31, r19
    24a4:	80 81       	ld	r24, Z
    24a6:	0e 94 8f 10 	call	0x211e	; 0x211e <LCD_voidSendChar>
	    u8 x = 0;
	    u8 i = 0;
		while(Copy_pu8String[x] != '\0')
		{
		 x++ ;
		 for(  ; i < x; i++)
    24aa:	89 81       	ldd	r24, Y+1	; 0x01
    24ac:	8f 5f       	subi	r24, 0xFF	; 255
    24ae:	89 83       	std	Y+1, r24	; 0x01
    24b0:	99 81       	ldd	r25, Y+1	; 0x01
    24b2:	8a 81       	ldd	r24, Y+2	; 0x02
    24b4:	98 17       	cp	r25, r24
    24b6:	70 f3       	brcs	.-36     	; 0x2494 <LCD_voidWriteString+0x26>
{
	if(Copy_pu8String != NULL )
	{
	    u8 x = 0;
	    u8 i = 0;
		while(Copy_pu8String[x] != '\0')
    24b8:	8a 81       	ldd	r24, Y+2	; 0x02
    24ba:	28 2f       	mov	r18, r24
    24bc:	30 e0       	ldi	r19, 0x00	; 0
    24be:	8b 81       	ldd	r24, Y+3	; 0x03
    24c0:	9c 81       	ldd	r25, Y+4	; 0x04
    24c2:	fc 01       	movw	r30, r24
    24c4:	e2 0f       	add	r30, r18
    24c6:	f3 1f       	adc	r31, r19
    24c8:	80 81       	ld	r24, Z
    24ca:	88 23       	and	r24, r24
    24cc:	f9 f6       	brne	.-66     	; 0x248c <LCD_voidWriteString+0x1e>
		 }
		 
		}
	}
	
}
    24ce:	0f 90       	pop	r0
    24d0:	0f 90       	pop	r0
    24d2:	0f 90       	pop	r0
    24d4:	0f 90       	pop	r0
    24d6:	cf 91       	pop	r28
    24d8:	df 91       	pop	r29
    24da:	08 95       	ret

000024dc <LCD_u8_GoTo_XY>:
u8 LCD_u8_GoTo_XY     (u8 Copy_u8X,u8 Copy_u8Y)
{
    24dc:	df 93       	push	r29
    24de:	cf 93       	push	r28
    24e0:	00 d0       	rcall	.+0      	; 0x24e2 <LCD_u8_GoTo_XY+0x6>
    24e2:	00 d0       	rcall	.+0      	; 0x24e4 <LCD_u8_GoTo_XY+0x8>
    24e4:	00 d0       	rcall	.+0      	; 0x24e6 <LCD_u8_GoTo_XY+0xa>
    24e6:	cd b7       	in	r28, 0x3d	; 61
    24e8:	de b7       	in	r29, 0x3e	; 62
    24ea:	8a 83       	std	Y+2, r24	; 0x02
    24ec:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ReturnState = STD_TYPES_OK;
    24ee:	81 e0       	ldi	r24, 0x01	; 1
    24f0:	89 83       	std	Y+1, r24	; 0x01
	if((Copy_u8X <=1)&&(Copy_u8Y <= 39))
    24f2:	8a 81       	ldd	r24, Y+2	; 0x02
    24f4:	82 30       	cpi	r24, 0x02	; 2
    24f6:	e0 f4       	brcc	.+56     	; 0x2530 <LCD_u8_GoTo_XY+0x54>
    24f8:	8b 81       	ldd	r24, Y+3	; 0x03
    24fa:	88 32       	cpi	r24, 0x28	; 40
    24fc:	c8 f4       	brcc	.+50     	; 0x2530 <LCD_u8_GoTo_XY+0x54>
	{
		switch(Copy_u8X)
    24fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2500:	28 2f       	mov	r18, r24
    2502:	30 e0       	ldi	r19, 0x00	; 0
    2504:	3d 83       	std	Y+5, r19	; 0x05
    2506:	2c 83       	std	Y+4, r18	; 0x04
    2508:	8c 81       	ldd	r24, Y+4	; 0x04
    250a:	9d 81       	ldd	r25, Y+5	; 0x05
    250c:	00 97       	sbiw	r24, 0x00	; 0
    250e:	31 f0       	breq	.+12     	; 0x251c <LCD_u8_GoTo_XY+0x40>
    2510:	2c 81       	ldd	r18, Y+4	; 0x04
    2512:	3d 81       	ldd	r19, Y+5	; 0x05
    2514:	21 30       	cpi	r18, 0x01	; 1
    2516:	31 05       	cpc	r19, r1
    2518:	31 f0       	breq	.+12     	; 0x2526 <LCD_u8_GoTo_XY+0x4a>
    251a:	0b c0       	rjmp	.+22     	; 0x2532 <LCD_u8_GoTo_XY+0x56>
		{
		case LCD_u8_LINE0 : LCD_voidSendCmnd(0x80 + Copy_u8Y);break;
    251c:	8b 81       	ldd	r24, Y+3	; 0x03
    251e:	80 58       	subi	r24, 0x80	; 128
    2520:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    2524:	06 c0       	rjmp	.+12     	; 0x2532 <LCD_u8_GoTo_XY+0x56>

		case LCD_u8_LINE1 : LCD_voidSendCmnd(0xC0 + Copy_u8Y);break;
    2526:	8b 81       	ldd	r24, Y+3	; 0x03
    2528:	80 54       	subi	r24, 0x40	; 64
    252a:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    252e:	01 c0       	rjmp	.+2      	; 0x2532 <LCD_u8_GoTo_XY+0x56>
		}
	}
	else
	{
		Local_u8ReturnState = STD_TYPES_NOK;
    2530:	19 82       	std	Y+1, r1	; 0x01
	}


}
    2532:	26 96       	adiw	r28, 0x06	; 6
    2534:	0f b6       	in	r0, 0x3f	; 63
    2536:	f8 94       	cli
    2538:	de bf       	out	0x3e, r29	; 62
    253a:	0f be       	out	0x3f, r0	; 63
    253c:	cd bf       	out	0x3d, r28	; 61
    253e:	cf 91       	pop	r28
    2540:	df 91       	pop	r29
    2542:	08 95       	ret

00002544 <LCD_voidWriteNumber>:
void LCD_voidWriteNumber (u32  Copy_u32Num)
{
    2544:	df 93       	push	r29
    2546:	cf 93       	push	r28
    2548:	cd b7       	in	r28, 0x3d	; 61
    254a:	de b7       	in	r29, 0x3e	; 62
    254c:	66 97       	sbiw	r28, 0x16	; 22
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	de bf       	out	0x3e, r29	; 62
    2554:	0f be       	out	0x3f, r0	; 63
    2556:	cd bf       	out	0x3d, r28	; 61
    2558:	6b 8b       	std	Y+19, r22	; 0x13
    255a:	7c 8b       	std	Y+20, r23	; 0x14
    255c:	8d 8b       	std	Y+21, r24	; 0x15
    255e:	9e 8b       	std	Y+22, r25	; 0x16

	u8 Arr[10];
	u8 Local_Remainder = 1;
    2560:	81 e0       	ldi	r24, 0x01	; 1
    2562:	88 87       	std	Y+8, r24	; 0x08
	u32 Local_Number = Copy_u32Num;
    2564:	8b 89       	ldd	r24, Y+19	; 0x13
    2566:	9c 89       	ldd	r25, Y+20	; 0x14
    2568:	ad 89       	ldd	r26, Y+21	; 0x15
    256a:	be 89       	ldd	r27, Y+22	; 0x16
    256c:	8c 83       	std	Y+4, r24	; 0x04
    256e:	9d 83       	std	Y+5, r25	; 0x05
    2570:	ae 83       	std	Y+6, r26	; 0x06
    2572:	bf 83       	std	Y+7, r27	; 0x07
	u8 Local_Counter = 0;
    2574:	1b 82       	std	Y+3, r1	; 0x03
	u8 Local_Counter2 ;


	for(u8 initial = 10 ; initial >=1 ; initial--)
    2576:	8a e0       	ldi	r24, 0x0A	; 10
    2578:	89 83       	std	Y+1, r24	; 0x01
    257a:	42 c0       	rjmp	.+132    	; 0x2600 <LCD_voidWriteNumber+0xbc>
	{
		Local_Remainder = Local_Number % 10 ;
    257c:	8c 81       	ldd	r24, Y+4	; 0x04
    257e:	9d 81       	ldd	r25, Y+5	; 0x05
    2580:	ae 81       	ldd	r26, Y+6	; 0x06
    2582:	bf 81       	ldd	r27, Y+7	; 0x07
    2584:	2a e0       	ldi	r18, 0x0A	; 10
    2586:	30 e0       	ldi	r19, 0x00	; 0
    2588:	40 e0       	ldi	r20, 0x00	; 0
    258a:	50 e0       	ldi	r21, 0x00	; 0
    258c:	bc 01       	movw	r22, r24
    258e:	cd 01       	movw	r24, r26
    2590:	0e 94 89 27 	call	0x4f12	; 0x4f12 <__udivmodsi4>
    2594:	dc 01       	movw	r26, r24
    2596:	cb 01       	movw	r24, r22
    2598:	88 87       	std	Y+8, r24	; 0x08
		Local_Number    = Local_Number /10 ;
    259a:	8c 81       	ldd	r24, Y+4	; 0x04
    259c:	9d 81       	ldd	r25, Y+5	; 0x05
    259e:	ae 81       	ldd	r26, Y+6	; 0x06
    25a0:	bf 81       	ldd	r27, Y+7	; 0x07
    25a2:	2a e0       	ldi	r18, 0x0A	; 10
    25a4:	30 e0       	ldi	r19, 0x00	; 0
    25a6:	40 e0       	ldi	r20, 0x00	; 0
    25a8:	50 e0       	ldi	r21, 0x00	; 0
    25aa:	bc 01       	movw	r22, r24
    25ac:	cd 01       	movw	r24, r26
    25ae:	0e 94 89 27 	call	0x4f12	; 0x4f12 <__udivmodsi4>
    25b2:	da 01       	movw	r26, r20
    25b4:	c9 01       	movw	r24, r18
    25b6:	8c 83       	std	Y+4, r24	; 0x04
    25b8:	9d 83       	std	Y+5, r25	; 0x05
    25ba:	ae 83       	std	Y+6, r26	; 0x06
    25bc:	bf 83       	std	Y+7, r27	; 0x07

		if((Local_Remainder ==0) && (Local_Number<1) && (Local_Counter>0) )
    25be:	88 85       	ldd	r24, Y+8	; 0x08
    25c0:	88 23       	and	r24, r24
    25c2:	59 f4       	brne	.+22     	; 0x25da <LCD_voidWriteNumber+0x96>
    25c4:	8c 81       	ldd	r24, Y+4	; 0x04
    25c6:	9d 81       	ldd	r25, Y+5	; 0x05
    25c8:	ae 81       	ldd	r26, Y+6	; 0x06
    25ca:	bf 81       	ldd	r27, Y+7	; 0x07
    25cc:	00 97       	sbiw	r24, 0x00	; 0
    25ce:	a1 05       	cpc	r26, r1
    25d0:	b1 05       	cpc	r27, r1
    25d2:	19 f4       	brne	.+6      	; 0x25da <LCD_voidWriteNumber+0x96>
    25d4:	8b 81       	ldd	r24, Y+3	; 0x03
    25d6:	88 23       	and	r24, r24
    25d8:	b9 f4       	brne	.+46     	; 0x2608 <LCD_voidWriteNumber+0xc4>
		{
			break;
		}
		Local_Counter ++;
    25da:	8b 81       	ldd	r24, Y+3	; 0x03
    25dc:	8f 5f       	subi	r24, 0xFF	; 255
    25de:	8b 83       	std	Y+3, r24	; 0x03
		Arr[initial-1] = Local_Remainder ;
    25e0:	89 81       	ldd	r24, Y+1	; 0x01
    25e2:	88 2f       	mov	r24, r24
    25e4:	90 e0       	ldi	r25, 0x00	; 0
    25e6:	9c 01       	movw	r18, r24
    25e8:	21 50       	subi	r18, 0x01	; 1
    25ea:	30 40       	sbci	r19, 0x00	; 0
    25ec:	ce 01       	movw	r24, r28
    25ee:	09 96       	adiw	r24, 0x09	; 9
    25f0:	fc 01       	movw	r30, r24
    25f2:	e2 0f       	add	r30, r18
    25f4:	f3 1f       	adc	r31, r19
    25f6:	88 85       	ldd	r24, Y+8	; 0x08
    25f8:	80 83       	st	Z, r24
	u32 Local_Number = Copy_u32Num;
	u8 Local_Counter = 0;
	u8 Local_Counter2 ;


	for(u8 initial = 10 ; initial >=1 ; initial--)
    25fa:	89 81       	ldd	r24, Y+1	; 0x01
    25fc:	81 50       	subi	r24, 0x01	; 1
    25fe:	89 83       	std	Y+1, r24	; 0x01
    2600:	89 81       	ldd	r24, Y+1	; 0x01
    2602:	88 23       	and	r24, r24
    2604:	09 f0       	breq	.+2      	; 0x2608 <LCD_voidWriteNumber+0xc4>
    2606:	ba cf       	rjmp	.-140    	; 0x257c <LCD_voidWriteNumber+0x38>
		}
		Local_Counter ++;
		Arr[initial-1] = Local_Remainder ;
	}

	for(Local_Counter2 = 10 - Local_Counter; Local_Counter2 < 10 ; Local_Counter2 ++)
    2608:	8a e0       	ldi	r24, 0x0A	; 10
    260a:	9b 81       	ldd	r25, Y+3	; 0x03
    260c:	89 1b       	sub	r24, r25
    260e:	8a 83       	std	Y+2, r24	; 0x02
    2610:	0f c0       	rjmp	.+30     	; 0x2630 <LCD_voidWriteNumber+0xec>
	{
		LCD_voidSendChar(Arr[Local_Counter2]+48);
    2612:	8a 81       	ldd	r24, Y+2	; 0x02
    2614:	28 2f       	mov	r18, r24
    2616:	30 e0       	ldi	r19, 0x00	; 0
    2618:	ce 01       	movw	r24, r28
    261a:	09 96       	adiw	r24, 0x09	; 9
    261c:	fc 01       	movw	r30, r24
    261e:	e2 0f       	add	r30, r18
    2620:	f3 1f       	adc	r31, r19
    2622:	80 81       	ld	r24, Z
    2624:	80 5d       	subi	r24, 0xD0	; 208
    2626:	0e 94 8f 10 	call	0x211e	; 0x211e <LCD_voidSendChar>
		}
		Local_Counter ++;
		Arr[initial-1] = Local_Remainder ;
	}

	for(Local_Counter2 = 10 - Local_Counter; Local_Counter2 < 10 ; Local_Counter2 ++)
    262a:	8a 81       	ldd	r24, Y+2	; 0x02
    262c:	8f 5f       	subi	r24, 0xFF	; 255
    262e:	8a 83       	std	Y+2, r24	; 0x02
    2630:	8a 81       	ldd	r24, Y+2	; 0x02
    2632:	8a 30       	cpi	r24, 0x0A	; 10
    2634:	70 f3       	brcs	.-36     	; 0x2612 <LCD_voidWriteNumber+0xce>
		LCD_voidSendChar(Arr[Local_Counter2]+48);
	}



}
    2636:	66 96       	adiw	r28, 0x16	; 22
    2638:	0f b6       	in	r0, 0x3f	; 63
    263a:	f8 94       	cli
    263c:	de bf       	out	0x3e, r29	; 62
    263e:	0f be       	out	0x3f, r0	; 63
    2640:	cd bf       	out	0x3d, r28	; 61
    2642:	cf 91       	pop	r28
    2644:	df 91       	pop	r29
    2646:	08 95       	ret

00002648 <LCD_voidSendSpecialChar>:

void LCD_voidSendSpecialChar(u8 Copy_u8CharNo,u8 Copy_u8X,u8 Copy_u8Y,u8 * Copy_PSpecialChar)
{
    2648:	df 93       	push	r29
    264a:	cf 93       	push	r28
    264c:	cd b7       	in	r28, 0x3d	; 61
    264e:	de b7       	in	r29, 0x3e	; 62
    2650:	28 97       	sbiw	r28, 0x08	; 8
    2652:	0f b6       	in	r0, 0x3f	; 63
    2654:	f8 94       	cli
    2656:	de bf       	out	0x3e, r29	; 62
    2658:	0f be       	out	0x3f, r0	; 63
    265a:	cd bf       	out	0x3d, r28	; 61
    265c:	8a 83       	std	Y+2, r24	; 0x02
    265e:	6b 83       	std	Y+3, r22	; 0x03
    2660:	4c 83       	std	Y+4, r20	; 0x04
    2662:	3e 83       	std	Y+6, r19	; 0x06
    2664:	2d 83       	std	Y+5, r18	; 0x05

	switch(Copy_u8CharNo)
    2666:	8a 81       	ldd	r24, Y+2	; 0x02
    2668:	28 2f       	mov	r18, r24
    266a:	30 e0       	ldi	r19, 0x00	; 0
    266c:	38 87       	std	Y+8, r19	; 0x08
    266e:	2f 83       	std	Y+7, r18	; 0x07
    2670:	8f 81       	ldd	r24, Y+7	; 0x07
    2672:	98 85       	ldd	r25, Y+8	; 0x08
    2674:	83 30       	cpi	r24, 0x03	; 3
    2676:	91 05       	cpc	r25, r1
    2678:	a9 f1       	breq	.+106    	; 0x26e4 <LCD_voidSendSpecialChar+0x9c>
    267a:	2f 81       	ldd	r18, Y+7	; 0x07
    267c:	38 85       	ldd	r19, Y+8	; 0x08
    267e:	24 30       	cpi	r18, 0x04	; 4
    2680:	31 05       	cpc	r19, r1
    2682:	7c f4       	brge	.+30     	; 0x26a2 <LCD_voidSendSpecialChar+0x5a>
    2684:	8f 81       	ldd	r24, Y+7	; 0x07
    2686:	98 85       	ldd	r25, Y+8	; 0x08
    2688:	81 30       	cpi	r24, 0x01	; 1
    268a:	91 05       	cpc	r25, r1
    268c:	19 f1       	breq	.+70     	; 0x26d4 <LCD_voidSendSpecialChar+0x8c>
    268e:	2f 81       	ldd	r18, Y+7	; 0x07
    2690:	38 85       	ldd	r19, Y+8	; 0x08
    2692:	22 30       	cpi	r18, 0x02	; 2
    2694:	31 05       	cpc	r19, r1
    2696:	14 f5       	brge	.+68     	; 0x26dc <LCD_voidSendSpecialChar+0x94>
    2698:	8f 81       	ldd	r24, Y+7	; 0x07
    269a:	98 85       	ldd	r25, Y+8	; 0x08
    269c:	00 97       	sbiw	r24, 0x00	; 0
    269e:	b1 f0       	breq	.+44     	; 0x26cc <LCD_voidSendSpecialChar+0x84>
    26a0:	34 c0       	rjmp	.+104    	; 0x270a <LCD_voidSendSpecialChar+0xc2>
    26a2:	2f 81       	ldd	r18, Y+7	; 0x07
    26a4:	38 85       	ldd	r19, Y+8	; 0x08
    26a6:	25 30       	cpi	r18, 0x05	; 5
    26a8:	31 05       	cpc	r19, r1
    26aa:	21 f1       	breq	.+72     	; 0x26f4 <LCD_voidSendSpecialChar+0xac>
    26ac:	8f 81       	ldd	r24, Y+7	; 0x07
    26ae:	98 85       	ldd	r25, Y+8	; 0x08
    26b0:	85 30       	cpi	r24, 0x05	; 5
    26b2:	91 05       	cpc	r25, r1
    26b4:	dc f0       	brlt	.+54     	; 0x26ec <LCD_voidSendSpecialChar+0xa4>
    26b6:	2f 81       	ldd	r18, Y+7	; 0x07
    26b8:	38 85       	ldd	r19, Y+8	; 0x08
    26ba:	26 30       	cpi	r18, 0x06	; 6
    26bc:	31 05       	cpc	r19, r1
    26be:	f1 f0       	breq	.+60     	; 0x26fc <LCD_voidSendSpecialChar+0xb4>
    26c0:	8f 81       	ldd	r24, Y+7	; 0x07
    26c2:	98 85       	ldd	r25, Y+8	; 0x08
    26c4:	87 30       	cpi	r24, 0x07	; 7
    26c6:	91 05       	cpc	r25, r1
    26c8:	e9 f0       	breq	.+58     	; 0x2704 <LCD_voidSendSpecialChar+0xbc>
    26ca:	1f c0       	rjmp	.+62     	; 0x270a <LCD_voidSendSpecialChar+0xc2>
	{
	case 0:
		LCD_voidSendCmnd(0b01000000);
    26cc:	80 e4       	ldi	r24, 0x40	; 64
    26ce:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    26d2:	1b c0       	rjmp	.+54     	; 0x270a <LCD_voidSendSpecialChar+0xc2>

		break;
	case 1:
	    LCD_voidSendCmnd(0b01001000);
    26d4:	88 e4       	ldi	r24, 0x48	; 72
    26d6:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    26da:	17 c0       	rjmp	.+46     	; 0x270a <LCD_voidSendSpecialChar+0xc2>
		break;
	case 2:
	    LCD_voidSendCmnd(0b01010000);
    26dc:	80 e5       	ldi	r24, 0x50	; 80
    26de:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    26e2:	13 c0       	rjmp	.+38     	; 0x270a <LCD_voidSendSpecialChar+0xc2>
		break;
	case 3:
	    LCD_voidSendCmnd(0b01011000);
    26e4:	88 e5       	ldi	r24, 0x58	; 88
    26e6:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    26ea:	0f c0       	rjmp	.+30     	; 0x270a <LCD_voidSendSpecialChar+0xc2>
		break;
	case 4:
	    LCD_voidSendCmnd(0b01100000);
    26ec:	80 e6       	ldi	r24, 0x60	; 96
    26ee:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    26f2:	0b c0       	rjmp	.+22     	; 0x270a <LCD_voidSendSpecialChar+0xc2>
		break;
	case 5:
	    LCD_voidSendCmnd(0b01101000);
    26f4:	88 e6       	ldi	r24, 0x68	; 104
    26f6:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    26fa:	07 c0       	rjmp	.+14     	; 0x270a <LCD_voidSendSpecialChar+0xc2>
		break;
	case 6:
	    LCD_voidSendCmnd(0b01110000);
    26fc:	80 e7       	ldi	r24, 0x70	; 112
    26fe:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
    2702:	03 c0       	rjmp	.+6      	; 0x270a <LCD_voidSendSpecialChar+0xc2>
		break;
	case 7:
	    LCD_voidSendCmnd(0b01111000);
    2704:	88 e7       	ldi	r24, 0x78	; 120
    2706:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
		break;
	}


	 for(u8 specialchar=0 ; specialchar<8 ; specialchar++ )
    270a:	19 82       	std	Y+1, r1	; 0x01
    270c:	0e c0       	rjmp	.+28     	; 0x272a <LCD_voidSendSpecialChar+0xe2>
	 {
		 LCD_voidSendChar(Copy_PSpecialChar[specialchar]);
    270e:	89 81       	ldd	r24, Y+1	; 0x01
    2710:	28 2f       	mov	r18, r24
    2712:	30 e0       	ldi	r19, 0x00	; 0
    2714:	8d 81       	ldd	r24, Y+5	; 0x05
    2716:	9e 81       	ldd	r25, Y+6	; 0x06
    2718:	fc 01       	movw	r30, r24
    271a:	e2 0f       	add	r30, r18
    271c:	f3 1f       	adc	r31, r19
    271e:	80 81       	ld	r24, Z
    2720:	0e 94 8f 10 	call	0x211e	; 0x211e <LCD_voidSendChar>
	    LCD_voidSendCmnd(0b01111000);
		break;
	}


	 for(u8 specialchar=0 ; specialchar<8 ; specialchar++ )
    2724:	89 81       	ldd	r24, Y+1	; 0x01
    2726:	8f 5f       	subi	r24, 0xFF	; 255
    2728:	89 83       	std	Y+1, r24	; 0x01
    272a:	89 81       	ldd	r24, Y+1	; 0x01
    272c:	88 30       	cpi	r24, 0x08	; 8
    272e:	78 f3       	brcs	.-34     	; 0x270e <LCD_voidSendSpecialChar+0xc6>
	 {
		 LCD_voidSendChar(Copy_PSpecialChar[specialchar]);
	 }

	 LCD_u8_GoTo_XY( Copy_u8X, Copy_u8Y);
    2730:	8b 81       	ldd	r24, Y+3	; 0x03
    2732:	6c 81       	ldd	r22, Y+4	; 0x04
    2734:	0e 94 6e 12 	call	0x24dc	; 0x24dc <LCD_u8_GoTo_XY>
	 LCD_voidSendChar(Copy_u8CharNo);
    2738:	8a 81       	ldd	r24, Y+2	; 0x02
    273a:	0e 94 8f 10 	call	0x211e	; 0x211e <LCD_voidSendChar>


}
    273e:	28 96       	adiw	r28, 0x08	; 8
    2740:	0f b6       	in	r0, 0x3f	; 63
    2742:	f8 94       	cli
    2744:	de bf       	out	0x3e, r29	; 62
    2746:	0f be       	out	0x3f, r0	; 63
    2748:	cd bf       	out	0x3d, r28	; 61
    274a:	cf 91       	pop	r28
    274c:	df 91       	pop	r29
    274e:	08 95       	ret

00002750 <LCD_voidShiftDispRight>:

void LCD_voidShiftDispRight(void)
{
    2750:	df 93       	push	r29
    2752:	cf 93       	push	r28
    2754:	cd b7       	in	r28, 0x3d	; 61
    2756:	de b7       	in	r29, 0x3e	; 62
	LCD_voidSendCmnd(0b00011100);
    2758:	8c e1       	ldi	r24, 0x1C	; 28
    275a:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
}
    275e:	cf 91       	pop	r28
    2760:	df 91       	pop	r29
    2762:	08 95       	ret

00002764 <LCD_voidShiftDispLeft>:
void LCD_voidShiftDispLeft(void)
{
    2764:	df 93       	push	r29
    2766:	cf 93       	push	r28
    2768:	cd b7       	in	r28, 0x3d	; 61
    276a:	de b7       	in	r29, 0x3e	; 62
	LCD_voidSendCmnd(0b00011000);
    276c:	88 e1       	ldi	r24, 0x18	; 24
    276e:	0e 94 e7 0e 	call	0x1dce	; 0x1dce <LCD_voidSendCmnd>
}
    2772:	cf 91       	pop	r28
    2774:	df 91       	pop	r29
    2776:	08 95       	ret

00002778 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2778:	df 93       	push	r29
    277a:	cf 93       	push	r28
    277c:	cd b7       	in	r28, 0x3d	; 61
    277e:	de b7       	in	r29, 0x3e	; 62
    2780:	27 97       	sbiw	r28, 0x07	; 7
    2782:	0f b6       	in	r0, 0x3f	; 63
    2784:	f8 94       	cli
    2786:	de bf       	out	0x3e, r29	; 62
    2788:	0f be       	out	0x3f, r0	; 63
    278a:	cd bf       	out	0x3d, r28	; 61
    278c:	9d 83       	std	Y+5, r25	; 0x05
    278e:	8c 83       	std	Y+4, r24	; 0x04
    2790:	6e 83       	std	Y+6, r22	; 0x06
    2792:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2794:	8a e1       	ldi	r24, 0x1A	; 26
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	0e 94 94 16 	call	0x2d28	; 0x2d28 <pvPortMalloc>
    279c:	9a 83       	std	Y+2, r25	; 0x02
    279e:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    27a0:	89 81       	ldd	r24, Y+1	; 0x01
    27a2:	9a 81       	ldd	r25, Y+2	; 0x02
    27a4:	00 97       	sbiw	r24, 0x00	; 0
    27a6:	09 f4       	brne	.+2      	; 0x27aa <xCoRoutineCreate+0x32>
    27a8:	6f c0       	rjmp	.+222    	; 0x2888 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    27aa:	80 91 86 00 	lds	r24, 0x0086
    27ae:	90 91 87 00 	lds	r25, 0x0087
    27b2:	00 97       	sbiw	r24, 0x00	; 0
    27b4:	41 f4       	brne	.+16     	; 0x27c6 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    27b6:	89 81       	ldd	r24, Y+1	; 0x01
    27b8:	9a 81       	ldd	r25, Y+2	; 0x02
    27ba:	90 93 87 00 	sts	0x0087, r25
    27be:	80 93 86 00 	sts	0x0086, r24
			prvInitialiseCoRoutineLists();
    27c2:	0e 94 23 16 	call	0x2c46	; 0x2c46 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    27c6:	8e 81       	ldd	r24, Y+6	; 0x06
    27c8:	82 30       	cpi	r24, 0x02	; 2
    27ca:	10 f0       	brcs	.+4      	; 0x27d0 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    27cc:	81 e0       	ldi	r24, 0x01	; 1
    27ce:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    27d0:	e9 81       	ldd	r30, Y+1	; 0x01
    27d2:	fa 81       	ldd	r31, Y+2	; 0x02
    27d4:	11 8e       	std	Z+25, r1	; 0x19
    27d6:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    27d8:	e9 81       	ldd	r30, Y+1	; 0x01
    27da:	fa 81       	ldd	r31, Y+2	; 0x02
    27dc:	8e 81       	ldd	r24, Y+6	; 0x06
    27de:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    27e0:	e9 81       	ldd	r30, Y+1	; 0x01
    27e2:	fa 81       	ldd	r31, Y+2	; 0x02
    27e4:	8f 81       	ldd	r24, Y+7	; 0x07
    27e6:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    27e8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ea:	fa 81       	ldd	r31, Y+2	; 0x02
    27ec:	8c 81       	ldd	r24, Y+4	; 0x04
    27ee:	9d 81       	ldd	r25, Y+5	; 0x05
    27f0:	91 83       	std	Z+1, r25	; 0x01
    27f2:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    27f4:	89 81       	ldd	r24, Y+1	; 0x01
    27f6:	9a 81       	ldd	r25, Y+2	; 0x02
    27f8:	02 96       	adiw	r24, 0x02	; 2
    27fa:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    27fe:	89 81       	ldd	r24, Y+1	; 0x01
    2800:	9a 81       	ldd	r25, Y+2	; 0x02
    2802:	0c 96       	adiw	r24, 0x0c	; 12
    2804:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2808:	e9 81       	ldd	r30, Y+1	; 0x01
    280a:	fa 81       	ldd	r31, Y+2	; 0x02
    280c:	89 81       	ldd	r24, Y+1	; 0x01
    280e:	9a 81       	ldd	r25, Y+2	; 0x02
    2810:	91 87       	std	Z+9, r25	; 0x09
    2812:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2814:	e9 81       	ldd	r30, Y+1	; 0x01
    2816:	fa 81       	ldd	r31, Y+2	; 0x02
    2818:	89 81       	ldd	r24, Y+1	; 0x01
    281a:	9a 81       	ldd	r25, Y+2	; 0x02
    281c:	93 8b       	std	Z+19, r25	; 0x13
    281e:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2820:	8e 81       	ldd	r24, Y+6	; 0x06
    2822:	28 2f       	mov	r18, r24
    2824:	30 e0       	ldi	r19, 0x00	; 0
    2826:	85 e0       	ldi	r24, 0x05	; 5
    2828:	90 e0       	ldi	r25, 0x00	; 0
    282a:	82 1b       	sub	r24, r18
    282c:	93 0b       	sbc	r25, r19
    282e:	e9 81       	ldd	r30, Y+1	; 0x01
    2830:	fa 81       	ldd	r31, Y+2	; 0x02
    2832:	95 87       	std	Z+13, r25	; 0x0d
    2834:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    2836:	e9 81       	ldd	r30, Y+1	; 0x01
    2838:	fa 81       	ldd	r31, Y+2	; 0x02
    283a:	96 89       	ldd	r25, Z+22	; 0x16
    283c:	80 91 88 00 	lds	r24, 0x0088
    2840:	89 17       	cp	r24, r25
    2842:	28 f4       	brcc	.+10     	; 0x284e <xCoRoutineCreate+0xd6>
    2844:	e9 81       	ldd	r30, Y+1	; 0x01
    2846:	fa 81       	ldd	r31, Y+2	; 0x02
    2848:	86 89       	ldd	r24, Z+22	; 0x16
    284a:	80 93 88 00 	sts	0x0088, r24
    284e:	e9 81       	ldd	r30, Y+1	; 0x01
    2850:	fa 81       	ldd	r31, Y+2	; 0x02
    2852:	86 89       	ldd	r24, Z+22	; 0x16
    2854:	28 2f       	mov	r18, r24
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	c9 01       	movw	r24, r18
    285a:	88 0f       	add	r24, r24
    285c:	99 1f       	adc	r25, r25
    285e:	88 0f       	add	r24, r24
    2860:	99 1f       	adc	r25, r25
    2862:	88 0f       	add	r24, r24
    2864:	99 1f       	adc	r25, r25
    2866:	82 0f       	add	r24, r18
    2868:	93 1f       	adc	r25, r19
    286a:	ac 01       	movw	r20, r24
    286c:	41 57       	subi	r20, 0x71	; 113
    286e:	5f 4f       	sbci	r21, 0xFF	; 255
    2870:	89 81       	ldd	r24, Y+1	; 0x01
    2872:	9a 81       	ldd	r25, Y+2	; 0x02
    2874:	9c 01       	movw	r18, r24
    2876:	2e 5f       	subi	r18, 0xFE	; 254
    2878:	3f 4f       	sbci	r19, 0xFF	; 255
    287a:	ca 01       	movw	r24, r20
    287c:	b9 01       	movw	r22, r18
    287e:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>

		xReturn = pdPASS;
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	8b 83       	std	Y+3, r24	; 0x03
    2886:	02 c0       	rjmp	.+4      	; 0x288c <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2888:	8f ef       	ldi	r24, 0xFF	; 255
    288a:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    288c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    288e:	27 96       	adiw	r28, 0x07	; 7
    2890:	0f b6       	in	r0, 0x3f	; 63
    2892:	f8 94       	cli
    2894:	de bf       	out	0x3e, r29	; 62
    2896:	0f be       	out	0x3f, r0	; 63
    2898:	cd bf       	out	0x3d, r28	; 61
    289a:	cf 91       	pop	r28
    289c:	df 91       	pop	r29
    289e:	08 95       	ret

000028a0 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    28a0:	df 93       	push	r29
    28a2:	cf 93       	push	r28
    28a4:	00 d0       	rcall	.+0      	; 0x28a6 <vCoRoutineAddToDelayedList+0x6>
    28a6:	00 d0       	rcall	.+0      	; 0x28a8 <vCoRoutineAddToDelayedList+0x8>
    28a8:	00 d0       	rcall	.+0      	; 0x28aa <vCoRoutineAddToDelayedList+0xa>
    28aa:	cd b7       	in	r28, 0x3d	; 61
    28ac:	de b7       	in	r29, 0x3e	; 62
    28ae:	9c 83       	std	Y+4, r25	; 0x04
    28b0:	8b 83       	std	Y+3, r24	; 0x03
    28b2:	7e 83       	std	Y+6, r23	; 0x06
    28b4:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    28b6:	20 91 89 00 	lds	r18, 0x0089
    28ba:	30 91 8a 00 	lds	r19, 0x008A
    28be:	8b 81       	ldd	r24, Y+3	; 0x03
    28c0:	9c 81       	ldd	r25, Y+4	; 0x04
    28c2:	82 0f       	add	r24, r18
    28c4:	93 1f       	adc	r25, r19
    28c6:	9a 83       	std	Y+2, r25	; 0x02
    28c8:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28ca:	80 91 86 00 	lds	r24, 0x0086
    28ce:	90 91 87 00 	lds	r25, 0x0087
    28d2:	02 96       	adiw	r24, 0x02	; 2
    28d4:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    28d8:	e0 91 86 00 	lds	r30, 0x0086
    28dc:	f0 91 87 00 	lds	r31, 0x0087
    28e0:	89 81       	ldd	r24, Y+1	; 0x01
    28e2:	9a 81       	ldd	r25, Y+2	; 0x02
    28e4:	93 83       	std	Z+3, r25	; 0x03
    28e6:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    28e8:	20 91 89 00 	lds	r18, 0x0089
    28ec:	30 91 8a 00 	lds	r19, 0x008A
    28f0:	89 81       	ldd	r24, Y+1	; 0x01
    28f2:	9a 81       	ldd	r25, Y+2	; 0x02
    28f4:	82 17       	cp	r24, r18
    28f6:	93 07       	cpc	r25, r19
    28f8:	70 f4       	brcc	.+28     	; 0x2916 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    28fa:	80 91 b5 00 	lds	r24, 0x00B5
    28fe:	90 91 b6 00 	lds	r25, 0x00B6
    2902:	20 91 86 00 	lds	r18, 0x0086
    2906:	30 91 87 00 	lds	r19, 0x0087
    290a:	2e 5f       	subi	r18, 0xFE	; 254
    290c:	3f 4f       	sbci	r19, 0xFF	; 255
    290e:	b9 01       	movw	r22, r18
    2910:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <vListInsert>
    2914:	0d c0       	rjmp	.+26     	; 0x2930 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2916:	80 91 b3 00 	lds	r24, 0x00B3
    291a:	90 91 b4 00 	lds	r25, 0x00B4
    291e:	20 91 86 00 	lds	r18, 0x0086
    2922:	30 91 87 00 	lds	r19, 0x0087
    2926:	2e 5f       	subi	r18, 0xFE	; 254
    2928:	3f 4f       	sbci	r19, 0xFF	; 255
    292a:	b9 01       	movw	r22, r18
    292c:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <vListInsert>
	}

	if( pxEventList )
    2930:	8d 81       	ldd	r24, Y+5	; 0x05
    2932:	9e 81       	ldd	r25, Y+6	; 0x06
    2934:	00 97       	sbiw	r24, 0x00	; 0
    2936:	61 f0       	breq	.+24     	; 0x2950 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2938:	80 91 86 00 	lds	r24, 0x0086
    293c:	90 91 87 00 	lds	r25, 0x0087
    2940:	9c 01       	movw	r18, r24
    2942:	24 5f       	subi	r18, 0xF4	; 244
    2944:	3f 4f       	sbci	r19, 0xFF	; 255
    2946:	8d 81       	ldd	r24, Y+5	; 0x05
    2948:	9e 81       	ldd	r25, Y+6	; 0x06
    294a:	b9 01       	movw	r22, r18
    294c:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <vListInsert>
	}
}
    2950:	26 96       	adiw	r28, 0x06	; 6
    2952:	0f b6       	in	r0, 0x3f	; 63
    2954:	f8 94       	cli
    2956:	de bf       	out	0x3e, r29	; 62
    2958:	0f be       	out	0x3f, r0	; 63
    295a:	cd bf       	out	0x3d, r28	; 61
    295c:	cf 91       	pop	r28
    295e:	df 91       	pop	r29
    2960:	08 95       	ret

00002962 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2962:	df 93       	push	r29
    2964:	cf 93       	push	r28
    2966:	00 d0       	rcall	.+0      	; 0x2968 <prvCheckPendingReadyList+0x6>
    2968:	cd b7       	in	r28, 0x3d	; 61
    296a:	de b7       	in	r29, 0x3e	; 62
    296c:	3a c0       	rjmp	.+116    	; 0x29e2 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    296e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    2970:	e0 91 bc 00 	lds	r30, 0x00BC
    2974:	f0 91 bd 00 	lds	r31, 0x00BD
    2978:	86 81       	ldd	r24, Z+6	; 0x06
    297a:	97 81       	ldd	r25, Z+7	; 0x07
    297c:	9a 83       	std	Y+2, r25	; 0x02
    297e:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2980:	89 81       	ldd	r24, Y+1	; 0x01
    2982:	9a 81       	ldd	r25, Y+2	; 0x02
    2984:	0c 96       	adiw	r24, 0x0c	; 12
    2986:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    298a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    298c:	89 81       	ldd	r24, Y+1	; 0x01
    298e:	9a 81       	ldd	r25, Y+2	; 0x02
    2990:	02 96       	adiw	r24, 0x02	; 2
    2992:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2996:	e9 81       	ldd	r30, Y+1	; 0x01
    2998:	fa 81       	ldd	r31, Y+2	; 0x02
    299a:	96 89       	ldd	r25, Z+22	; 0x16
    299c:	80 91 88 00 	lds	r24, 0x0088
    29a0:	89 17       	cp	r24, r25
    29a2:	28 f4       	brcc	.+10     	; 0x29ae <prvCheckPendingReadyList+0x4c>
    29a4:	e9 81       	ldd	r30, Y+1	; 0x01
    29a6:	fa 81       	ldd	r31, Y+2	; 0x02
    29a8:	86 89       	ldd	r24, Z+22	; 0x16
    29aa:	80 93 88 00 	sts	0x0088, r24
    29ae:	e9 81       	ldd	r30, Y+1	; 0x01
    29b0:	fa 81       	ldd	r31, Y+2	; 0x02
    29b2:	86 89       	ldd	r24, Z+22	; 0x16
    29b4:	28 2f       	mov	r18, r24
    29b6:	30 e0       	ldi	r19, 0x00	; 0
    29b8:	c9 01       	movw	r24, r18
    29ba:	88 0f       	add	r24, r24
    29bc:	99 1f       	adc	r25, r25
    29be:	88 0f       	add	r24, r24
    29c0:	99 1f       	adc	r25, r25
    29c2:	88 0f       	add	r24, r24
    29c4:	99 1f       	adc	r25, r25
    29c6:	82 0f       	add	r24, r18
    29c8:	93 1f       	adc	r25, r19
    29ca:	ac 01       	movw	r20, r24
    29cc:	41 57       	subi	r20, 0x71	; 113
    29ce:	5f 4f       	sbci	r21, 0xFF	; 255
    29d0:	89 81       	ldd	r24, Y+1	; 0x01
    29d2:	9a 81       	ldd	r25, Y+2	; 0x02
    29d4:	9c 01       	movw	r18, r24
    29d6:	2e 5f       	subi	r18, 0xFE	; 254
    29d8:	3f 4f       	sbci	r19, 0xFF	; 255
    29da:	ca 01       	movw	r24, r20
    29dc:	b9 01       	movw	r22, r18
    29de:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    29e2:	80 91 b7 00 	lds	r24, 0x00B7
    29e6:	88 23       	and	r24, r24
    29e8:	09 f0       	breq	.+2      	; 0x29ec <prvCheckPendingReadyList+0x8a>
    29ea:	c1 cf       	rjmp	.-126    	; 0x296e <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    29ec:	0f 90       	pop	r0
    29ee:	0f 90       	pop	r0
    29f0:	cf 91       	pop	r28
    29f2:	df 91       	pop	r29
    29f4:	08 95       	ret

000029f6 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    29f6:	df 93       	push	r29
    29f8:	cf 93       	push	r28
    29fa:	00 d0       	rcall	.+0      	; 0x29fc <prvCheckDelayedList+0x6>
    29fc:	00 d0       	rcall	.+0      	; 0x29fe <prvCheckDelayedList+0x8>
    29fe:	cd b7       	in	r28, 0x3d	; 61
    2a00:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2a02:	0e 94 70 23 	call	0x46e0	; 0x46e0 <xTaskGetTickCount>
    2a06:	20 91 8b 00 	lds	r18, 0x008B
    2a0a:	30 91 8c 00 	lds	r19, 0x008C
    2a0e:	82 1b       	sub	r24, r18
    2a10:	93 0b       	sbc	r25, r19
    2a12:	90 93 8e 00 	sts	0x008E, r25
    2a16:	80 93 8d 00 	sts	0x008D, r24
    2a1a:	85 c0       	rjmp	.+266    	; 0x2b26 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2a1c:	80 91 89 00 	lds	r24, 0x0089
    2a20:	90 91 8a 00 	lds	r25, 0x008A
    2a24:	01 96       	adiw	r24, 0x01	; 1
    2a26:	90 93 8a 00 	sts	0x008A, r25
    2a2a:	80 93 89 00 	sts	0x0089, r24
		xPassedTicks--;
    2a2e:	80 91 8d 00 	lds	r24, 0x008D
    2a32:	90 91 8e 00 	lds	r25, 0x008E
    2a36:	01 97       	sbiw	r24, 0x01	; 1
    2a38:	90 93 8e 00 	sts	0x008E, r25
    2a3c:	80 93 8d 00 	sts	0x008D, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2a40:	80 91 89 00 	lds	r24, 0x0089
    2a44:	90 91 8a 00 	lds	r25, 0x008A
    2a48:	00 97       	sbiw	r24, 0x00	; 0
    2a4a:	09 f0       	breq	.+2      	; 0x2a4e <prvCheckDelayedList+0x58>
    2a4c:	64 c0       	rjmp	.+200    	; 0x2b16 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2a4e:	80 91 b3 00 	lds	r24, 0x00B3
    2a52:	90 91 b4 00 	lds	r25, 0x00B4
    2a56:	9a 83       	std	Y+2, r25	; 0x02
    2a58:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2a5a:	80 91 b5 00 	lds	r24, 0x00B5
    2a5e:	90 91 b6 00 	lds	r25, 0x00B6
    2a62:	90 93 b4 00 	sts	0x00B4, r25
    2a66:	80 93 b3 00 	sts	0x00B3, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2a6a:	89 81       	ldd	r24, Y+1	; 0x01
    2a6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2a6e:	90 93 b6 00 	sts	0x00B6, r25
    2a72:	80 93 b5 00 	sts	0x00B5, r24
    2a76:	4f c0       	rjmp	.+158    	; 0x2b16 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2a78:	e0 91 b3 00 	lds	r30, 0x00B3
    2a7c:	f0 91 b4 00 	lds	r31, 0x00B4
    2a80:	05 80       	ldd	r0, Z+5	; 0x05
    2a82:	f6 81       	ldd	r31, Z+6	; 0x06
    2a84:	e0 2d       	mov	r30, r0
    2a86:	86 81       	ldd	r24, Z+6	; 0x06
    2a88:	97 81       	ldd	r25, Z+7	; 0x07
    2a8a:	9c 83       	std	Y+4, r25	; 0x04
    2a8c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a90:	fc 81       	ldd	r31, Y+4	; 0x04
    2a92:	22 81       	ldd	r18, Z+2	; 0x02
    2a94:	33 81       	ldd	r19, Z+3	; 0x03
    2a96:	80 91 89 00 	lds	r24, 0x0089
    2a9a:	90 91 8a 00 	lds	r25, 0x008A
    2a9e:	82 17       	cp	r24, r18
    2aa0:	93 07       	cpc	r25, r19
    2aa2:	08 f4       	brcc	.+2      	; 0x2aa6 <prvCheckDelayedList+0xb0>
    2aa4:	40 c0       	rjmp	.+128    	; 0x2b26 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2aa6:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2aa8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aaa:	9c 81       	ldd	r25, Y+4	; 0x04
    2aac:	02 96       	adiw	r24, 0x02	; 2
    2aae:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab6:	84 89       	ldd	r24, Z+20	; 0x14
    2ab8:	95 89       	ldd	r25, Z+21	; 0x15
    2aba:	00 97       	sbiw	r24, 0x00	; 0
    2abc:	29 f0       	breq	.+10     	; 0x2ac8 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    2abe:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac2:	0c 96       	adiw	r24, 0x0c	; 12
    2ac4:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2ac8:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    2aca:	eb 81       	ldd	r30, Y+3	; 0x03
    2acc:	fc 81       	ldd	r31, Y+4	; 0x04
    2ace:	96 89       	ldd	r25, Z+22	; 0x16
    2ad0:	80 91 88 00 	lds	r24, 0x0088
    2ad4:	89 17       	cp	r24, r25
    2ad6:	28 f4       	brcc	.+10     	; 0x2ae2 <prvCheckDelayedList+0xec>
    2ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    2ada:	fc 81       	ldd	r31, Y+4	; 0x04
    2adc:	86 89       	ldd	r24, Z+22	; 0x16
    2ade:	80 93 88 00 	sts	0x0088, r24
    2ae2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae6:	86 89       	ldd	r24, Z+22	; 0x16
    2ae8:	28 2f       	mov	r18, r24
    2aea:	30 e0       	ldi	r19, 0x00	; 0
    2aec:	c9 01       	movw	r24, r18
    2aee:	88 0f       	add	r24, r24
    2af0:	99 1f       	adc	r25, r25
    2af2:	88 0f       	add	r24, r24
    2af4:	99 1f       	adc	r25, r25
    2af6:	88 0f       	add	r24, r24
    2af8:	99 1f       	adc	r25, r25
    2afa:	82 0f       	add	r24, r18
    2afc:	93 1f       	adc	r25, r19
    2afe:	ac 01       	movw	r20, r24
    2b00:	41 57       	subi	r20, 0x71	; 113
    2b02:	5f 4f       	sbci	r21, 0xFF	; 255
    2b04:	8b 81       	ldd	r24, Y+3	; 0x03
    2b06:	9c 81       	ldd	r25, Y+4	; 0x04
    2b08:	9c 01       	movw	r18, r24
    2b0a:	2e 5f       	subi	r18, 0xFE	; 254
    2b0c:	3f 4f       	sbci	r19, 0xFF	; 255
    2b0e:	ca 01       	movw	r24, r20
    2b10:	b9 01       	movw	r22, r18
    2b12:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2b16:	e0 91 b3 00 	lds	r30, 0x00B3
    2b1a:	f0 91 b4 00 	lds	r31, 0x00B4
    2b1e:	80 81       	ld	r24, Z
    2b20:	88 23       	and	r24, r24
    2b22:	09 f0       	breq	.+2      	; 0x2b26 <prvCheckDelayedList+0x130>
    2b24:	a9 cf       	rjmp	.-174    	; 0x2a78 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2b26:	80 91 8d 00 	lds	r24, 0x008D
    2b2a:	90 91 8e 00 	lds	r25, 0x008E
    2b2e:	00 97       	sbiw	r24, 0x00	; 0
    2b30:	09 f0       	breq	.+2      	; 0x2b34 <prvCheckDelayedList+0x13e>
    2b32:	74 cf       	rjmp	.-280    	; 0x2a1c <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    2b34:	80 91 89 00 	lds	r24, 0x0089
    2b38:	90 91 8a 00 	lds	r25, 0x008A
    2b3c:	90 93 8c 00 	sts	0x008C, r25
    2b40:	80 93 8b 00 	sts	0x008B, r24
}
    2b44:	0f 90       	pop	r0
    2b46:	0f 90       	pop	r0
    2b48:	0f 90       	pop	r0
    2b4a:	0f 90       	pop	r0
    2b4c:	cf 91       	pop	r28
    2b4e:	df 91       	pop	r29
    2b50:	08 95       	ret

00002b52 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2b52:	df 93       	push	r29
    2b54:	cf 93       	push	r28
    2b56:	00 d0       	rcall	.+0      	; 0x2b58 <vCoRoutineSchedule+0x6>
    2b58:	cd b7       	in	r28, 0x3d	; 61
    2b5a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2b5c:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2b60:	0e 94 fb 14 	call	0x29f6	; 0x29f6 <prvCheckDelayedList>
    2b64:	0a c0       	rjmp	.+20     	; 0x2b7a <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2b66:	80 91 88 00 	lds	r24, 0x0088
    2b6a:	88 23       	and	r24, r24
    2b6c:	09 f4       	brne	.+2      	; 0x2b70 <vCoRoutineSchedule+0x1e>
    2b6e:	66 c0       	rjmp	.+204    	; 0x2c3c <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2b70:	80 91 88 00 	lds	r24, 0x0088
    2b74:	81 50       	subi	r24, 0x01	; 1
    2b76:	80 93 88 00 	sts	0x0088, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2b7a:	80 91 88 00 	lds	r24, 0x0088
    2b7e:	28 2f       	mov	r18, r24
    2b80:	30 e0       	ldi	r19, 0x00	; 0
    2b82:	c9 01       	movw	r24, r18
    2b84:	88 0f       	add	r24, r24
    2b86:	99 1f       	adc	r25, r25
    2b88:	88 0f       	add	r24, r24
    2b8a:	99 1f       	adc	r25, r25
    2b8c:	88 0f       	add	r24, r24
    2b8e:	99 1f       	adc	r25, r25
    2b90:	82 0f       	add	r24, r18
    2b92:	93 1f       	adc	r25, r19
    2b94:	fc 01       	movw	r30, r24
    2b96:	e1 57       	subi	r30, 0x71	; 113
    2b98:	ff 4f       	sbci	r31, 0xFF	; 255
    2b9a:	80 81       	ld	r24, Z
    2b9c:	88 23       	and	r24, r24
    2b9e:	19 f3       	breq	.-58     	; 0x2b66 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2ba0:	80 91 88 00 	lds	r24, 0x0088
    2ba4:	28 2f       	mov	r18, r24
    2ba6:	30 e0       	ldi	r19, 0x00	; 0
    2ba8:	c9 01       	movw	r24, r18
    2baa:	88 0f       	add	r24, r24
    2bac:	99 1f       	adc	r25, r25
    2bae:	88 0f       	add	r24, r24
    2bb0:	99 1f       	adc	r25, r25
    2bb2:	88 0f       	add	r24, r24
    2bb4:	99 1f       	adc	r25, r25
    2bb6:	82 0f       	add	r24, r18
    2bb8:	93 1f       	adc	r25, r19
    2bba:	81 57       	subi	r24, 0x71	; 113
    2bbc:	9f 4f       	sbci	r25, 0xFF	; 255
    2bbe:	9a 83       	std	Y+2, r25	; 0x02
    2bc0:	89 83       	std	Y+1, r24	; 0x01
    2bc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2bc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2bc6:	01 80       	ldd	r0, Z+1	; 0x01
    2bc8:	f2 81       	ldd	r31, Z+2	; 0x02
    2bca:	e0 2d       	mov	r30, r0
    2bcc:	82 81       	ldd	r24, Z+2	; 0x02
    2bce:	93 81       	ldd	r25, Z+3	; 0x03
    2bd0:	e9 81       	ldd	r30, Y+1	; 0x01
    2bd2:	fa 81       	ldd	r31, Y+2	; 0x02
    2bd4:	92 83       	std	Z+2, r25	; 0x02
    2bd6:	81 83       	std	Z+1, r24	; 0x01
    2bd8:	e9 81       	ldd	r30, Y+1	; 0x01
    2bda:	fa 81       	ldd	r31, Y+2	; 0x02
    2bdc:	21 81       	ldd	r18, Z+1	; 0x01
    2bde:	32 81       	ldd	r19, Z+2	; 0x02
    2be0:	89 81       	ldd	r24, Y+1	; 0x01
    2be2:	9a 81       	ldd	r25, Y+2	; 0x02
    2be4:	03 96       	adiw	r24, 0x03	; 3
    2be6:	28 17       	cp	r18, r24
    2be8:	39 07       	cpc	r19, r25
    2bea:	59 f4       	brne	.+22     	; 0x2c02 <vCoRoutineSchedule+0xb0>
    2bec:	e9 81       	ldd	r30, Y+1	; 0x01
    2bee:	fa 81       	ldd	r31, Y+2	; 0x02
    2bf0:	01 80       	ldd	r0, Z+1	; 0x01
    2bf2:	f2 81       	ldd	r31, Z+2	; 0x02
    2bf4:	e0 2d       	mov	r30, r0
    2bf6:	82 81       	ldd	r24, Z+2	; 0x02
    2bf8:	93 81       	ldd	r25, Z+3	; 0x03
    2bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bfe:	92 83       	std	Z+2, r25	; 0x02
    2c00:	81 83       	std	Z+1, r24	; 0x01
    2c02:	e9 81       	ldd	r30, Y+1	; 0x01
    2c04:	fa 81       	ldd	r31, Y+2	; 0x02
    2c06:	01 80       	ldd	r0, Z+1	; 0x01
    2c08:	f2 81       	ldd	r31, Z+2	; 0x02
    2c0a:	e0 2d       	mov	r30, r0
    2c0c:	86 81       	ldd	r24, Z+6	; 0x06
    2c0e:	97 81       	ldd	r25, Z+7	; 0x07
    2c10:	90 93 87 00 	sts	0x0087, r25
    2c14:	80 93 86 00 	sts	0x0086, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2c18:	e0 91 86 00 	lds	r30, 0x0086
    2c1c:	f0 91 87 00 	lds	r31, 0x0087
    2c20:	40 81       	ld	r20, Z
    2c22:	51 81       	ldd	r21, Z+1	; 0x01
    2c24:	80 91 86 00 	lds	r24, 0x0086
    2c28:	90 91 87 00 	lds	r25, 0x0087
    2c2c:	e0 91 86 00 	lds	r30, 0x0086
    2c30:	f0 91 87 00 	lds	r31, 0x0087
    2c34:	27 89       	ldd	r18, Z+23	; 0x17
    2c36:	62 2f       	mov	r22, r18
    2c38:	fa 01       	movw	r30, r20
    2c3a:	09 95       	icall

	return;
}
    2c3c:	0f 90       	pop	r0
    2c3e:	0f 90       	pop	r0
    2c40:	cf 91       	pop	r28
    2c42:	df 91       	pop	r29
    2c44:	08 95       	ret

00002c46 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2c46:	df 93       	push	r29
    2c48:	cf 93       	push	r28
    2c4a:	0f 92       	push	r0
    2c4c:	cd b7       	in	r28, 0x3d	; 61
    2c4e:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c50:	19 82       	std	Y+1, r1	; 0x01
    2c52:	13 c0       	rjmp	.+38     	; 0x2c7a <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2c54:	89 81       	ldd	r24, Y+1	; 0x01
    2c56:	28 2f       	mov	r18, r24
    2c58:	30 e0       	ldi	r19, 0x00	; 0
    2c5a:	c9 01       	movw	r24, r18
    2c5c:	88 0f       	add	r24, r24
    2c5e:	99 1f       	adc	r25, r25
    2c60:	88 0f       	add	r24, r24
    2c62:	99 1f       	adc	r25, r25
    2c64:	88 0f       	add	r24, r24
    2c66:	99 1f       	adc	r25, r25
    2c68:	82 0f       	add	r24, r18
    2c6a:	93 1f       	adc	r25, r19
    2c6c:	81 57       	subi	r24, 0x71	; 113
    2c6e:	9f 4f       	sbci	r25, 0xFF	; 255
    2c70:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2c74:	89 81       	ldd	r24, Y+1	; 0x01
    2c76:	8f 5f       	subi	r24, 0xFF	; 255
    2c78:	89 83       	std	Y+1, r24	; 0x01
    2c7a:	89 81       	ldd	r24, Y+1	; 0x01
    2c7c:	82 30       	cpi	r24, 0x02	; 2
    2c7e:	50 f3       	brcs	.-44     	; 0x2c54 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2c80:	81 ea       	ldi	r24, 0xA1	; 161
    2c82:	90 e0       	ldi	r25, 0x00	; 0
    2c84:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2c88:	8a ea       	ldi	r24, 0xAA	; 170
    2c8a:	90 e0       	ldi	r25, 0x00	; 0
    2c8c:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2c90:	87 eb       	ldi	r24, 0xB7	; 183
    2c92:	90 e0       	ldi	r25, 0x00	; 0
    2c94:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2c98:	81 ea       	ldi	r24, 0xA1	; 161
    2c9a:	90 e0       	ldi	r25, 0x00	; 0
    2c9c:	90 93 b4 00 	sts	0x00B4, r25
    2ca0:	80 93 b3 00 	sts	0x00B3, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2ca4:	8a ea       	ldi	r24, 0xAA	; 170
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	90 93 b6 00 	sts	0x00B6, r25
    2cac:	80 93 b5 00 	sts	0x00B5, r24
}
    2cb0:	0f 90       	pop	r0
    2cb2:	cf 91       	pop	r28
    2cb4:	df 91       	pop	r29
    2cb6:	08 95       	ret

00002cb8 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2cb8:	df 93       	push	r29
    2cba:	cf 93       	push	r28
    2cbc:	00 d0       	rcall	.+0      	; 0x2cbe <xCoRoutineRemoveFromEventList+0x6>
    2cbe:	00 d0       	rcall	.+0      	; 0x2cc0 <xCoRoutineRemoveFromEventList+0x8>
    2cc0:	0f 92       	push	r0
    2cc2:	cd b7       	in	r28, 0x3d	; 61
    2cc4:	de b7       	in	r29, 0x3e	; 62
    2cc6:	9d 83       	std	Y+5, r25	; 0x05
    2cc8:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2cca:	ec 81       	ldd	r30, Y+4	; 0x04
    2ccc:	fd 81       	ldd	r31, Y+5	; 0x05
    2cce:	05 80       	ldd	r0, Z+5	; 0x05
    2cd0:	f6 81       	ldd	r31, Z+6	; 0x06
    2cd2:	e0 2d       	mov	r30, r0
    2cd4:	86 81       	ldd	r24, Z+6	; 0x06
    2cd6:	97 81       	ldd	r25, Z+7	; 0x07
    2cd8:	9b 83       	std	Y+3, r25	; 0x03
    2cda:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    2cde:	9b 81       	ldd	r25, Y+3	; 0x03
    2ce0:	0c 96       	adiw	r24, 0x0c	; 12
    2ce2:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2ce6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ce8:	9b 81       	ldd	r25, Y+3	; 0x03
    2cea:	9c 01       	movw	r18, r24
    2cec:	24 5f       	subi	r18, 0xF4	; 244
    2cee:	3f 4f       	sbci	r19, 0xFF	; 255
    2cf0:	87 eb       	ldi	r24, 0xB7	; 183
    2cf2:	90 e0       	ldi	r25, 0x00	; 0
    2cf4:	b9 01       	movw	r22, r18
    2cf6:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2cfa:	ea 81       	ldd	r30, Y+2	; 0x02
    2cfc:	fb 81       	ldd	r31, Y+3	; 0x03
    2cfe:	96 89       	ldd	r25, Z+22	; 0x16
    2d00:	e0 91 86 00 	lds	r30, 0x0086
    2d04:	f0 91 87 00 	lds	r31, 0x0087
    2d08:	86 89       	ldd	r24, Z+22	; 0x16
    2d0a:	98 17       	cp	r25, r24
    2d0c:	18 f0       	brcs	.+6      	; 0x2d14 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2d0e:	81 e0       	ldi	r24, 0x01	; 1
    2d10:	89 83       	std	Y+1, r24	; 0x01
    2d12:	01 c0       	rjmp	.+2      	; 0x2d16 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2d14:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2d16:	89 81       	ldd	r24, Y+1	; 0x01
}
    2d18:	0f 90       	pop	r0
    2d1a:	0f 90       	pop	r0
    2d1c:	0f 90       	pop	r0
    2d1e:	0f 90       	pop	r0
    2d20:	0f 90       	pop	r0
    2d22:	cf 91       	pop	r28
    2d24:	df 91       	pop	r29
    2d26:	08 95       	ret

00002d28 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2d28:	df 93       	push	r29
    2d2a:	cf 93       	push	r28
    2d2c:	00 d0       	rcall	.+0      	; 0x2d2e <pvPortMalloc+0x6>
    2d2e:	00 d0       	rcall	.+0      	; 0x2d30 <pvPortMalloc+0x8>
    2d30:	cd b7       	in	r28, 0x3d	; 61
    2d32:	de b7       	in	r29, 0x3e	; 62
    2d34:	9c 83       	std	Y+4, r25	; 0x04
    2d36:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2d38:	1a 82       	std	Y+2, r1	; 0x02
    2d3a:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2d3c:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2d40:	80 91 c0 00 	lds	r24, 0x00C0
    2d44:	90 91 c1 00 	lds	r25, 0x00C1
    2d48:	2b 81       	ldd	r18, Y+3	; 0x03
    2d4a:	3c 81       	ldd	r19, Y+4	; 0x04
    2d4c:	82 0f       	add	r24, r18
    2d4e:	93 1f       	adc	r25, r19
    2d50:	23 e0       	ldi	r18, 0x03	; 3
    2d52:	88 3e       	cpi	r24, 0xE8	; 232
    2d54:	92 07       	cpc	r25, r18
    2d56:	18 f5       	brcc	.+70     	; 0x2d9e <pvPortMalloc+0x76>
    2d58:	20 91 c0 00 	lds	r18, 0x00C0
    2d5c:	30 91 c1 00 	lds	r19, 0x00C1
    2d60:	8b 81       	ldd	r24, Y+3	; 0x03
    2d62:	9c 81       	ldd	r25, Y+4	; 0x04
    2d64:	28 0f       	add	r18, r24
    2d66:	39 1f       	adc	r19, r25
    2d68:	80 91 c0 00 	lds	r24, 0x00C0
    2d6c:	90 91 c1 00 	lds	r25, 0x00C1
    2d70:	82 17       	cp	r24, r18
    2d72:	93 07       	cpc	r25, r19
    2d74:	a0 f4       	brcc	.+40     	; 0x2d9e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2d76:	80 91 c0 00 	lds	r24, 0x00C0
    2d7a:	90 91 c1 00 	lds	r25, 0x00C1
    2d7e:	8e 53       	subi	r24, 0x3E	; 62
    2d80:	9f 4f       	sbci	r25, 0xFF	; 255
    2d82:	9a 83       	std	Y+2, r25	; 0x02
    2d84:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2d86:	20 91 c0 00 	lds	r18, 0x00C0
    2d8a:	30 91 c1 00 	lds	r19, 0x00C1
    2d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d90:	9c 81       	ldd	r25, Y+4	; 0x04
    2d92:	82 0f       	add	r24, r18
    2d94:	93 1f       	adc	r25, r19
    2d96:	90 93 c1 00 	sts	0x00C1, r25
    2d9a:	80 93 c0 00 	sts	0x00C0, r24
		}	
	}
	xTaskResumeAll();
    2d9e:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2da2:	89 81       	ldd	r24, Y+1	; 0x01
    2da4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2da6:	0f 90       	pop	r0
    2da8:	0f 90       	pop	r0
    2daa:	0f 90       	pop	r0
    2dac:	0f 90       	pop	r0
    2dae:	cf 91       	pop	r28
    2db0:	df 91       	pop	r29
    2db2:	08 95       	ret

00002db4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2db4:	df 93       	push	r29
    2db6:	cf 93       	push	r28
    2db8:	00 d0       	rcall	.+0      	; 0x2dba <vPortFree+0x6>
    2dba:	cd b7       	in	r28, 0x3d	; 61
    2dbc:	de b7       	in	r29, 0x3e	; 62
    2dbe:	9a 83       	std	Y+2, r25	; 0x02
    2dc0:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2dc2:	0f 90       	pop	r0
    2dc4:	0f 90       	pop	r0
    2dc6:	cf 91       	pop	r28
    2dc8:	df 91       	pop	r29
    2dca:	08 95       	ret

00002dcc <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2dcc:	df 93       	push	r29
    2dce:	cf 93       	push	r28
    2dd0:	cd b7       	in	r28, 0x3d	; 61
    2dd2:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2dd4:	10 92 c1 00 	sts	0x00C1, r1
    2dd8:	10 92 c0 00 	sts	0x00C0, r1
}
    2ddc:	cf 91       	pop	r28
    2dde:	df 91       	pop	r29
    2de0:	08 95       	ret

00002de2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2de2:	df 93       	push	r29
    2de4:	cf 93       	push	r28
    2de6:	cd b7       	in	r28, 0x3d	; 61
    2de8:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2dea:	20 91 c0 00 	lds	r18, 0x00C0
    2dee:	30 91 c1 00 	lds	r19, 0x00C1
    2df2:	88 ee       	ldi	r24, 0xE8	; 232
    2df4:	93 e0       	ldi	r25, 0x03	; 3
    2df6:	82 1b       	sub	r24, r18
    2df8:	93 0b       	sbc	r25, r19
}
    2dfa:	cf 91       	pop	r28
    2dfc:	df 91       	pop	r29
    2dfe:	08 95       	ret

00002e00 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2e00:	df 93       	push	r29
    2e02:	cf 93       	push	r28
    2e04:	00 d0       	rcall	.+0      	; 0x2e06 <vListInitialise+0x6>
    2e06:	cd b7       	in	r28, 0x3d	; 61
    2e08:	de b7       	in	r29, 0x3e	; 62
    2e0a:	9a 83       	std	Y+2, r25	; 0x02
    2e0c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2e0e:	89 81       	ldd	r24, Y+1	; 0x01
    2e10:	9a 81       	ldd	r25, Y+2	; 0x02
    2e12:	03 96       	adiw	r24, 0x03	; 3
    2e14:	e9 81       	ldd	r30, Y+1	; 0x01
    2e16:	fa 81       	ldd	r31, Y+2	; 0x02
    2e18:	92 83       	std	Z+2, r25	; 0x02
    2e1a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e20:	8f ef       	ldi	r24, 0xFF	; 255
    2e22:	9f ef       	ldi	r25, 0xFF	; 255
    2e24:	94 83       	std	Z+4, r25	; 0x04
    2e26:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2e28:	89 81       	ldd	r24, Y+1	; 0x01
    2e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e2c:	03 96       	adiw	r24, 0x03	; 3
    2e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e30:	fa 81       	ldd	r31, Y+2	; 0x02
    2e32:	96 83       	std	Z+6, r25	; 0x06
    2e34:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2e36:	89 81       	ldd	r24, Y+1	; 0x01
    2e38:	9a 81       	ldd	r25, Y+2	; 0x02
    2e3a:	03 96       	adiw	r24, 0x03	; 3
    2e3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e40:	90 87       	std	Z+8, r25	; 0x08
    2e42:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2e44:	e9 81       	ldd	r30, Y+1	; 0x01
    2e46:	fa 81       	ldd	r31, Y+2	; 0x02
    2e48:	10 82       	st	Z, r1
}
    2e4a:	0f 90       	pop	r0
    2e4c:	0f 90       	pop	r0
    2e4e:	cf 91       	pop	r28
    2e50:	df 91       	pop	r29
    2e52:	08 95       	ret

00002e54 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2e54:	df 93       	push	r29
    2e56:	cf 93       	push	r28
    2e58:	00 d0       	rcall	.+0      	; 0x2e5a <vListInitialiseItem+0x6>
    2e5a:	cd b7       	in	r28, 0x3d	; 61
    2e5c:	de b7       	in	r29, 0x3e	; 62
    2e5e:	9a 83       	std	Y+2, r25	; 0x02
    2e60:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2e62:	e9 81       	ldd	r30, Y+1	; 0x01
    2e64:	fa 81       	ldd	r31, Y+2	; 0x02
    2e66:	11 86       	std	Z+9, r1	; 0x09
    2e68:	10 86       	std	Z+8, r1	; 0x08
}
    2e6a:	0f 90       	pop	r0
    2e6c:	0f 90       	pop	r0
    2e6e:	cf 91       	pop	r28
    2e70:	df 91       	pop	r29
    2e72:	08 95       	ret

00002e74 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2e74:	df 93       	push	r29
    2e76:	cf 93       	push	r28
    2e78:	00 d0       	rcall	.+0      	; 0x2e7a <vListInsertEnd+0x6>
    2e7a:	00 d0       	rcall	.+0      	; 0x2e7c <vListInsertEnd+0x8>
    2e7c:	00 d0       	rcall	.+0      	; 0x2e7e <vListInsertEnd+0xa>
    2e7e:	cd b7       	in	r28, 0x3d	; 61
    2e80:	de b7       	in	r29, 0x3e	; 62
    2e82:	9c 83       	std	Y+4, r25	; 0x04
    2e84:	8b 83       	std	Y+3, r24	; 0x03
    2e86:	7e 83       	std	Y+6, r23	; 0x06
    2e88:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2e8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e8e:	81 81       	ldd	r24, Z+1	; 0x01
    2e90:	92 81       	ldd	r25, Z+2	; 0x02
    2e92:	9a 83       	std	Y+2, r25	; 0x02
    2e94:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2e96:	e9 81       	ldd	r30, Y+1	; 0x01
    2e98:	fa 81       	ldd	r31, Y+2	; 0x02
    2e9a:	82 81       	ldd	r24, Z+2	; 0x02
    2e9c:	93 81       	ldd	r25, Z+3	; 0x03
    2e9e:	ed 81       	ldd	r30, Y+5	; 0x05
    2ea0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ea2:	93 83       	std	Z+3, r25	; 0x03
    2ea4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eaa:	81 81       	ldd	r24, Z+1	; 0x01
    2eac:	92 81       	ldd	r25, Z+2	; 0x02
    2eae:	ed 81       	ldd	r30, Y+5	; 0x05
    2eb0:	fe 81       	ldd	r31, Y+6	; 0x06
    2eb2:	95 83       	std	Z+5, r25	; 0x05
    2eb4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2eb6:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eba:	02 80       	ldd	r0, Z+2	; 0x02
    2ebc:	f3 81       	ldd	r31, Z+3	; 0x03
    2ebe:	e0 2d       	mov	r30, r0
    2ec0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ec2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ec4:	95 83       	std	Z+5, r25	; 0x05
    2ec6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2ec8:	8d 81       	ldd	r24, Y+5	; 0x05
    2eca:	9e 81       	ldd	r25, Y+6	; 0x06
    2ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ece:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed0:	93 83       	std	Z+3, r25	; 0x03
    2ed2:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2ed4:	8d 81       	ldd	r24, Y+5	; 0x05
    2ed6:	9e 81       	ldd	r25, Y+6	; 0x06
    2ed8:	eb 81       	ldd	r30, Y+3	; 0x03
    2eda:	fc 81       	ldd	r31, Y+4	; 0x04
    2edc:	92 83       	std	Z+2, r25	; 0x02
    2ede:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2ee0:	ed 81       	ldd	r30, Y+5	; 0x05
    2ee2:	fe 81       	ldd	r31, Y+6	; 0x06
    2ee4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ee6:	9c 81       	ldd	r25, Y+4	; 0x04
    2ee8:	91 87       	std	Z+9, r25	; 0x09
    2eea:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2eec:	eb 81       	ldd	r30, Y+3	; 0x03
    2eee:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef0:	80 81       	ld	r24, Z
    2ef2:	8f 5f       	subi	r24, 0xFF	; 255
    2ef4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef8:	80 83       	st	Z, r24
}
    2efa:	26 96       	adiw	r28, 0x06	; 6
    2efc:	0f b6       	in	r0, 0x3f	; 63
    2efe:	f8 94       	cli
    2f00:	de bf       	out	0x3e, r29	; 62
    2f02:	0f be       	out	0x3f, r0	; 63
    2f04:	cd bf       	out	0x3d, r28	; 61
    2f06:	cf 91       	pop	r28
    2f08:	df 91       	pop	r29
    2f0a:	08 95       	ret

00002f0c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2f0c:	df 93       	push	r29
    2f0e:	cf 93       	push	r28
    2f10:	cd b7       	in	r28, 0x3d	; 61
    2f12:	de b7       	in	r29, 0x3e	; 62
    2f14:	28 97       	sbiw	r28, 0x08	; 8
    2f16:	0f b6       	in	r0, 0x3f	; 63
    2f18:	f8 94       	cli
    2f1a:	de bf       	out	0x3e, r29	; 62
    2f1c:	0f be       	out	0x3f, r0	; 63
    2f1e:	cd bf       	out	0x3d, r28	; 61
    2f20:	9e 83       	std	Y+6, r25	; 0x06
    2f22:	8d 83       	std	Y+5, r24	; 0x05
    2f24:	78 87       	std	Y+8, r23	; 0x08
    2f26:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2f28:	ef 81       	ldd	r30, Y+7	; 0x07
    2f2a:	f8 85       	ldd	r31, Y+8	; 0x08
    2f2c:	80 81       	ld	r24, Z
    2f2e:	91 81       	ldd	r25, Z+1	; 0x01
    2f30:	9a 83       	std	Y+2, r25	; 0x02
    2f32:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2f34:	89 81       	ldd	r24, Y+1	; 0x01
    2f36:	9a 81       	ldd	r25, Y+2	; 0x02
    2f38:	2f ef       	ldi	r18, 0xFF	; 255
    2f3a:	8f 3f       	cpi	r24, 0xFF	; 255
    2f3c:	92 07       	cpc	r25, r18
    2f3e:	39 f4       	brne	.+14     	; 0x2f4e <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2f40:	ed 81       	ldd	r30, Y+5	; 0x05
    2f42:	fe 81       	ldd	r31, Y+6	; 0x06
    2f44:	87 81       	ldd	r24, Z+7	; 0x07
    2f46:	90 85       	ldd	r25, Z+8	; 0x08
    2f48:	9c 83       	std	Y+4, r25	; 0x04
    2f4a:	8b 83       	std	Y+3, r24	; 0x03
    2f4c:	18 c0       	rjmp	.+48     	; 0x2f7e <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2f4e:	8d 81       	ldd	r24, Y+5	; 0x05
    2f50:	9e 81       	ldd	r25, Y+6	; 0x06
    2f52:	03 96       	adiw	r24, 0x03	; 3
    2f54:	9c 83       	std	Y+4, r25	; 0x04
    2f56:	8b 83       	std	Y+3, r24	; 0x03
    2f58:	06 c0       	rjmp	.+12     	; 0x2f66 <vListInsert+0x5a>
    2f5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f5e:	82 81       	ldd	r24, Z+2	; 0x02
    2f60:	93 81       	ldd	r25, Z+3	; 0x03
    2f62:	9c 83       	std	Y+4, r25	; 0x04
    2f64:	8b 83       	std	Y+3, r24	; 0x03
    2f66:	eb 81       	ldd	r30, Y+3	; 0x03
    2f68:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6a:	02 80       	ldd	r0, Z+2	; 0x02
    2f6c:	f3 81       	ldd	r31, Z+3	; 0x03
    2f6e:	e0 2d       	mov	r30, r0
    2f70:	20 81       	ld	r18, Z
    2f72:	31 81       	ldd	r19, Z+1	; 0x01
    2f74:	89 81       	ldd	r24, Y+1	; 0x01
    2f76:	9a 81       	ldd	r25, Y+2	; 0x02
    2f78:	82 17       	cp	r24, r18
    2f7a:	93 07       	cpc	r25, r19
    2f7c:	70 f7       	brcc	.-36     	; 0x2f5a <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2f7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2f80:	fc 81       	ldd	r31, Y+4	; 0x04
    2f82:	82 81       	ldd	r24, Z+2	; 0x02
    2f84:	93 81       	ldd	r25, Z+3	; 0x03
    2f86:	ef 81       	ldd	r30, Y+7	; 0x07
    2f88:	f8 85       	ldd	r31, Y+8	; 0x08
    2f8a:	93 83       	std	Z+3, r25	; 0x03
    2f8c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2f8e:	ef 81       	ldd	r30, Y+7	; 0x07
    2f90:	f8 85       	ldd	r31, Y+8	; 0x08
    2f92:	02 80       	ldd	r0, Z+2	; 0x02
    2f94:	f3 81       	ldd	r31, Z+3	; 0x03
    2f96:	e0 2d       	mov	r30, r0
    2f98:	8f 81       	ldd	r24, Y+7	; 0x07
    2f9a:	98 85       	ldd	r25, Y+8	; 0x08
    2f9c:	95 83       	std	Z+5, r25	; 0x05
    2f9e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2fa0:	ef 81       	ldd	r30, Y+7	; 0x07
    2fa2:	f8 85       	ldd	r31, Y+8	; 0x08
    2fa4:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa6:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa8:	95 83       	std	Z+5, r25	; 0x05
    2faa:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2fac:	8f 81       	ldd	r24, Y+7	; 0x07
    2fae:	98 85       	ldd	r25, Y+8	; 0x08
    2fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2fb4:	93 83       	std	Z+3, r25	; 0x03
    2fb6:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2fb8:	ef 81       	ldd	r30, Y+7	; 0x07
    2fba:	f8 85       	ldd	r31, Y+8	; 0x08
    2fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    2fbe:	9e 81       	ldd	r25, Y+6	; 0x06
    2fc0:	91 87       	std	Z+9, r25	; 0x09
    2fc2:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2fc4:	ed 81       	ldd	r30, Y+5	; 0x05
    2fc6:	fe 81       	ldd	r31, Y+6	; 0x06
    2fc8:	80 81       	ld	r24, Z
    2fca:	8f 5f       	subi	r24, 0xFF	; 255
    2fcc:	ed 81       	ldd	r30, Y+5	; 0x05
    2fce:	fe 81       	ldd	r31, Y+6	; 0x06
    2fd0:	80 83       	st	Z, r24
}
    2fd2:	28 96       	adiw	r28, 0x08	; 8
    2fd4:	0f b6       	in	r0, 0x3f	; 63
    2fd6:	f8 94       	cli
    2fd8:	de bf       	out	0x3e, r29	; 62
    2fda:	0f be       	out	0x3f, r0	; 63
    2fdc:	cd bf       	out	0x3d, r28	; 61
    2fde:	cf 91       	pop	r28
    2fe0:	df 91       	pop	r29
    2fe2:	08 95       	ret

00002fe4 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    2fe4:	df 93       	push	r29
    2fe6:	cf 93       	push	r28
    2fe8:	00 d0       	rcall	.+0      	; 0x2fea <vListRemove+0x6>
    2fea:	00 d0       	rcall	.+0      	; 0x2fec <vListRemove+0x8>
    2fec:	cd b7       	in	r28, 0x3d	; 61
    2fee:	de b7       	in	r29, 0x3e	; 62
    2ff0:	9c 83       	std	Y+4, r25	; 0x04
    2ff2:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2ff4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ff8:	a2 81       	ldd	r26, Z+2	; 0x02
    2ffa:	b3 81       	ldd	r27, Z+3	; 0x03
    2ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    3000:	84 81       	ldd	r24, Z+4	; 0x04
    3002:	95 81       	ldd	r25, Z+5	; 0x05
    3004:	15 96       	adiw	r26, 0x05	; 5
    3006:	9c 93       	st	X, r25
    3008:	8e 93       	st	-X, r24
    300a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    300c:	eb 81       	ldd	r30, Y+3	; 0x03
    300e:	fc 81       	ldd	r31, Y+4	; 0x04
    3010:	a4 81       	ldd	r26, Z+4	; 0x04
    3012:	b5 81       	ldd	r27, Z+5	; 0x05
    3014:	eb 81       	ldd	r30, Y+3	; 0x03
    3016:	fc 81       	ldd	r31, Y+4	; 0x04
    3018:	82 81       	ldd	r24, Z+2	; 0x02
    301a:	93 81       	ldd	r25, Z+3	; 0x03
    301c:	13 96       	adiw	r26, 0x03	; 3
    301e:	9c 93       	st	X, r25
    3020:	8e 93       	st	-X, r24
    3022:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    3024:	eb 81       	ldd	r30, Y+3	; 0x03
    3026:	fc 81       	ldd	r31, Y+4	; 0x04
    3028:	80 85       	ldd	r24, Z+8	; 0x08
    302a:	91 85       	ldd	r25, Z+9	; 0x09
    302c:	9a 83       	std	Y+2, r25	; 0x02
    302e:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3030:	e9 81       	ldd	r30, Y+1	; 0x01
    3032:	fa 81       	ldd	r31, Y+2	; 0x02
    3034:	21 81       	ldd	r18, Z+1	; 0x01
    3036:	32 81       	ldd	r19, Z+2	; 0x02
    3038:	8b 81       	ldd	r24, Y+3	; 0x03
    303a:	9c 81       	ldd	r25, Y+4	; 0x04
    303c:	28 17       	cp	r18, r24
    303e:	39 07       	cpc	r19, r25
    3040:	41 f4       	brne	.+16     	; 0x3052 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3042:	eb 81       	ldd	r30, Y+3	; 0x03
    3044:	fc 81       	ldd	r31, Y+4	; 0x04
    3046:	84 81       	ldd	r24, Z+4	; 0x04
    3048:	95 81       	ldd	r25, Z+5	; 0x05
    304a:	e9 81       	ldd	r30, Y+1	; 0x01
    304c:	fa 81       	ldd	r31, Y+2	; 0x02
    304e:	92 83       	std	Z+2, r25	; 0x02
    3050:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    3052:	eb 81       	ldd	r30, Y+3	; 0x03
    3054:	fc 81       	ldd	r31, Y+4	; 0x04
    3056:	11 86       	std	Z+9, r1	; 0x09
    3058:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    305a:	e9 81       	ldd	r30, Y+1	; 0x01
    305c:	fa 81       	ldd	r31, Y+2	; 0x02
    305e:	80 81       	ld	r24, Z
    3060:	81 50       	subi	r24, 0x01	; 1
    3062:	e9 81       	ldd	r30, Y+1	; 0x01
    3064:	fa 81       	ldd	r31, Y+2	; 0x02
    3066:	80 83       	st	Z, r24
}
    3068:	0f 90       	pop	r0
    306a:	0f 90       	pop	r0
    306c:	0f 90       	pop	r0
    306e:	0f 90       	pop	r0
    3070:	cf 91       	pop	r28
    3072:	df 91       	pop	r29
    3074:	08 95       	ret

00003076 <main>:

/* Create Global Varible of Semaphore Type */
xSemaphoreHandle App_LCDSemph;

int main(void)
{
    3076:	af 92       	push	r10
    3078:	bf 92       	push	r11
    307a:	cf 92       	push	r12
    307c:	df 92       	push	r13
    307e:	ef 92       	push	r14
    3080:	ff 92       	push	r15
    3082:	0f 93       	push	r16
    3084:	df 93       	push	r29
    3086:	cf 93       	push	r28
    3088:	cd b7       	in	r28, 0x3d	; 61
    308a:	de b7       	in	r29, 0x3e	; 62
	DIO_u8Init();
    308c:	0e 94 4f 06 	call	0xc9e	; 0xc9e <DIO_u8Init>

	LCD_voidInit();
    3090:	0e 94 14 0b 	call	0x1628	; 0x1628 <LCD_voidInit>
/* Create Tasks */
//	xTaskCreate(&App_voidTask1,NULL,200,NULL,TASK1_u8_PRIORITY,NULL);
//	xTaskCreate(&App_voidTask2,NULL,200,NULL,TASK2_u8_PRIORITY,NULL);
//	xTaskCreate(&App_voidTask3,NULL,200,NULL,TASK3_u8_PRIORITY,NULL);
	xTaskCreate(&App_voidLCD1,NULL,200,NULL,2,NULL);
    3094:	83 ef       	ldi	r24, 0xF3	; 243
    3096:	98 e1       	ldi	r25, 0x18	; 24
    3098:	60 e0       	ldi	r22, 0x00	; 0
    309a:	70 e0       	ldi	r23, 0x00	; 0
    309c:	48 ec       	ldi	r20, 0xC8	; 200
    309e:	50 e0       	ldi	r21, 0x00	; 0
    30a0:	20 e0       	ldi	r18, 0x00	; 0
    30a2:	30 e0       	ldi	r19, 0x00	; 0
    30a4:	02 e0       	ldi	r16, 0x02	; 2
    30a6:	ee 24       	eor	r14, r14
    30a8:	ff 24       	eor	r15, r15
    30aa:	cc 24       	eor	r12, r12
    30ac:	dd 24       	eor	r13, r13
    30ae:	aa 24       	eor	r10, r10
    30b0:	bb 24       	eor	r11, r11
    30b2:	0e 94 9e 20 	call	0x413c	; 0x413c <xTaskGenericCreate>
	xTaskCreate(&App_voidLCD2,NULL,200,NULL,2,NULL);
    30b6:	8f e1       	ldi	r24, 0x1F	; 31
    30b8:	99 e1       	ldi	r25, 0x19	; 25
    30ba:	60 e0       	ldi	r22, 0x00	; 0
    30bc:	70 e0       	ldi	r23, 0x00	; 0
    30be:	48 ec       	ldi	r20, 0xC8	; 200
    30c0:	50 e0       	ldi	r21, 0x00	; 0
    30c2:	20 e0       	ldi	r18, 0x00	; 0
    30c4:	30 e0       	ldi	r19, 0x00	; 0
    30c6:	02 e0       	ldi	r16, 0x02	; 2
    30c8:	ee 24       	eor	r14, r14
    30ca:	ff 24       	eor	r15, r15
    30cc:	cc 24       	eor	r12, r12
    30ce:	dd 24       	eor	r13, r13
    30d0:	aa 24       	eor	r10, r10
    30d2:	bb 24       	eor	r11, r11
    30d4:	0e 94 9e 20 	call	0x413c	; 0x413c <xTaskGenericCreate>


	/* Create Semaphore */
	vSemaphoreCreateBinary(App_LCDSemph);
    30d8:	81 e0       	ldi	r24, 0x01	; 1
    30da:	60 e0       	ldi	r22, 0x00	; 0
    30dc:	0e 94 1d 1c 	call	0x383a	; 0x383a <xQueueCreate>
    30e0:	90 93 11 05 	sts	0x0511, r25
    30e4:	80 93 10 05 	sts	0x0510, r24
    30e8:	80 91 10 05 	lds	r24, 0x0510
    30ec:	90 91 11 05 	lds	r25, 0x0511
    30f0:	00 97       	sbiw	r24, 0x00	; 0
    30f2:	59 f0       	breq	.+22     	; 0x310a <main+0x94>
    30f4:	80 91 10 05 	lds	r24, 0x0510
    30f8:	90 91 11 05 	lds	r25, 0x0511
    30fc:	60 e0       	ldi	r22, 0x00	; 0
    30fe:	70 e0       	ldi	r23, 0x00	; 0
    3100:	40 e0       	ldi	r20, 0x00	; 0
    3102:	50 e0       	ldi	r21, 0x00	; 0
    3104:	20 e0       	ldi	r18, 0x00	; 0
    3106:	0e 94 c6 1c 	call	0x398c	; 0x398c <xQueueGenericSend>

	/* Start Scheduler */
	vTaskStartScheduler();
    310a:	0e 94 97 22 	call	0x452e	; 0x452e <vTaskStartScheduler>
	return 0;
    310e:	80 e0       	ldi	r24, 0x00	; 0
    3110:	90 e0       	ldi	r25, 0x00	; 0
}
    3112:	cf 91       	pop	r28
    3114:	df 91       	pop	r29
    3116:	0f 91       	pop	r16
    3118:	ff 90       	pop	r15
    311a:	ef 90       	pop	r14
    311c:	df 90       	pop	r13
    311e:	cf 90       	pop	r12
    3120:	bf 90       	pop	r11
    3122:	af 90       	pop	r10
    3124:	08 95       	ret

00003126 <App_voidTask1>:

void App_voidTask1(void * Copy_pv)
{
    3126:	df 93       	push	r29
    3128:	cf 93       	push	r28
    312a:	00 d0       	rcall	.+0      	; 0x312c <App_voidTask1+0x6>
    312c:	cd b7       	in	r28, 0x3d	; 61
    312e:	de b7       	in	r29, 0x3e	; 62
    3130:	9a 83       	std	Y+2, r25	; 0x02
    3132:	89 83       	std	Y+1, r24	; 0x01
	static u8 flag = 0;
	while(1)
	{

		if(flag == 0)
    3134:	80 91 aa 04 	lds	r24, 0x04AA
    3138:	88 23       	and	r24, r24
    313a:	49 f4       	brne	.+18     	; 0x314e <App_voidTask1+0x28>
		{

			DIO_u8SetPinValue(DIO_u8_PORTB,DIO_u8_PIN0,DIO_u8_HIGH);
    313c:	81 e0       	ldi	r24, 0x01	; 1
    313e:	60 e0       	ldi	r22, 0x00	; 0
    3140:	41 e0       	ldi	r20, 0x01	; 1
    3142:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
			flag = 1;
    3146:	81 e0       	ldi	r24, 0x01	; 1
    3148:	80 93 aa 04 	sts	0x04AA, r24
    314c:	07 c0       	rjmp	.+14     	; 0x315c <App_voidTask1+0x36>
		}
		else
		{
			DIO_u8SetPinValue(DIO_u8_PORTB,DIO_u8_PIN0,DIO_u8_LOW);
    314e:	81 e0       	ldi	r24, 0x01	; 1
    3150:	60 e0       	ldi	r22, 0x00	; 0
    3152:	40 e0       	ldi	r20, 0x00	; 0
    3154:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
			flag = 0;
    3158:	10 92 aa 04 	sts	0x04AA, r1
		}
		vTaskDelay(1000);
    315c:	88 ee       	ldi	r24, 0xE8	; 232
    315e:	93 e0       	ldi	r25, 0x03	; 3
    3160:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskDelay>
    3164:	e7 cf       	rjmp	.-50     	; 0x3134 <App_voidTask1+0xe>

00003166 <App_voidTask2>:
	}
}

void App_voidTask2(void * Copy_pv)
{
    3166:	df 93       	push	r29
    3168:	cf 93       	push	r28
    316a:	00 d0       	rcall	.+0      	; 0x316c <App_voidTask2+0x6>
    316c:	cd b7       	in	r28, 0x3d	; 61
    316e:	de b7       	in	r29, 0x3e	; 62
    3170:	9a 83       	std	Y+2, r25	; 0x02
    3172:	89 83       	std	Y+1, r24	; 0x01
	static u8 flag = 0;
	while(1)
	{

		if(flag == 0)
    3174:	80 91 ab 04 	lds	r24, 0x04AB
    3178:	88 23       	and	r24, r24
    317a:	49 f4       	brne	.+18     	; 0x318e <App_voidTask2+0x28>
		{

			DIO_u8SetPinValue(DIO_u8_PORTB,DIO_u8_PIN1,DIO_u8_HIGH);
    317c:	81 e0       	ldi	r24, 0x01	; 1
    317e:	61 e0       	ldi	r22, 0x01	; 1
    3180:	41 e0       	ldi	r20, 0x01	; 1
    3182:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
			flag = 1;
    3186:	81 e0       	ldi	r24, 0x01	; 1
    3188:	80 93 ab 04 	sts	0x04AB, r24
    318c:	07 c0       	rjmp	.+14     	; 0x319c <App_voidTask2+0x36>
		}
		else
		{
			DIO_u8SetPinValue(DIO_u8_PORTB,DIO_u8_PIN1,DIO_u8_LOW);
    318e:	81 e0       	ldi	r24, 0x01	; 1
    3190:	61 e0       	ldi	r22, 0x01	; 1
    3192:	40 e0       	ldi	r20, 0x00	; 0
    3194:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
			flag = 0;
    3198:	10 92 ab 04 	sts	0x04AB, r1
		}
		vTaskDelay(2000);
    319c:	80 ed       	ldi	r24, 0xD0	; 208
    319e:	97 e0       	ldi	r25, 0x07	; 7
    31a0:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskDelay>
    31a4:	e7 cf       	rjmp	.-50     	; 0x3174 <App_voidTask2+0xe>

000031a6 <App_voidTask3>:
	}
}

void App_voidTask3(void * Copy_pv)
{
    31a6:	df 93       	push	r29
    31a8:	cf 93       	push	r28
    31aa:	00 d0       	rcall	.+0      	; 0x31ac <App_voidTask3+0x6>
    31ac:	cd b7       	in	r28, 0x3d	; 61
    31ae:	de b7       	in	r29, 0x3e	; 62
    31b0:	9a 83       	std	Y+2, r25	; 0x02
    31b2:	89 83       	std	Y+1, r24	; 0x01
	static u8 flag = 0;
	while(1)
	{

		if(flag == 0)
    31b4:	80 91 ac 04 	lds	r24, 0x04AC
    31b8:	88 23       	and	r24, r24
    31ba:	49 f4       	brne	.+18     	; 0x31ce <App_voidTask3+0x28>
		{
			DIO_u8SetPinValue(DIO_u8_PORTB,DIO_u8_PIN2,DIO_u8_HIGH);
    31bc:	81 e0       	ldi	r24, 0x01	; 1
    31be:	62 e0       	ldi	r22, 0x02	; 2
    31c0:	41 e0       	ldi	r20, 0x01	; 1
    31c2:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
			flag = 1;
    31c6:	81 e0       	ldi	r24, 0x01	; 1
    31c8:	80 93 ac 04 	sts	0x04AC, r24
    31cc:	07 c0       	rjmp	.+14     	; 0x31dc <App_voidTask3+0x36>
		}
		else
		{
			DIO_u8SetPinValue(DIO_u8_PORTB,DIO_u8_PIN2,DIO_u8_LOW);
    31ce:	81 e0       	ldi	r24, 0x01	; 1
    31d0:	62 e0       	ldi	r22, 0x02	; 2
    31d2:	40 e0       	ldi	r20, 0x00	; 0
    31d4:	0e 94 9d 07 	call	0xf3a	; 0xf3a <DIO_u8SetPinValue>
			flag = 0;
    31d8:	10 92 ac 04 	sts	0x04AC, r1
		}
		vTaskDelay(5000);
    31dc:	88 e8       	ldi	r24, 0x88	; 136
    31de:	93 e1       	ldi	r25, 0x13	; 19
    31e0:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskDelay>
    31e4:	e7 cf       	rjmp	.-50     	; 0x31b4 <App_voidTask3+0xe>

000031e6 <App_voidLCD1>:
	}
}

void App_voidLCD1(void * Copy_pv)
{
    31e6:	df 93       	push	r29
    31e8:	cf 93       	push	r28
    31ea:	00 d0       	rcall	.+0      	; 0x31ec <App_voidLCD1+0x6>
    31ec:	cd b7       	in	r28, 0x3d	; 61
    31ee:	de b7       	in	r29, 0x3e	; 62
    31f0:	9a 83       	std	Y+2, r25	; 0x02
    31f2:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(App_LCDSemph,portMAX_DELAY) == pdTRUE)
    31f4:	80 91 10 05 	lds	r24, 0x0510
    31f8:	90 91 11 05 	lds	r25, 0x0511
    31fc:	60 e0       	ldi	r22, 0x00	; 0
    31fe:	70 e0       	ldi	r23, 0x00	; 0
    3200:	4f ef       	ldi	r20, 0xFF	; 255
    3202:	5f ef       	ldi	r21, 0xFF	; 255
    3204:	20 e0       	ldi	r18, 0x00	; 0
    3206:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xQueueGenericReceive>
    320a:	81 30       	cpi	r24, 0x01	; 1
    320c:	99 f7       	brne	.-26     	; 0x31f4 <App_voidLCD1+0xe>
		{
		LCD_u8_GoTo_XY(0,0);
    320e:	80 e0       	ldi	r24, 0x00	; 0
    3210:	60 e0       	ldi	r22, 0x00	; 0
    3212:	0e 94 6e 12 	call	0x24dc	; 0x24dc <LCD_u8_GoTo_XY>
		LCD_voidWriteString("Iam TASK 1");
    3216:	80 e6       	ldi	r24, 0x60	; 96
    3218:	90 e0       	ldi	r25, 0x00	; 0
    321a:	0e 94 37 12 	call	0x246e	; 0x246e <LCD_voidWriteString>
		xSemaphoreGive(App_LCDSemph);
    321e:	80 91 10 05 	lds	r24, 0x0510
    3222:	90 91 11 05 	lds	r25, 0x0511
    3226:	60 e0       	ldi	r22, 0x00	; 0
    3228:	70 e0       	ldi	r23, 0x00	; 0
    322a:	40 e0       	ldi	r20, 0x00	; 0
    322c:	50 e0       	ldi	r21, 0x00	; 0
    322e:	20 e0       	ldi	r18, 0x00	; 0
    3230:	0e 94 c6 1c 	call	0x398c	; 0x398c <xQueueGenericSend>
		vTaskDelay(1000);
    3234:	88 ee       	ldi	r24, 0xE8	; 232
    3236:	93 e0       	ldi	r25, 0x03	; 3
    3238:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskDelay>
    323c:	db cf       	rjmp	.-74     	; 0x31f4 <App_voidLCD1+0xe>

0000323e <App_voidLCD2>:
		}
	}
}

void App_voidLCD2(void * Copy_pv)
{
    323e:	df 93       	push	r29
    3240:	cf 93       	push	r28
    3242:	00 d0       	rcall	.+0      	; 0x3244 <App_voidLCD2+0x6>
    3244:	cd b7       	in	r28, 0x3d	; 61
    3246:	de b7       	in	r29, 0x3e	; 62
    3248:	9a 83       	std	Y+2, r25	; 0x02
    324a:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		if(xSemaphoreTake(App_LCDSemph,portMAX_DELAY) == pdTRUE)
    324c:	80 91 10 05 	lds	r24, 0x0510
    3250:	90 91 11 05 	lds	r25, 0x0511
    3254:	60 e0       	ldi	r22, 0x00	; 0
    3256:	70 e0       	ldi	r23, 0x00	; 0
    3258:	4f ef       	ldi	r20, 0xFF	; 255
    325a:	5f ef       	ldi	r21, 0xFF	; 255
    325c:	20 e0       	ldi	r18, 0x00	; 0
    325e:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xQueueGenericReceive>
    3262:	81 30       	cpi	r24, 0x01	; 1
    3264:	99 f7       	brne	.-26     	; 0x324c <App_voidLCD2+0xe>
		{
		LCD_u8_GoTo_XY(1,0);
    3266:	81 e0       	ldi	r24, 0x01	; 1
    3268:	60 e0       	ldi	r22, 0x00	; 0
    326a:	0e 94 6e 12 	call	0x24dc	; 0x24dc <LCD_u8_GoTo_XY>
		LCD_voidWriteString("Iam TASK 2");
    326e:	8b e6       	ldi	r24, 0x6B	; 107
    3270:	90 e0       	ldi	r25, 0x00	; 0
    3272:	0e 94 37 12 	call	0x246e	; 0x246e <LCD_voidWriteString>
		xSemaphoreGive(App_LCDSemph);
    3276:	80 91 10 05 	lds	r24, 0x0510
    327a:	90 91 11 05 	lds	r25, 0x0511
    327e:	60 e0       	ldi	r22, 0x00	; 0
    3280:	70 e0       	ldi	r23, 0x00	; 0
    3282:	40 e0       	ldi	r20, 0x00	; 0
    3284:	50 e0       	ldi	r21, 0x00	; 0
    3286:	20 e0       	ldi	r18, 0x00	; 0
    3288:	0e 94 c6 1c 	call	0x398c	; 0x398c <xQueueGenericSend>
		vTaskDelay(1000);
    328c:	88 ee       	ldi	r24, 0xE8	; 232
    328e:	93 e0       	ldi	r25, 0x03	; 3
    3290:	0e 94 62 22 	call	0x44c4	; 0x44c4 <vTaskDelay>
    3294:	db cf       	rjmp	.-74     	; 0x324c <App_voidLCD2+0xe>

00003296 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    3296:	df 93       	push	r29
    3298:	cf 93       	push	r28
    329a:	cd b7       	in	r28, 0x3d	; 61
    329c:	de b7       	in	r29, 0x3e	; 62
    329e:	28 97       	sbiw	r28, 0x08	; 8
    32a0:	0f b6       	in	r0, 0x3f	; 63
    32a2:	f8 94       	cli
    32a4:	de bf       	out	0x3e, r29	; 62
    32a6:	0f be       	out	0x3f, r0	; 63
    32a8:	cd bf       	out	0x3d, r28	; 61
    32aa:	9c 83       	std	Y+4, r25	; 0x04
    32ac:	8b 83       	std	Y+3, r24	; 0x03
    32ae:	7e 83       	std	Y+6, r23	; 0x06
    32b0:	6d 83       	std	Y+5, r22	; 0x05
    32b2:	58 87       	std	Y+8, r21	; 0x08
    32b4:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    32b6:	eb 81       	ldd	r30, Y+3	; 0x03
    32b8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ba:	81 e1       	ldi	r24, 0x11	; 17
    32bc:	80 83       	st	Z, r24
	pxTopOfStack--;
    32be:	8b 81       	ldd	r24, Y+3	; 0x03
    32c0:	9c 81       	ldd	r25, Y+4	; 0x04
    32c2:	01 97       	sbiw	r24, 0x01	; 1
    32c4:	9c 83       	std	Y+4, r25	; 0x04
    32c6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    32c8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ca:	fc 81       	ldd	r31, Y+4	; 0x04
    32cc:	82 e2       	ldi	r24, 0x22	; 34
    32ce:	80 83       	st	Z, r24
	pxTopOfStack--;
    32d0:	8b 81       	ldd	r24, Y+3	; 0x03
    32d2:	9c 81       	ldd	r25, Y+4	; 0x04
    32d4:	01 97       	sbiw	r24, 0x01	; 1
    32d6:	9c 83       	std	Y+4, r25	; 0x04
    32d8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    32da:	eb 81       	ldd	r30, Y+3	; 0x03
    32dc:	fc 81       	ldd	r31, Y+4	; 0x04
    32de:	83 e3       	ldi	r24, 0x33	; 51
    32e0:	80 83       	st	Z, r24
	pxTopOfStack--;
    32e2:	8b 81       	ldd	r24, Y+3	; 0x03
    32e4:	9c 81       	ldd	r25, Y+4	; 0x04
    32e6:	01 97       	sbiw	r24, 0x01	; 1
    32e8:	9c 83       	std	Y+4, r25	; 0x04
    32ea:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    32ec:	8d 81       	ldd	r24, Y+5	; 0x05
    32ee:	9e 81       	ldd	r25, Y+6	; 0x06
    32f0:	9a 83       	std	Y+2, r25	; 0x02
    32f2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    32f4:	89 81       	ldd	r24, Y+1	; 0x01
    32f6:	eb 81       	ldd	r30, Y+3	; 0x03
    32f8:	fc 81       	ldd	r31, Y+4	; 0x04
    32fa:	80 83       	st	Z, r24
	pxTopOfStack--;
    32fc:	8b 81       	ldd	r24, Y+3	; 0x03
    32fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3300:	01 97       	sbiw	r24, 0x01	; 1
    3302:	9c 83       	std	Y+4, r25	; 0x04
    3304:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3306:	89 81       	ldd	r24, Y+1	; 0x01
    3308:	9a 81       	ldd	r25, Y+2	; 0x02
    330a:	89 2f       	mov	r24, r25
    330c:	99 27       	eor	r25, r25
    330e:	9a 83       	std	Y+2, r25	; 0x02
    3310:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3312:	89 81       	ldd	r24, Y+1	; 0x01
    3314:	eb 81       	ldd	r30, Y+3	; 0x03
    3316:	fc 81       	ldd	r31, Y+4	; 0x04
    3318:	80 83       	st	Z, r24
	pxTopOfStack--;
    331a:	8b 81       	ldd	r24, Y+3	; 0x03
    331c:	9c 81       	ldd	r25, Y+4	; 0x04
    331e:	01 97       	sbiw	r24, 0x01	; 1
    3320:	9c 83       	std	Y+4, r25	; 0x04
    3322:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    3324:	eb 81       	ldd	r30, Y+3	; 0x03
    3326:	fc 81       	ldd	r31, Y+4	; 0x04
    3328:	10 82       	st	Z, r1
	pxTopOfStack--;
    332a:	8b 81       	ldd	r24, Y+3	; 0x03
    332c:	9c 81       	ldd	r25, Y+4	; 0x04
    332e:	01 97       	sbiw	r24, 0x01	; 1
    3330:	9c 83       	std	Y+4, r25	; 0x04
    3332:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3334:	eb 81       	ldd	r30, Y+3	; 0x03
    3336:	fc 81       	ldd	r31, Y+4	; 0x04
    3338:	80 e8       	ldi	r24, 0x80	; 128
    333a:	80 83       	st	Z, r24
	pxTopOfStack--;
    333c:	8b 81       	ldd	r24, Y+3	; 0x03
    333e:	9c 81       	ldd	r25, Y+4	; 0x04
    3340:	01 97       	sbiw	r24, 0x01	; 1
    3342:	9c 83       	std	Y+4, r25	; 0x04
    3344:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3346:	eb 81       	ldd	r30, Y+3	; 0x03
    3348:	fc 81       	ldd	r31, Y+4	; 0x04
    334a:	10 82       	st	Z, r1
	pxTopOfStack--;
    334c:	8b 81       	ldd	r24, Y+3	; 0x03
    334e:	9c 81       	ldd	r25, Y+4	; 0x04
    3350:	01 97       	sbiw	r24, 0x01	; 1
    3352:	9c 83       	std	Y+4, r25	; 0x04
    3354:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3356:	eb 81       	ldd	r30, Y+3	; 0x03
    3358:	fc 81       	ldd	r31, Y+4	; 0x04
    335a:	82 e0       	ldi	r24, 0x02	; 2
    335c:	80 83       	st	Z, r24
	pxTopOfStack--;
    335e:	8b 81       	ldd	r24, Y+3	; 0x03
    3360:	9c 81       	ldd	r25, Y+4	; 0x04
    3362:	01 97       	sbiw	r24, 0x01	; 1
    3364:	9c 83       	std	Y+4, r25	; 0x04
    3366:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    3368:	eb 81       	ldd	r30, Y+3	; 0x03
    336a:	fc 81       	ldd	r31, Y+4	; 0x04
    336c:	83 e0       	ldi	r24, 0x03	; 3
    336e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3370:	8b 81       	ldd	r24, Y+3	; 0x03
    3372:	9c 81       	ldd	r25, Y+4	; 0x04
    3374:	01 97       	sbiw	r24, 0x01	; 1
    3376:	9c 83       	std	Y+4, r25	; 0x04
    3378:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    337a:	eb 81       	ldd	r30, Y+3	; 0x03
    337c:	fc 81       	ldd	r31, Y+4	; 0x04
    337e:	84 e0       	ldi	r24, 0x04	; 4
    3380:	80 83       	st	Z, r24
	pxTopOfStack--;
    3382:	8b 81       	ldd	r24, Y+3	; 0x03
    3384:	9c 81       	ldd	r25, Y+4	; 0x04
    3386:	01 97       	sbiw	r24, 0x01	; 1
    3388:	9c 83       	std	Y+4, r25	; 0x04
    338a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    338c:	eb 81       	ldd	r30, Y+3	; 0x03
    338e:	fc 81       	ldd	r31, Y+4	; 0x04
    3390:	85 e0       	ldi	r24, 0x05	; 5
    3392:	80 83       	st	Z, r24
	pxTopOfStack--;
    3394:	8b 81       	ldd	r24, Y+3	; 0x03
    3396:	9c 81       	ldd	r25, Y+4	; 0x04
    3398:	01 97       	sbiw	r24, 0x01	; 1
    339a:	9c 83       	std	Y+4, r25	; 0x04
    339c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    339e:	eb 81       	ldd	r30, Y+3	; 0x03
    33a0:	fc 81       	ldd	r31, Y+4	; 0x04
    33a2:	86 e0       	ldi	r24, 0x06	; 6
    33a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    33a6:	8b 81       	ldd	r24, Y+3	; 0x03
    33a8:	9c 81       	ldd	r25, Y+4	; 0x04
    33aa:	01 97       	sbiw	r24, 0x01	; 1
    33ac:	9c 83       	std	Y+4, r25	; 0x04
    33ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    33b0:	eb 81       	ldd	r30, Y+3	; 0x03
    33b2:	fc 81       	ldd	r31, Y+4	; 0x04
    33b4:	87 e0       	ldi	r24, 0x07	; 7
    33b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    33b8:	8b 81       	ldd	r24, Y+3	; 0x03
    33ba:	9c 81       	ldd	r25, Y+4	; 0x04
    33bc:	01 97       	sbiw	r24, 0x01	; 1
    33be:	9c 83       	std	Y+4, r25	; 0x04
    33c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    33c2:	eb 81       	ldd	r30, Y+3	; 0x03
    33c4:	fc 81       	ldd	r31, Y+4	; 0x04
    33c6:	88 e0       	ldi	r24, 0x08	; 8
    33c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    33ca:	8b 81       	ldd	r24, Y+3	; 0x03
    33cc:	9c 81       	ldd	r25, Y+4	; 0x04
    33ce:	01 97       	sbiw	r24, 0x01	; 1
    33d0:	9c 83       	std	Y+4, r25	; 0x04
    33d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    33d4:	eb 81       	ldd	r30, Y+3	; 0x03
    33d6:	fc 81       	ldd	r31, Y+4	; 0x04
    33d8:	89 e0       	ldi	r24, 0x09	; 9
    33da:	80 83       	st	Z, r24
	pxTopOfStack--;
    33dc:	8b 81       	ldd	r24, Y+3	; 0x03
    33de:	9c 81       	ldd	r25, Y+4	; 0x04
    33e0:	01 97       	sbiw	r24, 0x01	; 1
    33e2:	9c 83       	std	Y+4, r25	; 0x04
    33e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    33e6:	eb 81       	ldd	r30, Y+3	; 0x03
    33e8:	fc 81       	ldd	r31, Y+4	; 0x04
    33ea:	80 e1       	ldi	r24, 0x10	; 16
    33ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    33ee:	8b 81       	ldd	r24, Y+3	; 0x03
    33f0:	9c 81       	ldd	r25, Y+4	; 0x04
    33f2:	01 97       	sbiw	r24, 0x01	; 1
    33f4:	9c 83       	std	Y+4, r25	; 0x04
    33f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    33f8:	eb 81       	ldd	r30, Y+3	; 0x03
    33fa:	fc 81       	ldd	r31, Y+4	; 0x04
    33fc:	81 e1       	ldi	r24, 0x11	; 17
    33fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    3400:	8b 81       	ldd	r24, Y+3	; 0x03
    3402:	9c 81       	ldd	r25, Y+4	; 0x04
    3404:	01 97       	sbiw	r24, 0x01	; 1
    3406:	9c 83       	std	Y+4, r25	; 0x04
    3408:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    340a:	eb 81       	ldd	r30, Y+3	; 0x03
    340c:	fc 81       	ldd	r31, Y+4	; 0x04
    340e:	82 e1       	ldi	r24, 0x12	; 18
    3410:	80 83       	st	Z, r24
	pxTopOfStack--;
    3412:	8b 81       	ldd	r24, Y+3	; 0x03
    3414:	9c 81       	ldd	r25, Y+4	; 0x04
    3416:	01 97       	sbiw	r24, 0x01	; 1
    3418:	9c 83       	std	Y+4, r25	; 0x04
    341a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    341c:	eb 81       	ldd	r30, Y+3	; 0x03
    341e:	fc 81       	ldd	r31, Y+4	; 0x04
    3420:	83 e1       	ldi	r24, 0x13	; 19
    3422:	80 83       	st	Z, r24
	pxTopOfStack--;
    3424:	8b 81       	ldd	r24, Y+3	; 0x03
    3426:	9c 81       	ldd	r25, Y+4	; 0x04
    3428:	01 97       	sbiw	r24, 0x01	; 1
    342a:	9c 83       	std	Y+4, r25	; 0x04
    342c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    342e:	eb 81       	ldd	r30, Y+3	; 0x03
    3430:	fc 81       	ldd	r31, Y+4	; 0x04
    3432:	84 e1       	ldi	r24, 0x14	; 20
    3434:	80 83       	st	Z, r24
	pxTopOfStack--;
    3436:	8b 81       	ldd	r24, Y+3	; 0x03
    3438:	9c 81       	ldd	r25, Y+4	; 0x04
    343a:	01 97       	sbiw	r24, 0x01	; 1
    343c:	9c 83       	std	Y+4, r25	; 0x04
    343e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3440:	eb 81       	ldd	r30, Y+3	; 0x03
    3442:	fc 81       	ldd	r31, Y+4	; 0x04
    3444:	85 e1       	ldi	r24, 0x15	; 21
    3446:	80 83       	st	Z, r24
	pxTopOfStack--;
    3448:	8b 81       	ldd	r24, Y+3	; 0x03
    344a:	9c 81       	ldd	r25, Y+4	; 0x04
    344c:	01 97       	sbiw	r24, 0x01	; 1
    344e:	9c 83       	std	Y+4, r25	; 0x04
    3450:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3452:	eb 81       	ldd	r30, Y+3	; 0x03
    3454:	fc 81       	ldd	r31, Y+4	; 0x04
    3456:	86 e1       	ldi	r24, 0x16	; 22
    3458:	80 83       	st	Z, r24
	pxTopOfStack--;
    345a:	8b 81       	ldd	r24, Y+3	; 0x03
    345c:	9c 81       	ldd	r25, Y+4	; 0x04
    345e:	01 97       	sbiw	r24, 0x01	; 1
    3460:	9c 83       	std	Y+4, r25	; 0x04
    3462:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    3464:	eb 81       	ldd	r30, Y+3	; 0x03
    3466:	fc 81       	ldd	r31, Y+4	; 0x04
    3468:	87 e1       	ldi	r24, 0x17	; 23
    346a:	80 83       	st	Z, r24
	pxTopOfStack--;
    346c:	8b 81       	ldd	r24, Y+3	; 0x03
    346e:	9c 81       	ldd	r25, Y+4	; 0x04
    3470:	01 97       	sbiw	r24, 0x01	; 1
    3472:	9c 83       	std	Y+4, r25	; 0x04
    3474:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    3476:	eb 81       	ldd	r30, Y+3	; 0x03
    3478:	fc 81       	ldd	r31, Y+4	; 0x04
    347a:	88 e1       	ldi	r24, 0x18	; 24
    347c:	80 83       	st	Z, r24
	pxTopOfStack--;
    347e:	8b 81       	ldd	r24, Y+3	; 0x03
    3480:	9c 81       	ldd	r25, Y+4	; 0x04
    3482:	01 97       	sbiw	r24, 0x01	; 1
    3484:	9c 83       	std	Y+4, r25	; 0x04
    3486:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    3488:	eb 81       	ldd	r30, Y+3	; 0x03
    348a:	fc 81       	ldd	r31, Y+4	; 0x04
    348c:	89 e1       	ldi	r24, 0x19	; 25
    348e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3490:	8b 81       	ldd	r24, Y+3	; 0x03
    3492:	9c 81       	ldd	r25, Y+4	; 0x04
    3494:	01 97       	sbiw	r24, 0x01	; 1
    3496:	9c 83       	std	Y+4, r25	; 0x04
    3498:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    349a:	eb 81       	ldd	r30, Y+3	; 0x03
    349c:	fc 81       	ldd	r31, Y+4	; 0x04
    349e:	80 e2       	ldi	r24, 0x20	; 32
    34a0:	80 83       	st	Z, r24
	pxTopOfStack--;
    34a2:	8b 81       	ldd	r24, Y+3	; 0x03
    34a4:	9c 81       	ldd	r25, Y+4	; 0x04
    34a6:	01 97       	sbiw	r24, 0x01	; 1
    34a8:	9c 83       	std	Y+4, r25	; 0x04
    34aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    34ac:	eb 81       	ldd	r30, Y+3	; 0x03
    34ae:	fc 81       	ldd	r31, Y+4	; 0x04
    34b0:	81 e2       	ldi	r24, 0x21	; 33
    34b2:	80 83       	st	Z, r24
	pxTopOfStack--;
    34b4:	8b 81       	ldd	r24, Y+3	; 0x03
    34b6:	9c 81       	ldd	r25, Y+4	; 0x04
    34b8:	01 97       	sbiw	r24, 0x01	; 1
    34ba:	9c 83       	std	Y+4, r25	; 0x04
    34bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    34be:	eb 81       	ldd	r30, Y+3	; 0x03
    34c0:	fc 81       	ldd	r31, Y+4	; 0x04
    34c2:	82 e2       	ldi	r24, 0x22	; 34
    34c4:	80 83       	st	Z, r24
	pxTopOfStack--;
    34c6:	8b 81       	ldd	r24, Y+3	; 0x03
    34c8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ca:	01 97       	sbiw	r24, 0x01	; 1
    34cc:	9c 83       	std	Y+4, r25	; 0x04
    34ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    34d0:	eb 81       	ldd	r30, Y+3	; 0x03
    34d2:	fc 81       	ldd	r31, Y+4	; 0x04
    34d4:	83 e2       	ldi	r24, 0x23	; 35
    34d6:	80 83       	st	Z, r24
	pxTopOfStack--;
    34d8:	8b 81       	ldd	r24, Y+3	; 0x03
    34da:	9c 81       	ldd	r25, Y+4	; 0x04
    34dc:	01 97       	sbiw	r24, 0x01	; 1
    34de:	9c 83       	std	Y+4, r25	; 0x04
    34e0:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    34e2:	8f 81       	ldd	r24, Y+7	; 0x07
    34e4:	98 85       	ldd	r25, Y+8	; 0x08
    34e6:	9a 83       	std	Y+2, r25	; 0x02
    34e8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    34ea:	89 81       	ldd	r24, Y+1	; 0x01
    34ec:	eb 81       	ldd	r30, Y+3	; 0x03
    34ee:	fc 81       	ldd	r31, Y+4	; 0x04
    34f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    34f2:	8b 81       	ldd	r24, Y+3	; 0x03
    34f4:	9c 81       	ldd	r25, Y+4	; 0x04
    34f6:	01 97       	sbiw	r24, 0x01	; 1
    34f8:	9c 83       	std	Y+4, r25	; 0x04
    34fa:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    34fc:	89 81       	ldd	r24, Y+1	; 0x01
    34fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3500:	89 2f       	mov	r24, r25
    3502:	99 27       	eor	r25, r25
    3504:	9a 83       	std	Y+2, r25	; 0x02
    3506:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3508:	89 81       	ldd	r24, Y+1	; 0x01
    350a:	eb 81       	ldd	r30, Y+3	; 0x03
    350c:	fc 81       	ldd	r31, Y+4	; 0x04
    350e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3510:	8b 81       	ldd	r24, Y+3	; 0x03
    3512:	9c 81       	ldd	r25, Y+4	; 0x04
    3514:	01 97       	sbiw	r24, 0x01	; 1
    3516:	9c 83       	std	Y+4, r25	; 0x04
    3518:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    351a:	eb 81       	ldd	r30, Y+3	; 0x03
    351c:	fc 81       	ldd	r31, Y+4	; 0x04
    351e:	86 e2       	ldi	r24, 0x26	; 38
    3520:	80 83       	st	Z, r24
	pxTopOfStack--;
    3522:	8b 81       	ldd	r24, Y+3	; 0x03
    3524:	9c 81       	ldd	r25, Y+4	; 0x04
    3526:	01 97       	sbiw	r24, 0x01	; 1
    3528:	9c 83       	std	Y+4, r25	; 0x04
    352a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    352c:	eb 81       	ldd	r30, Y+3	; 0x03
    352e:	fc 81       	ldd	r31, Y+4	; 0x04
    3530:	87 e2       	ldi	r24, 0x27	; 39
    3532:	80 83       	st	Z, r24
	pxTopOfStack--;
    3534:	8b 81       	ldd	r24, Y+3	; 0x03
    3536:	9c 81       	ldd	r25, Y+4	; 0x04
    3538:	01 97       	sbiw	r24, 0x01	; 1
    353a:	9c 83       	std	Y+4, r25	; 0x04
    353c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    353e:	eb 81       	ldd	r30, Y+3	; 0x03
    3540:	fc 81       	ldd	r31, Y+4	; 0x04
    3542:	88 e2       	ldi	r24, 0x28	; 40
    3544:	80 83       	st	Z, r24
	pxTopOfStack--;
    3546:	8b 81       	ldd	r24, Y+3	; 0x03
    3548:	9c 81       	ldd	r25, Y+4	; 0x04
    354a:	01 97       	sbiw	r24, 0x01	; 1
    354c:	9c 83       	std	Y+4, r25	; 0x04
    354e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    3550:	eb 81       	ldd	r30, Y+3	; 0x03
    3552:	fc 81       	ldd	r31, Y+4	; 0x04
    3554:	89 e2       	ldi	r24, 0x29	; 41
    3556:	80 83       	st	Z, r24
	pxTopOfStack--;
    3558:	8b 81       	ldd	r24, Y+3	; 0x03
    355a:	9c 81       	ldd	r25, Y+4	; 0x04
    355c:	01 97       	sbiw	r24, 0x01	; 1
    355e:	9c 83       	std	Y+4, r25	; 0x04
    3560:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3562:	eb 81       	ldd	r30, Y+3	; 0x03
    3564:	fc 81       	ldd	r31, Y+4	; 0x04
    3566:	80 e3       	ldi	r24, 0x30	; 48
    3568:	80 83       	st	Z, r24
	pxTopOfStack--;
    356a:	8b 81       	ldd	r24, Y+3	; 0x03
    356c:	9c 81       	ldd	r25, Y+4	; 0x04
    356e:	01 97       	sbiw	r24, 0x01	; 1
    3570:	9c 83       	std	Y+4, r25	; 0x04
    3572:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    3574:	eb 81       	ldd	r30, Y+3	; 0x03
    3576:	fc 81       	ldd	r31, Y+4	; 0x04
    3578:	81 e3       	ldi	r24, 0x31	; 49
    357a:	80 83       	st	Z, r24
	pxTopOfStack--;
    357c:	8b 81       	ldd	r24, Y+3	; 0x03
    357e:	9c 81       	ldd	r25, Y+4	; 0x04
    3580:	01 97       	sbiw	r24, 0x01	; 1
    3582:	9c 83       	std	Y+4, r25	; 0x04
    3584:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3586:	8b 81       	ldd	r24, Y+3	; 0x03
    3588:	9c 81       	ldd	r25, Y+4	; 0x04
}
    358a:	28 96       	adiw	r28, 0x08	; 8
    358c:	0f b6       	in	r0, 0x3f	; 63
    358e:	f8 94       	cli
    3590:	de bf       	out	0x3e, r29	; 62
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	cd bf       	out	0x3d, r28	; 61
    3596:	cf 91       	pop	r28
    3598:	df 91       	pop	r29
    359a:	08 95       	ret

0000359c <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    359c:	df 93       	push	r29
    359e:	cf 93       	push	r28
    35a0:	cd b7       	in	r28, 0x3d	; 61
    35a2:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    35a4:	0e 94 be 1b 	call	0x377c	; 0x377c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    35a8:	a0 91 ad 04 	lds	r26, 0x04AD
    35ac:	b0 91 ae 04 	lds	r27, 0x04AE
    35b0:	cd 91       	ld	r28, X+
    35b2:	cd bf       	out	0x3d, r28	; 61
    35b4:	dd 91       	ld	r29, X+
    35b6:	de bf       	out	0x3e, r29	; 62
    35b8:	ff 91       	pop	r31
    35ba:	ef 91       	pop	r30
    35bc:	df 91       	pop	r29
    35be:	cf 91       	pop	r28
    35c0:	bf 91       	pop	r27
    35c2:	af 91       	pop	r26
    35c4:	9f 91       	pop	r25
    35c6:	8f 91       	pop	r24
    35c8:	7f 91       	pop	r23
    35ca:	6f 91       	pop	r22
    35cc:	5f 91       	pop	r21
    35ce:	4f 91       	pop	r20
    35d0:	3f 91       	pop	r19
    35d2:	2f 91       	pop	r18
    35d4:	1f 91       	pop	r17
    35d6:	0f 91       	pop	r16
    35d8:	ff 90       	pop	r15
    35da:	ef 90       	pop	r14
    35dc:	df 90       	pop	r13
    35de:	cf 90       	pop	r12
    35e0:	bf 90       	pop	r11
    35e2:	af 90       	pop	r10
    35e4:	9f 90       	pop	r9
    35e6:	8f 90       	pop	r8
    35e8:	7f 90       	pop	r7
    35ea:	6f 90       	pop	r6
    35ec:	5f 90       	pop	r5
    35ee:	4f 90       	pop	r4
    35f0:	3f 90       	pop	r3
    35f2:	2f 90       	pop	r2
    35f4:	1f 90       	pop	r1
    35f6:	0f 90       	pop	r0
    35f8:	0f be       	out	0x3f, r0	; 63
    35fa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    35fc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    35fe:	81 e0       	ldi	r24, 0x01	; 1
}
    3600:	cf 91       	pop	r28
    3602:	df 91       	pop	r29
    3604:	08 95       	ret

00003606 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3606:	df 93       	push	r29
    3608:	cf 93       	push	r28
    360a:	cd b7       	in	r28, 0x3d	; 61
    360c:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    360e:	cf 91       	pop	r28
    3610:	df 91       	pop	r29
    3612:	08 95       	ret

00003614 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3614:	0f 92       	push	r0
    3616:	0f b6       	in	r0, 0x3f	; 63
    3618:	f8 94       	cli
    361a:	0f 92       	push	r0
    361c:	1f 92       	push	r1
    361e:	11 24       	eor	r1, r1
    3620:	2f 92       	push	r2
    3622:	3f 92       	push	r3
    3624:	4f 92       	push	r4
    3626:	5f 92       	push	r5
    3628:	6f 92       	push	r6
    362a:	7f 92       	push	r7
    362c:	8f 92       	push	r8
    362e:	9f 92       	push	r9
    3630:	af 92       	push	r10
    3632:	bf 92       	push	r11
    3634:	cf 92       	push	r12
    3636:	df 92       	push	r13
    3638:	ef 92       	push	r14
    363a:	ff 92       	push	r15
    363c:	0f 93       	push	r16
    363e:	1f 93       	push	r17
    3640:	2f 93       	push	r18
    3642:	3f 93       	push	r19
    3644:	4f 93       	push	r20
    3646:	5f 93       	push	r21
    3648:	6f 93       	push	r22
    364a:	7f 93       	push	r23
    364c:	8f 93       	push	r24
    364e:	9f 93       	push	r25
    3650:	af 93       	push	r26
    3652:	bf 93       	push	r27
    3654:	cf 93       	push	r28
    3656:	df 93       	push	r29
    3658:	ef 93       	push	r30
    365a:	ff 93       	push	r31
    365c:	a0 91 ad 04 	lds	r26, 0x04AD
    3660:	b0 91 ae 04 	lds	r27, 0x04AE
    3664:	0d b6       	in	r0, 0x3d	; 61
    3666:	0d 92       	st	X+, r0
    3668:	0e b6       	in	r0, 0x3e	; 62
    366a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    366c:	0e 94 7a 24 	call	0x48f4	; 0x48f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3670:	a0 91 ad 04 	lds	r26, 0x04AD
    3674:	b0 91 ae 04 	lds	r27, 0x04AE
    3678:	cd 91       	ld	r28, X+
    367a:	cd bf       	out	0x3d, r28	; 61
    367c:	dd 91       	ld	r29, X+
    367e:	de bf       	out	0x3e, r29	; 62
    3680:	ff 91       	pop	r31
    3682:	ef 91       	pop	r30
    3684:	df 91       	pop	r29
    3686:	cf 91       	pop	r28
    3688:	bf 91       	pop	r27
    368a:	af 91       	pop	r26
    368c:	9f 91       	pop	r25
    368e:	8f 91       	pop	r24
    3690:	7f 91       	pop	r23
    3692:	6f 91       	pop	r22
    3694:	5f 91       	pop	r21
    3696:	4f 91       	pop	r20
    3698:	3f 91       	pop	r19
    369a:	2f 91       	pop	r18
    369c:	1f 91       	pop	r17
    369e:	0f 91       	pop	r16
    36a0:	ff 90       	pop	r15
    36a2:	ef 90       	pop	r14
    36a4:	df 90       	pop	r13
    36a6:	cf 90       	pop	r12
    36a8:	bf 90       	pop	r11
    36aa:	af 90       	pop	r10
    36ac:	9f 90       	pop	r9
    36ae:	8f 90       	pop	r8
    36b0:	7f 90       	pop	r7
    36b2:	6f 90       	pop	r6
    36b4:	5f 90       	pop	r5
    36b6:	4f 90       	pop	r4
    36b8:	3f 90       	pop	r3
    36ba:	2f 90       	pop	r2
    36bc:	1f 90       	pop	r1
    36be:	0f 90       	pop	r0
    36c0:	0f be       	out	0x3f, r0	; 63
    36c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    36c4:	08 95       	ret

000036c6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    36c6:	0f 92       	push	r0
    36c8:	0f b6       	in	r0, 0x3f	; 63
    36ca:	f8 94       	cli
    36cc:	0f 92       	push	r0
    36ce:	1f 92       	push	r1
    36d0:	11 24       	eor	r1, r1
    36d2:	2f 92       	push	r2
    36d4:	3f 92       	push	r3
    36d6:	4f 92       	push	r4
    36d8:	5f 92       	push	r5
    36da:	6f 92       	push	r6
    36dc:	7f 92       	push	r7
    36de:	8f 92       	push	r8
    36e0:	9f 92       	push	r9
    36e2:	af 92       	push	r10
    36e4:	bf 92       	push	r11
    36e6:	cf 92       	push	r12
    36e8:	df 92       	push	r13
    36ea:	ef 92       	push	r14
    36ec:	ff 92       	push	r15
    36ee:	0f 93       	push	r16
    36f0:	1f 93       	push	r17
    36f2:	2f 93       	push	r18
    36f4:	3f 93       	push	r19
    36f6:	4f 93       	push	r20
    36f8:	5f 93       	push	r21
    36fa:	6f 93       	push	r22
    36fc:	7f 93       	push	r23
    36fe:	8f 93       	push	r24
    3700:	9f 93       	push	r25
    3702:	af 93       	push	r26
    3704:	bf 93       	push	r27
    3706:	cf 93       	push	r28
    3708:	df 93       	push	r29
    370a:	ef 93       	push	r30
    370c:	ff 93       	push	r31
    370e:	a0 91 ad 04 	lds	r26, 0x04AD
    3712:	b0 91 ae 04 	lds	r27, 0x04AE
    3716:	0d b6       	in	r0, 0x3d	; 61
    3718:	0d 92       	st	X+, r0
    371a:	0e b6       	in	r0, 0x3e	; 62
    371c:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    371e:	0e 94 a5 23 	call	0x474a	; 0x474a <vTaskIncrementTick>
	vTaskSwitchContext();
    3722:	0e 94 7a 24 	call	0x48f4	; 0x48f4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3726:	a0 91 ad 04 	lds	r26, 0x04AD
    372a:	b0 91 ae 04 	lds	r27, 0x04AE
    372e:	cd 91       	ld	r28, X+
    3730:	cd bf       	out	0x3d, r28	; 61
    3732:	dd 91       	ld	r29, X+
    3734:	de bf       	out	0x3e, r29	; 62
    3736:	ff 91       	pop	r31
    3738:	ef 91       	pop	r30
    373a:	df 91       	pop	r29
    373c:	cf 91       	pop	r28
    373e:	bf 91       	pop	r27
    3740:	af 91       	pop	r26
    3742:	9f 91       	pop	r25
    3744:	8f 91       	pop	r24
    3746:	7f 91       	pop	r23
    3748:	6f 91       	pop	r22
    374a:	5f 91       	pop	r21
    374c:	4f 91       	pop	r20
    374e:	3f 91       	pop	r19
    3750:	2f 91       	pop	r18
    3752:	1f 91       	pop	r17
    3754:	0f 91       	pop	r16
    3756:	ff 90       	pop	r15
    3758:	ef 90       	pop	r14
    375a:	df 90       	pop	r13
    375c:	cf 90       	pop	r12
    375e:	bf 90       	pop	r11
    3760:	af 90       	pop	r10
    3762:	9f 90       	pop	r9
    3764:	8f 90       	pop	r8
    3766:	7f 90       	pop	r7
    3768:	6f 90       	pop	r6
    376a:	5f 90       	pop	r5
    376c:	4f 90       	pop	r4
    376e:	3f 90       	pop	r3
    3770:	2f 90       	pop	r2
    3772:	1f 90       	pop	r1
    3774:	0f 90       	pop	r0
    3776:	0f be       	out	0x3f, r0	; 63
    3778:	0f 90       	pop	r0

	asm volatile ( "ret" );
    377a:	08 95       	ret

0000377c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    377c:	df 93       	push	r29
    377e:	cf 93       	push	r28
    3780:	00 d0       	rcall	.+0      	; 0x3782 <prvSetupTimerInterrupt+0x6>
    3782:	00 d0       	rcall	.+0      	; 0x3784 <prvSetupTimerInterrupt+0x8>
    3784:	00 d0       	rcall	.+0      	; 0x3786 <prvSetupTimerInterrupt+0xa>
    3786:	cd b7       	in	r28, 0x3d	; 61
    3788:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    378a:	80 e8       	ldi	r24, 0x80	; 128
    378c:	98 e3       	ldi	r25, 0x38	; 56
    378e:	a1 e0       	ldi	r26, 0x01	; 1
    3790:	b0 e0       	ldi	r27, 0x00	; 0
    3792:	8b 83       	std	Y+3, r24	; 0x03
    3794:	9c 83       	std	Y+4, r25	; 0x04
    3796:	ad 83       	std	Y+5, r26	; 0x05
    3798:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    379a:	8b 81       	ldd	r24, Y+3	; 0x03
    379c:	9c 81       	ldd	r25, Y+4	; 0x04
    379e:	ad 81       	ldd	r26, Y+5	; 0x05
    37a0:	be 81       	ldd	r27, Y+6	; 0x06
    37a2:	68 94       	set
    37a4:	15 f8       	bld	r1, 5
    37a6:	b6 95       	lsr	r27
    37a8:	a7 95       	ror	r26
    37aa:	97 95       	ror	r25
    37ac:	87 95       	ror	r24
    37ae:	16 94       	lsr	r1
    37b0:	d1 f7       	brne	.-12     	; 0x37a6 <prvSetupTimerInterrupt+0x2a>
    37b2:	8b 83       	std	Y+3, r24	; 0x03
    37b4:	9c 83       	std	Y+4, r25	; 0x04
    37b6:	ad 83       	std	Y+5, r26	; 0x05
    37b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    37ba:	8b 81       	ldd	r24, Y+3	; 0x03
    37bc:	9c 81       	ldd	r25, Y+4	; 0x04
    37be:	ad 81       	ldd	r26, Y+5	; 0x05
    37c0:	be 81       	ldd	r27, Y+6	; 0x06
    37c2:	01 97       	sbiw	r24, 0x01	; 1
    37c4:	a1 09       	sbc	r26, r1
    37c6:	b1 09       	sbc	r27, r1
    37c8:	8b 83       	std	Y+3, r24	; 0x03
    37ca:	9c 83       	std	Y+4, r25	; 0x04
    37cc:	ad 83       	std	Y+5, r26	; 0x05
    37ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    37d0:	8b 81       	ldd	r24, Y+3	; 0x03
    37d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    37d4:	8b 81       	ldd	r24, Y+3	; 0x03
    37d6:	9c 81       	ldd	r25, Y+4	; 0x04
    37d8:	ad 81       	ldd	r26, Y+5	; 0x05
    37da:	be 81       	ldd	r27, Y+6	; 0x06
    37dc:	89 2f       	mov	r24, r25
    37de:	9a 2f       	mov	r25, r26
    37e0:	ab 2f       	mov	r26, r27
    37e2:	bb 27       	eor	r27, r27
    37e4:	8b 83       	std	Y+3, r24	; 0x03
    37e6:	9c 83       	std	Y+4, r25	; 0x04
    37e8:	ad 83       	std	Y+5, r26	; 0x05
    37ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    37ec:	8b 81       	ldd	r24, Y+3	; 0x03
    37ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    37f0:	eb e4       	ldi	r30, 0x4B	; 75
    37f2:	f0 e0       	ldi	r31, 0x00	; 0
    37f4:	8a 81       	ldd	r24, Y+2	; 0x02
    37f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    37f8:	ea e4       	ldi	r30, 0x4A	; 74
    37fa:	f0 e0       	ldi	r31, 0x00	; 0
    37fc:	89 81       	ldd	r24, Y+1	; 0x01
    37fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3800:	8b e0       	ldi	r24, 0x0B	; 11
    3802:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3804:	ee e4       	ldi	r30, 0x4E	; 78
    3806:	f0 e0       	ldi	r31, 0x00	; 0
    3808:	89 81       	ldd	r24, Y+1	; 0x01
    380a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    380c:	e9 e5       	ldi	r30, 0x59	; 89
    380e:	f0 e0       	ldi	r31, 0x00	; 0
    3810:	80 81       	ld	r24, Z
    3812:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3814:	89 81       	ldd	r24, Y+1	; 0x01
    3816:	80 61       	ori	r24, 0x10	; 16
    3818:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    381a:	e9 e5       	ldi	r30, 0x59	; 89
    381c:	f0 e0       	ldi	r31, 0x00	; 0
    381e:	89 81       	ldd	r24, Y+1	; 0x01
    3820:	80 83       	st	Z, r24
}
    3822:	26 96       	adiw	r28, 0x06	; 6
    3824:	0f b6       	in	r0, 0x3f	; 63
    3826:	f8 94       	cli
    3828:	de bf       	out	0x3e, r29	; 62
    382a:	0f be       	out	0x3f, r0	; 63
    382c:	cd bf       	out	0x3d, r28	; 61
    382e:	cf 91       	pop	r28
    3830:	df 91       	pop	r29
    3832:	08 95       	ret

00003834 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3834:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <vPortYieldFromTick>
		asm volatile ( "reti" );
    3838:	18 95       	reti

0000383a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    383a:	df 93       	push	r29
    383c:	cf 93       	push	r28
    383e:	cd b7       	in	r28, 0x3d	; 61
    3840:	de b7       	in	r29, 0x3e	; 62
    3842:	28 97       	sbiw	r28, 0x08	; 8
    3844:	0f b6       	in	r0, 0x3f	; 63
    3846:	f8 94       	cli
    3848:	de bf       	out	0x3e, r29	; 62
    384a:	0f be       	out	0x3f, r0	; 63
    384c:	cd bf       	out	0x3d, r28	; 61
    384e:	8f 83       	std	Y+7, r24	; 0x07
    3850:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    3852:	1a 82       	std	Y+2, r1	; 0x02
    3854:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3856:	8f 81       	ldd	r24, Y+7	; 0x07
    3858:	88 23       	and	r24, r24
    385a:	09 f4       	brne	.+2      	; 0x385e <xQueueCreate+0x24>
    385c:	8c c0       	rjmp	.+280    	; 0x3976 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    385e:	8f e1       	ldi	r24, 0x1F	; 31
    3860:	90 e0       	ldi	r25, 0x00	; 0
    3862:	0e 94 94 16 	call	0x2d28	; 0x2d28 <pvPortMalloc>
    3866:	9e 83       	std	Y+6, r25	; 0x06
    3868:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    386a:	8d 81       	ldd	r24, Y+5	; 0x05
    386c:	9e 81       	ldd	r25, Y+6	; 0x06
    386e:	00 97       	sbiw	r24, 0x00	; 0
    3870:	09 f4       	brne	.+2      	; 0x3874 <xQueueCreate+0x3a>
    3872:	81 c0       	rjmp	.+258    	; 0x3976 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3874:	8f 81       	ldd	r24, Y+7	; 0x07
    3876:	28 2f       	mov	r18, r24
    3878:	30 e0       	ldi	r19, 0x00	; 0
    387a:	88 85       	ldd	r24, Y+8	; 0x08
    387c:	88 2f       	mov	r24, r24
    387e:	90 e0       	ldi	r25, 0x00	; 0
    3880:	ac 01       	movw	r20, r24
    3882:	24 9f       	mul	r18, r20
    3884:	c0 01       	movw	r24, r0
    3886:	25 9f       	mul	r18, r21
    3888:	90 0d       	add	r25, r0
    388a:	34 9f       	mul	r19, r20
    388c:	90 0d       	add	r25, r0
    388e:	11 24       	eor	r1, r1
    3890:	01 96       	adiw	r24, 0x01	; 1
    3892:	9c 83       	std	Y+4, r25	; 0x04
    3894:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3896:	8b 81       	ldd	r24, Y+3	; 0x03
    3898:	9c 81       	ldd	r25, Y+4	; 0x04
    389a:	0e 94 94 16 	call	0x2d28	; 0x2d28 <pvPortMalloc>
    389e:	ed 81       	ldd	r30, Y+5	; 0x05
    38a0:	fe 81       	ldd	r31, Y+6	; 0x06
    38a2:	91 83       	std	Z+1, r25	; 0x01
    38a4:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    38a6:	ed 81       	ldd	r30, Y+5	; 0x05
    38a8:	fe 81       	ldd	r31, Y+6	; 0x06
    38aa:	80 81       	ld	r24, Z
    38ac:	91 81       	ldd	r25, Z+1	; 0x01
    38ae:	00 97       	sbiw	r24, 0x00	; 0
    38b0:	09 f4       	brne	.+2      	; 0x38b4 <xQueueCreate+0x7a>
    38b2:	5d c0       	rjmp	.+186    	; 0x396e <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    38b4:	ed 81       	ldd	r30, Y+5	; 0x05
    38b6:	fe 81       	ldd	r31, Y+6	; 0x06
    38b8:	40 81       	ld	r20, Z
    38ba:	51 81       	ldd	r21, Z+1	; 0x01
    38bc:	8f 81       	ldd	r24, Y+7	; 0x07
    38be:	28 2f       	mov	r18, r24
    38c0:	30 e0       	ldi	r19, 0x00	; 0
    38c2:	88 85       	ldd	r24, Y+8	; 0x08
    38c4:	88 2f       	mov	r24, r24
    38c6:	90 e0       	ldi	r25, 0x00	; 0
    38c8:	bc 01       	movw	r22, r24
    38ca:	26 9f       	mul	r18, r22
    38cc:	c0 01       	movw	r24, r0
    38ce:	27 9f       	mul	r18, r23
    38d0:	90 0d       	add	r25, r0
    38d2:	36 9f       	mul	r19, r22
    38d4:	90 0d       	add	r25, r0
    38d6:	11 24       	eor	r1, r1
    38d8:	84 0f       	add	r24, r20
    38da:	95 1f       	adc	r25, r21
    38dc:	ed 81       	ldd	r30, Y+5	; 0x05
    38de:	fe 81       	ldd	r31, Y+6	; 0x06
    38e0:	93 83       	std	Z+3, r25	; 0x03
    38e2:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    38e4:	ed 81       	ldd	r30, Y+5	; 0x05
    38e6:	fe 81       	ldd	r31, Y+6	; 0x06
    38e8:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    38ea:	ed 81       	ldd	r30, Y+5	; 0x05
    38ec:	fe 81       	ldd	r31, Y+6	; 0x06
    38ee:	80 81       	ld	r24, Z
    38f0:	91 81       	ldd	r25, Z+1	; 0x01
    38f2:	ed 81       	ldd	r30, Y+5	; 0x05
    38f4:	fe 81       	ldd	r31, Y+6	; 0x06
    38f6:	95 83       	std	Z+5, r25	; 0x05
    38f8:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    38fa:	ed 81       	ldd	r30, Y+5	; 0x05
    38fc:	fe 81       	ldd	r31, Y+6	; 0x06
    38fe:	40 81       	ld	r20, Z
    3900:	51 81       	ldd	r21, Z+1	; 0x01
    3902:	8f 81       	ldd	r24, Y+7	; 0x07
    3904:	88 2f       	mov	r24, r24
    3906:	90 e0       	ldi	r25, 0x00	; 0
    3908:	9c 01       	movw	r18, r24
    390a:	21 50       	subi	r18, 0x01	; 1
    390c:	30 40       	sbci	r19, 0x00	; 0
    390e:	88 85       	ldd	r24, Y+8	; 0x08
    3910:	88 2f       	mov	r24, r24
    3912:	90 e0       	ldi	r25, 0x00	; 0
    3914:	bc 01       	movw	r22, r24
    3916:	26 9f       	mul	r18, r22
    3918:	c0 01       	movw	r24, r0
    391a:	27 9f       	mul	r18, r23
    391c:	90 0d       	add	r25, r0
    391e:	36 9f       	mul	r19, r22
    3920:	90 0d       	add	r25, r0
    3922:	11 24       	eor	r1, r1
    3924:	84 0f       	add	r24, r20
    3926:	95 1f       	adc	r25, r21
    3928:	ed 81       	ldd	r30, Y+5	; 0x05
    392a:	fe 81       	ldd	r31, Y+6	; 0x06
    392c:	97 83       	std	Z+7, r25	; 0x07
    392e:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    3930:	ed 81       	ldd	r30, Y+5	; 0x05
    3932:	fe 81       	ldd	r31, Y+6	; 0x06
    3934:	8f 81       	ldd	r24, Y+7	; 0x07
    3936:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3938:	ed 81       	ldd	r30, Y+5	; 0x05
    393a:	fe 81       	ldd	r31, Y+6	; 0x06
    393c:	88 85       	ldd	r24, Y+8	; 0x08
    393e:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    3940:	ed 81       	ldd	r30, Y+5	; 0x05
    3942:	fe 81       	ldd	r31, Y+6	; 0x06
    3944:	8f ef       	ldi	r24, 0xFF	; 255
    3946:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3948:	ed 81       	ldd	r30, Y+5	; 0x05
    394a:	fe 81       	ldd	r31, Y+6	; 0x06
    394c:	8f ef       	ldi	r24, 0xFF	; 255
    394e:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3950:	8d 81       	ldd	r24, Y+5	; 0x05
    3952:	9e 81       	ldd	r25, Y+6	; 0x06
    3954:	08 96       	adiw	r24, 0x08	; 8
    3956:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    395a:	8d 81       	ldd	r24, Y+5	; 0x05
    395c:	9e 81       	ldd	r25, Y+6	; 0x06
    395e:	41 96       	adiw	r24, 0x11	; 17
    3960:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3964:	8d 81       	ldd	r24, Y+5	; 0x05
    3966:	9e 81       	ldd	r25, Y+6	; 0x06
    3968:	9a 83       	std	Y+2, r25	; 0x02
    396a:	89 83       	std	Y+1, r24	; 0x01
    396c:	04 c0       	rjmp	.+8      	; 0x3976 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    396e:	8d 81       	ldd	r24, Y+5	; 0x05
    3970:	9e 81       	ldd	r25, Y+6	; 0x06
    3972:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3976:	89 81       	ldd	r24, Y+1	; 0x01
    3978:	9a 81       	ldd	r25, Y+2	; 0x02
}
    397a:	28 96       	adiw	r28, 0x08	; 8
    397c:	0f b6       	in	r0, 0x3f	; 63
    397e:	f8 94       	cli
    3980:	de bf       	out	0x3e, r29	; 62
    3982:	0f be       	out	0x3f, r0	; 63
    3984:	cd bf       	out	0x3d, r28	; 61
    3986:	cf 91       	pop	r28
    3988:	df 91       	pop	r29
    398a:	08 95       	ret

0000398c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    398c:	df 93       	push	r29
    398e:	cf 93       	push	r28
    3990:	cd b7       	in	r28, 0x3d	; 61
    3992:	de b7       	in	r29, 0x3e	; 62
    3994:	2c 97       	sbiw	r28, 0x0c	; 12
    3996:	0f b6       	in	r0, 0x3f	; 63
    3998:	f8 94       	cli
    399a:	de bf       	out	0x3e, r29	; 62
    399c:	0f be       	out	0x3f, r0	; 63
    399e:	cd bf       	out	0x3d, r28	; 61
    39a0:	9e 83       	std	Y+6, r25	; 0x06
    39a2:	8d 83       	std	Y+5, r24	; 0x05
    39a4:	78 87       	std	Y+8, r23	; 0x08
    39a6:	6f 83       	std	Y+7, r22	; 0x07
    39a8:	5a 87       	std	Y+10, r21	; 0x0a
    39aa:	49 87       	std	Y+9, r20	; 0x09
    39ac:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    39ae:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    39b0:	0f b6       	in	r0, 0x3f	; 63
    39b2:	f8 94       	cli
    39b4:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    39b6:	ed 81       	ldd	r30, Y+5	; 0x05
    39b8:	fe 81       	ldd	r31, Y+6	; 0x06
    39ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    39bc:	ed 81       	ldd	r30, Y+5	; 0x05
    39be:	fe 81       	ldd	r31, Y+6	; 0x06
    39c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    39c2:	98 17       	cp	r25, r24
    39c4:	d8 f4       	brcc	.+54     	; 0x39fc <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    39c6:	8d 81       	ldd	r24, Y+5	; 0x05
    39c8:	9e 81       	ldd	r25, Y+6	; 0x06
    39ca:	2f 81       	ldd	r18, Y+7	; 0x07
    39cc:	38 85       	ldd	r19, Y+8	; 0x08
    39ce:	b9 01       	movw	r22, r18
    39d0:	4b 85       	ldd	r20, Y+11	; 0x0b
    39d2:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    39d6:	ed 81       	ldd	r30, Y+5	; 0x05
    39d8:	fe 81       	ldd	r31, Y+6	; 0x06
    39da:	81 89       	ldd	r24, Z+17	; 0x11
    39dc:	88 23       	and	r24, r24
    39de:	49 f0       	breq	.+18     	; 0x39f2 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    39e0:	8d 81       	ldd	r24, Y+5	; 0x05
    39e2:	9e 81       	ldd	r25, Y+6	; 0x06
    39e4:	41 96       	adiw	r24, 0x11	; 17
    39e6:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskRemoveFromEventList>
    39ea:	81 30       	cpi	r24, 0x01	; 1
    39ec:	11 f4       	brne	.+4      	; 0x39f2 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    39ee:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    39f2:	0f 90       	pop	r0
    39f4:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    39f6:	81 e0       	ldi	r24, 0x01	; 1
    39f8:	8c 87       	std	Y+12, r24	; 0x0c
    39fa:	5c c0       	rjmp	.+184    	; 0x3ab4 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    39fc:	89 85       	ldd	r24, Y+9	; 0x09
    39fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a00:	00 97       	sbiw	r24, 0x00	; 0
    3a02:	21 f4       	brne	.+8      	; 0x3a0c <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3a04:	0f 90       	pop	r0
    3a06:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3a08:	1c 86       	std	Y+12, r1	; 0x0c
    3a0a:	54 c0       	rjmp	.+168    	; 0x3ab4 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3a0c:	89 81       	ldd	r24, Y+1	; 0x01
    3a0e:	88 23       	and	r24, r24
    3a10:	31 f4       	brne	.+12     	; 0x3a1e <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3a12:	ce 01       	movw	r24, r28
    3a14:	02 96       	adiw	r24, 0x02	; 2
    3a16:	0e 94 7e 25 	call	0x4afc	; 0x4afc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3a1a:	81 e0       	ldi	r24, 0x01	; 1
    3a1c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3a1e:	0f 90       	pop	r0
    3a20:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3a22:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3a26:	0f b6       	in	r0, 0x3f	; 63
    3a28:	f8 94       	cli
    3a2a:	0f 92       	push	r0
    3a2c:	ed 81       	ldd	r30, Y+5	; 0x05
    3a2e:	fe 81       	ldd	r31, Y+6	; 0x06
    3a30:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a32:	8f 3f       	cpi	r24, 0xFF	; 255
    3a34:	19 f4       	brne	.+6      	; 0x3a3c <xQueueGenericSend+0xb0>
    3a36:	ed 81       	ldd	r30, Y+5	; 0x05
    3a38:	fe 81       	ldd	r31, Y+6	; 0x06
    3a3a:	15 8e       	std	Z+29, r1	; 0x1d
    3a3c:	ed 81       	ldd	r30, Y+5	; 0x05
    3a3e:	fe 81       	ldd	r31, Y+6	; 0x06
    3a40:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a42:	8f 3f       	cpi	r24, 0xFF	; 255
    3a44:	19 f4       	brne	.+6      	; 0x3a4c <xQueueGenericSend+0xc0>
    3a46:	ed 81       	ldd	r30, Y+5	; 0x05
    3a48:	fe 81       	ldd	r31, Y+6	; 0x06
    3a4a:	16 8e       	std	Z+30, r1	; 0x1e
    3a4c:	0f 90       	pop	r0
    3a4e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3a50:	ce 01       	movw	r24, r28
    3a52:	02 96       	adiw	r24, 0x02	; 2
    3a54:	9e 01       	movw	r18, r28
    3a56:	27 5f       	subi	r18, 0xF7	; 247
    3a58:	3f 4f       	sbci	r19, 0xFF	; 255
    3a5a:	b9 01       	movw	r22, r18
    3a5c:	0e 94 97 25 	call	0x4b2e	; 0x4b2e <xTaskCheckForTimeOut>
    3a60:	88 23       	and	r24, r24
    3a62:	09 f5       	brne	.+66     	; 0x3aa6 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3a64:	8d 81       	ldd	r24, Y+5	; 0x05
    3a66:	9e 81       	ldd	r25, Y+6	; 0x06
    3a68:	0e 94 65 20 	call	0x40ca	; 0x40ca <prvIsQueueFull>
    3a6c:	88 23       	and	r24, r24
    3a6e:	a1 f0       	breq	.+40     	; 0x3a98 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3a70:	8d 81       	ldd	r24, Y+5	; 0x05
    3a72:	9e 81       	ldd	r25, Y+6	; 0x06
    3a74:	08 96       	adiw	r24, 0x08	; 8
    3a76:	29 85       	ldd	r18, Y+9	; 0x09
    3a78:	3a 85       	ldd	r19, Y+10	; 0x0a
    3a7a:	b9 01       	movw	r22, r18
    3a7c:	0e 94 e0 24 	call	0x49c0	; 0x49c0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3a80:	8d 81       	ldd	r24, Y+5	; 0x05
    3a82:	9e 81       	ldd	r25, Y+6	; 0x06
    3a84:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3a88:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
    3a8c:	88 23       	and	r24, r24
    3a8e:	09 f0       	breq	.+2      	; 0x3a92 <xQueueGenericSend+0x106>
    3a90:	8f cf       	rjmp	.-226    	; 0x39b0 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3a92:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
    3a96:	8c cf       	rjmp	.-232    	; 0x39b0 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3a98:	8d 81       	ldd	r24, Y+5	; 0x05
    3a9a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a9c:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3aa0:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
    3aa4:	85 cf       	rjmp	.-246    	; 0x39b0 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3aa6:	8d 81       	ldd	r24, Y+5	; 0x05
    3aa8:	9e 81       	ldd	r25, Y+6	; 0x06
    3aaa:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3aae:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3ab2:	1c 86       	std	Y+12, r1	; 0x0c
    3ab4:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3ab6:	2c 96       	adiw	r28, 0x0c	; 12
    3ab8:	0f b6       	in	r0, 0x3f	; 63
    3aba:	f8 94       	cli
    3abc:	de bf       	out	0x3e, r29	; 62
    3abe:	0f be       	out	0x3f, r0	; 63
    3ac0:	cd bf       	out	0x3d, r28	; 61
    3ac2:	cf 91       	pop	r28
    3ac4:	df 91       	pop	r29
    3ac6:	08 95       	ret

00003ac8 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3ac8:	df 93       	push	r29
    3aca:	cf 93       	push	r28
    3acc:	cd b7       	in	r28, 0x3d	; 61
    3ace:	de b7       	in	r29, 0x3e	; 62
    3ad0:	29 97       	sbiw	r28, 0x09	; 9
    3ad2:	0f b6       	in	r0, 0x3f	; 63
    3ad4:	f8 94       	cli
    3ad6:	de bf       	out	0x3e, r29	; 62
    3ad8:	0f be       	out	0x3f, r0	; 63
    3ada:	cd bf       	out	0x3d, r28	; 61
    3adc:	9c 83       	std	Y+4, r25	; 0x04
    3ade:	8b 83       	std	Y+3, r24	; 0x03
    3ae0:	7e 83       	std	Y+6, r23	; 0x06
    3ae2:	6d 83       	std	Y+5, r22	; 0x05
    3ae4:	58 87       	std	Y+8, r21	; 0x08
    3ae6:	4f 83       	std	Y+7, r20	; 0x07
    3ae8:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3aea:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3aec:	eb 81       	ldd	r30, Y+3	; 0x03
    3aee:	fc 81       	ldd	r31, Y+4	; 0x04
    3af0:	92 8d       	ldd	r25, Z+26	; 0x1a
    3af2:	eb 81       	ldd	r30, Y+3	; 0x03
    3af4:	fc 81       	ldd	r31, Y+4	; 0x04
    3af6:	83 8d       	ldd	r24, Z+27	; 0x1b
    3af8:	98 17       	cp	r25, r24
    3afa:	40 f5       	brcc	.+80     	; 0x3b4c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3afc:	8b 81       	ldd	r24, Y+3	; 0x03
    3afe:	9c 81       	ldd	r25, Y+4	; 0x04
    3b00:	2d 81       	ldd	r18, Y+5	; 0x05
    3b02:	3e 81       	ldd	r19, Y+6	; 0x06
    3b04:	b9 01       	movw	r22, r18
    3b06:	49 85       	ldd	r20, Y+9	; 0x09
    3b08:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3b0c:	eb 81       	ldd	r30, Y+3	; 0x03
    3b0e:	fc 81       	ldd	r31, Y+4	; 0x04
    3b10:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b12:	8f 3f       	cpi	r24, 0xFF	; 255
    3b14:	89 f4       	brne	.+34     	; 0x3b38 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3b16:	eb 81       	ldd	r30, Y+3	; 0x03
    3b18:	fc 81       	ldd	r31, Y+4	; 0x04
    3b1a:	81 89       	ldd	r24, Z+17	; 0x11
    3b1c:	88 23       	and	r24, r24
    3b1e:	99 f0       	breq	.+38     	; 0x3b46 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3b20:	8b 81       	ldd	r24, Y+3	; 0x03
    3b22:	9c 81       	ldd	r25, Y+4	; 0x04
    3b24:	41 96       	adiw	r24, 0x11	; 17
    3b26:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskRemoveFromEventList>
    3b2a:	88 23       	and	r24, r24
    3b2c:	61 f0       	breq	.+24     	; 0x3b46 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3b2e:	ef 81       	ldd	r30, Y+7	; 0x07
    3b30:	f8 85       	ldd	r31, Y+8	; 0x08
    3b32:	81 e0       	ldi	r24, 0x01	; 1
    3b34:	80 83       	st	Z, r24
    3b36:	07 c0       	rjmp	.+14     	; 0x3b46 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3b38:	eb 81       	ldd	r30, Y+3	; 0x03
    3b3a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b3e:	8f 5f       	subi	r24, 0xFF	; 255
    3b40:	eb 81       	ldd	r30, Y+3	; 0x03
    3b42:	fc 81       	ldd	r31, Y+4	; 0x04
    3b44:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3b46:	81 e0       	ldi	r24, 0x01	; 1
    3b48:	8a 83       	std	Y+2, r24	; 0x02
    3b4a:	01 c0       	rjmp	.+2      	; 0x3b4e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3b4c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3b4e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3b50:	29 96       	adiw	r28, 0x09	; 9
    3b52:	0f b6       	in	r0, 0x3f	; 63
    3b54:	f8 94       	cli
    3b56:	de bf       	out	0x3e, r29	; 62
    3b58:	0f be       	out	0x3f, r0	; 63
    3b5a:	cd bf       	out	0x3d, r28	; 61
    3b5c:	cf 91       	pop	r28
    3b5e:	df 91       	pop	r29
    3b60:	08 95       	ret

00003b62 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3b62:	df 93       	push	r29
    3b64:	cf 93       	push	r28
    3b66:	cd b7       	in	r28, 0x3d	; 61
    3b68:	de b7       	in	r29, 0x3e	; 62
    3b6a:	2e 97       	sbiw	r28, 0x0e	; 14
    3b6c:	0f b6       	in	r0, 0x3f	; 63
    3b6e:	f8 94       	cli
    3b70:	de bf       	out	0x3e, r29	; 62
    3b72:	0f be       	out	0x3f, r0	; 63
    3b74:	cd bf       	out	0x3d, r28	; 61
    3b76:	98 87       	std	Y+8, r25	; 0x08
    3b78:	8f 83       	std	Y+7, r24	; 0x07
    3b7a:	7a 87       	std	Y+10, r23	; 0x0a
    3b7c:	69 87       	std	Y+9, r22	; 0x09
    3b7e:	5c 87       	std	Y+12, r21	; 0x0c
    3b80:	4b 87       	std	Y+11, r20	; 0x0b
    3b82:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3b84:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3b86:	0f b6       	in	r0, 0x3f	; 63
    3b88:	f8 94       	cli
    3b8a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3b8c:	ef 81       	ldd	r30, Y+7	; 0x07
    3b8e:	f8 85       	ldd	r31, Y+8	; 0x08
    3b90:	82 8d       	ldd	r24, Z+26	; 0x1a
    3b92:	88 23       	and	r24, r24
    3b94:	09 f4       	brne	.+2      	; 0x3b98 <xQueueGenericReceive+0x36>
    3b96:	3f c0       	rjmp	.+126    	; 0x3c16 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3b98:	ef 81       	ldd	r30, Y+7	; 0x07
    3b9a:	f8 85       	ldd	r31, Y+8	; 0x08
    3b9c:	86 81       	ldd	r24, Z+6	; 0x06
    3b9e:	97 81       	ldd	r25, Z+7	; 0x07
    3ba0:	9a 83       	std	Y+2, r25	; 0x02
    3ba2:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3ba4:	8f 81       	ldd	r24, Y+7	; 0x07
    3ba6:	98 85       	ldd	r25, Y+8	; 0x08
    3ba8:	29 85       	ldd	r18, Y+9	; 0x09
    3baa:	3a 85       	ldd	r19, Y+10	; 0x0a
    3bac:	b9 01       	movw	r22, r18
    3bae:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3bb2:	8d 85       	ldd	r24, Y+13	; 0x0d
    3bb4:	88 23       	and	r24, r24
    3bb6:	b1 f4       	brne	.+44     	; 0x3be4 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3bb8:	ef 81       	ldd	r30, Y+7	; 0x07
    3bba:	f8 85       	ldd	r31, Y+8	; 0x08
    3bbc:	82 8d       	ldd	r24, Z+26	; 0x1a
    3bbe:	81 50       	subi	r24, 0x01	; 1
    3bc0:	ef 81       	ldd	r30, Y+7	; 0x07
    3bc2:	f8 85       	ldd	r31, Y+8	; 0x08
    3bc4:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3bc6:	ef 81       	ldd	r30, Y+7	; 0x07
    3bc8:	f8 85       	ldd	r31, Y+8	; 0x08
    3bca:	80 85       	ldd	r24, Z+8	; 0x08
    3bcc:	88 23       	and	r24, r24
    3bce:	f1 f0       	breq	.+60     	; 0x3c0c <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3bd0:	8f 81       	ldd	r24, Y+7	; 0x07
    3bd2:	98 85       	ldd	r25, Y+8	; 0x08
    3bd4:	08 96       	adiw	r24, 0x08	; 8
    3bd6:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskRemoveFromEventList>
    3bda:	81 30       	cpi	r24, 0x01	; 1
    3bdc:	b9 f4       	brne	.+46     	; 0x3c0c <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3bde:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
    3be2:	14 c0       	rjmp	.+40     	; 0x3c0c <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3be4:	ef 81       	ldd	r30, Y+7	; 0x07
    3be6:	f8 85       	ldd	r31, Y+8	; 0x08
    3be8:	89 81       	ldd	r24, Y+1	; 0x01
    3bea:	9a 81       	ldd	r25, Y+2	; 0x02
    3bec:	97 83       	std	Z+7, r25	; 0x07
    3bee:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3bf0:	ef 81       	ldd	r30, Y+7	; 0x07
    3bf2:	f8 85       	ldd	r31, Y+8	; 0x08
    3bf4:	81 89       	ldd	r24, Z+17	; 0x11
    3bf6:	88 23       	and	r24, r24
    3bf8:	49 f0       	breq	.+18     	; 0x3c0c <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3bfa:	8f 81       	ldd	r24, Y+7	; 0x07
    3bfc:	98 85       	ldd	r25, Y+8	; 0x08
    3bfe:	41 96       	adiw	r24, 0x11	; 17
    3c00:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskRemoveFromEventList>
    3c04:	88 23       	and	r24, r24
    3c06:	11 f0       	breq	.+4      	; 0x3c0c <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3c08:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3c0c:	0f 90       	pop	r0
    3c0e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3c10:	81 e0       	ldi	r24, 0x01	; 1
    3c12:	8e 87       	std	Y+14, r24	; 0x0e
    3c14:	5c c0       	rjmp	.+184    	; 0x3cce <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3c16:	8b 85       	ldd	r24, Y+11	; 0x0b
    3c18:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c1a:	00 97       	sbiw	r24, 0x00	; 0
    3c1c:	21 f4       	brne	.+8      	; 0x3c26 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3c1e:	0f 90       	pop	r0
    3c20:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3c22:	1e 86       	std	Y+14, r1	; 0x0e
    3c24:	54 c0       	rjmp	.+168    	; 0x3cce <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3c26:	8b 81       	ldd	r24, Y+3	; 0x03
    3c28:	88 23       	and	r24, r24
    3c2a:	31 f4       	brne	.+12     	; 0x3c38 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3c2c:	ce 01       	movw	r24, r28
    3c2e:	04 96       	adiw	r24, 0x04	; 4
    3c30:	0e 94 7e 25 	call	0x4afc	; 0x4afc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3c34:	81 e0       	ldi	r24, 0x01	; 1
    3c36:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    3c38:	0f 90       	pop	r0
    3c3a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3c3c:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3c40:	0f b6       	in	r0, 0x3f	; 63
    3c42:	f8 94       	cli
    3c44:	0f 92       	push	r0
    3c46:	ef 81       	ldd	r30, Y+7	; 0x07
    3c48:	f8 85       	ldd	r31, Y+8	; 0x08
    3c4a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c4c:	8f 3f       	cpi	r24, 0xFF	; 255
    3c4e:	19 f4       	brne	.+6      	; 0x3c56 <xQueueGenericReceive+0xf4>
    3c50:	ef 81       	ldd	r30, Y+7	; 0x07
    3c52:	f8 85       	ldd	r31, Y+8	; 0x08
    3c54:	15 8e       	std	Z+29, r1	; 0x1d
    3c56:	ef 81       	ldd	r30, Y+7	; 0x07
    3c58:	f8 85       	ldd	r31, Y+8	; 0x08
    3c5a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c5c:	8f 3f       	cpi	r24, 0xFF	; 255
    3c5e:	19 f4       	brne	.+6      	; 0x3c66 <xQueueGenericReceive+0x104>
    3c60:	ef 81       	ldd	r30, Y+7	; 0x07
    3c62:	f8 85       	ldd	r31, Y+8	; 0x08
    3c64:	16 8e       	std	Z+30, r1	; 0x1e
    3c66:	0f 90       	pop	r0
    3c68:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3c6a:	ce 01       	movw	r24, r28
    3c6c:	04 96       	adiw	r24, 0x04	; 4
    3c6e:	9e 01       	movw	r18, r28
    3c70:	25 5f       	subi	r18, 0xF5	; 245
    3c72:	3f 4f       	sbci	r19, 0xFF	; 255
    3c74:	b9 01       	movw	r22, r18
    3c76:	0e 94 97 25 	call	0x4b2e	; 0x4b2e <xTaskCheckForTimeOut>
    3c7a:	88 23       	and	r24, r24
    3c7c:	09 f5       	brne	.+66     	; 0x3cc0 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3c7e:	8f 81       	ldd	r24, Y+7	; 0x07
    3c80:	98 85       	ldd	r25, Y+8	; 0x08
    3c82:	0e 94 32 20 	call	0x4064	; 0x4064 <prvIsQueueEmpty>
    3c86:	88 23       	and	r24, r24
    3c88:	a1 f0       	breq	.+40     	; 0x3cb2 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3c8a:	8f 81       	ldd	r24, Y+7	; 0x07
    3c8c:	98 85       	ldd	r25, Y+8	; 0x08
    3c8e:	41 96       	adiw	r24, 0x11	; 17
    3c90:	2b 85       	ldd	r18, Y+11	; 0x0b
    3c92:	3c 85       	ldd	r19, Y+12	; 0x0c
    3c94:	b9 01       	movw	r22, r18
    3c96:	0e 94 e0 24 	call	0x49c0	; 0x49c0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3c9a:	8f 81       	ldd	r24, Y+7	; 0x07
    3c9c:	98 85       	ldd	r25, Y+8	; 0x08
    3c9e:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3ca2:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
    3ca6:	88 23       	and	r24, r24
    3ca8:	09 f0       	breq	.+2      	; 0x3cac <xQueueGenericReceive+0x14a>
    3caa:	6d cf       	rjmp	.-294    	; 0x3b86 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3cac:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
    3cb0:	6a cf       	rjmp	.-300    	; 0x3b86 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3cb2:	8f 81       	ldd	r24, Y+7	; 0x07
    3cb4:	98 85       	ldd	r25, Y+8	; 0x08
    3cb6:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3cba:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
    3cbe:	63 cf       	rjmp	.-314    	; 0x3b86 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3cc0:	8f 81       	ldd	r24, Y+7	; 0x07
    3cc2:	98 85       	ldd	r25, Y+8	; 0x08
    3cc4:	0e 94 de 1f 	call	0x3fbc	; 0x3fbc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3cc8:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3ccc:	1e 86       	std	Y+14, r1	; 0x0e
    3cce:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3cd0:	2e 96       	adiw	r28, 0x0e	; 14
    3cd2:	0f b6       	in	r0, 0x3f	; 63
    3cd4:	f8 94       	cli
    3cd6:	de bf       	out	0x3e, r29	; 62
    3cd8:	0f be       	out	0x3f, r0	; 63
    3cda:	cd bf       	out	0x3d, r28	; 61
    3cdc:	cf 91       	pop	r28
    3cde:	df 91       	pop	r29
    3ce0:	08 95       	ret

00003ce2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3ce2:	df 93       	push	r29
    3ce4:	cf 93       	push	r28
    3ce6:	cd b7       	in	r28, 0x3d	; 61
    3ce8:	de b7       	in	r29, 0x3e	; 62
    3cea:	28 97       	sbiw	r28, 0x08	; 8
    3cec:	0f b6       	in	r0, 0x3f	; 63
    3cee:	f8 94       	cli
    3cf0:	de bf       	out	0x3e, r29	; 62
    3cf2:	0f be       	out	0x3f, r0	; 63
    3cf4:	cd bf       	out	0x3d, r28	; 61
    3cf6:	9c 83       	std	Y+4, r25	; 0x04
    3cf8:	8b 83       	std	Y+3, r24	; 0x03
    3cfa:	7e 83       	std	Y+6, r23	; 0x06
    3cfc:	6d 83       	std	Y+5, r22	; 0x05
    3cfe:	58 87       	std	Y+8, r21	; 0x08
    3d00:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3d02:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3d04:	eb 81       	ldd	r30, Y+3	; 0x03
    3d06:	fc 81       	ldd	r31, Y+4	; 0x04
    3d08:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d0a:	88 23       	and	r24, r24
    3d0c:	71 f1       	breq	.+92     	; 0x3d6a <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d10:	9c 81       	ldd	r25, Y+4	; 0x04
    3d12:	2d 81       	ldd	r18, Y+5	; 0x05
    3d14:	3e 81       	ldd	r19, Y+6	; 0x06
    3d16:	b9 01       	movw	r22, r18
    3d18:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3d1c:	eb 81       	ldd	r30, Y+3	; 0x03
    3d1e:	fc 81       	ldd	r31, Y+4	; 0x04
    3d20:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d22:	81 50       	subi	r24, 0x01	; 1
    3d24:	eb 81       	ldd	r30, Y+3	; 0x03
    3d26:	fc 81       	ldd	r31, Y+4	; 0x04
    3d28:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3d2a:	eb 81       	ldd	r30, Y+3	; 0x03
    3d2c:	fc 81       	ldd	r31, Y+4	; 0x04
    3d2e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d30:	8f 3f       	cpi	r24, 0xFF	; 255
    3d32:	89 f4       	brne	.+34     	; 0x3d56 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3d34:	eb 81       	ldd	r30, Y+3	; 0x03
    3d36:	fc 81       	ldd	r31, Y+4	; 0x04
    3d38:	80 85       	ldd	r24, Z+8	; 0x08
    3d3a:	88 23       	and	r24, r24
    3d3c:	99 f0       	breq	.+38     	; 0x3d64 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3d3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d40:	9c 81       	ldd	r25, Y+4	; 0x04
    3d42:	08 96       	adiw	r24, 0x08	; 8
    3d44:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskRemoveFromEventList>
    3d48:	88 23       	and	r24, r24
    3d4a:	61 f0       	breq	.+24     	; 0x3d64 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    3d4c:	ef 81       	ldd	r30, Y+7	; 0x07
    3d4e:	f8 85       	ldd	r31, Y+8	; 0x08
    3d50:	81 e0       	ldi	r24, 0x01	; 1
    3d52:	80 83       	st	Z, r24
    3d54:	07 c0       	rjmp	.+14     	; 0x3d64 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3d56:	eb 81       	ldd	r30, Y+3	; 0x03
    3d58:	fc 81       	ldd	r31, Y+4	; 0x04
    3d5a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d5c:	8f 5f       	subi	r24, 0xFF	; 255
    3d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    3d60:	fc 81       	ldd	r31, Y+4	; 0x04
    3d62:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    3d64:	81 e0       	ldi	r24, 0x01	; 1
    3d66:	8a 83       	std	Y+2, r24	; 0x02
    3d68:	01 c0       	rjmp	.+2      	; 0x3d6c <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3d6a:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3d6c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3d6e:	28 96       	adiw	r28, 0x08	; 8
    3d70:	0f b6       	in	r0, 0x3f	; 63
    3d72:	f8 94       	cli
    3d74:	de bf       	out	0x3e, r29	; 62
    3d76:	0f be       	out	0x3f, r0	; 63
    3d78:	cd bf       	out	0x3d, r28	; 61
    3d7a:	cf 91       	pop	r28
    3d7c:	df 91       	pop	r29
    3d7e:	08 95       	ret

00003d80 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3d80:	df 93       	push	r29
    3d82:	cf 93       	push	r28
    3d84:	00 d0       	rcall	.+0      	; 0x3d86 <uxQueueMessagesWaiting+0x6>
    3d86:	0f 92       	push	r0
    3d88:	cd b7       	in	r28, 0x3d	; 61
    3d8a:	de b7       	in	r29, 0x3e	; 62
    3d8c:	9b 83       	std	Y+3, r25	; 0x03
    3d8e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3d90:	0f b6       	in	r0, 0x3f	; 63
    3d92:	f8 94       	cli
    3d94:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    3d96:	ea 81       	ldd	r30, Y+2	; 0x02
    3d98:	fb 81       	ldd	r31, Y+3	; 0x03
    3d9a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d9c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3d9e:	0f 90       	pop	r0
    3da0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3da2:	89 81       	ldd	r24, Y+1	; 0x01
}
    3da4:	0f 90       	pop	r0
    3da6:	0f 90       	pop	r0
    3da8:	0f 90       	pop	r0
    3daa:	cf 91       	pop	r28
    3dac:	df 91       	pop	r29
    3dae:	08 95       	ret

00003db0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3db0:	df 93       	push	r29
    3db2:	cf 93       	push	r28
    3db4:	00 d0       	rcall	.+0      	; 0x3db6 <uxQueueMessagesWaitingFromISR+0x6>
    3db6:	0f 92       	push	r0
    3db8:	cd b7       	in	r28, 0x3d	; 61
    3dba:	de b7       	in	r29, 0x3e	; 62
    3dbc:	9b 83       	std	Y+3, r25	; 0x03
    3dbe:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3dc0:	ea 81       	ldd	r30, Y+2	; 0x02
    3dc2:	fb 81       	ldd	r31, Y+3	; 0x03
    3dc4:	82 8d       	ldd	r24, Z+26	; 0x1a
    3dc6:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3dc8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3dca:	0f 90       	pop	r0
    3dcc:	0f 90       	pop	r0
    3dce:	0f 90       	pop	r0
    3dd0:	cf 91       	pop	r28
    3dd2:	df 91       	pop	r29
    3dd4:	08 95       	ret

00003dd6 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    3dd6:	df 93       	push	r29
    3dd8:	cf 93       	push	r28
    3dda:	00 d0       	rcall	.+0      	; 0x3ddc <vQueueDelete+0x6>
    3ddc:	cd b7       	in	r28, 0x3d	; 61
    3dde:	de b7       	in	r29, 0x3e	; 62
    3de0:	9a 83       	std	Y+2, r25	; 0x02
    3de2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    3de4:	e9 81       	ldd	r30, Y+1	; 0x01
    3de6:	fa 81       	ldd	r31, Y+2	; 0x02
    3de8:	80 81       	ld	r24, Z
    3dea:	91 81       	ldd	r25, Z+1	; 0x01
    3dec:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortFree>
	vPortFree( pxQueue );
    3df0:	89 81       	ldd	r24, Y+1	; 0x01
    3df2:	9a 81       	ldd	r25, Y+2	; 0x02
    3df4:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortFree>
}
    3df8:	0f 90       	pop	r0
    3dfa:	0f 90       	pop	r0
    3dfc:	cf 91       	pop	r28
    3dfe:	df 91       	pop	r29
    3e00:	08 95       	ret

00003e02 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3e02:	df 93       	push	r29
    3e04:	cf 93       	push	r28
    3e06:	00 d0       	rcall	.+0      	; 0x3e08 <prvCopyDataToQueue+0x6>
    3e08:	00 d0       	rcall	.+0      	; 0x3e0a <prvCopyDataToQueue+0x8>
    3e0a:	0f 92       	push	r0
    3e0c:	cd b7       	in	r28, 0x3d	; 61
    3e0e:	de b7       	in	r29, 0x3e	; 62
    3e10:	9a 83       	std	Y+2, r25	; 0x02
    3e12:	89 83       	std	Y+1, r24	; 0x01
    3e14:	7c 83       	std	Y+4, r23	; 0x04
    3e16:	6b 83       	std	Y+3, r22	; 0x03
    3e18:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e20:	88 23       	and	r24, r24
    3e22:	09 f4       	brne	.+2      	; 0x3e26 <prvCopyDataToQueue+0x24>
    3e24:	74 c0       	rjmp	.+232    	; 0x3f0e <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3e26:	8d 81       	ldd	r24, Y+5	; 0x05
    3e28:	88 23       	and	r24, r24
    3e2a:	99 f5       	brne	.+102    	; 0x3e92 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3e2c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e2e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e30:	64 81       	ldd	r22, Z+4	; 0x04
    3e32:	75 81       	ldd	r23, Z+5	; 0x05
    3e34:	e9 81       	ldd	r30, Y+1	; 0x01
    3e36:	fa 81       	ldd	r31, Y+2	; 0x02
    3e38:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e3a:	48 2f       	mov	r20, r24
    3e3c:	50 e0       	ldi	r21, 0x00	; 0
    3e3e:	2b 81       	ldd	r18, Y+3	; 0x03
    3e40:	3c 81       	ldd	r19, Y+4	; 0x04
    3e42:	cb 01       	movw	r24, r22
    3e44:	b9 01       	movw	r22, r18
    3e46:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e4e:	24 81       	ldd	r18, Z+4	; 0x04
    3e50:	35 81       	ldd	r19, Z+5	; 0x05
    3e52:	e9 81       	ldd	r30, Y+1	; 0x01
    3e54:	fa 81       	ldd	r31, Y+2	; 0x02
    3e56:	84 8d       	ldd	r24, Z+28	; 0x1c
    3e58:	88 2f       	mov	r24, r24
    3e5a:	90 e0       	ldi	r25, 0x00	; 0
    3e5c:	82 0f       	add	r24, r18
    3e5e:	93 1f       	adc	r25, r19
    3e60:	e9 81       	ldd	r30, Y+1	; 0x01
    3e62:	fa 81       	ldd	r31, Y+2	; 0x02
    3e64:	95 83       	std	Z+5, r25	; 0x05
    3e66:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3e68:	e9 81       	ldd	r30, Y+1	; 0x01
    3e6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e6c:	24 81       	ldd	r18, Z+4	; 0x04
    3e6e:	35 81       	ldd	r19, Z+5	; 0x05
    3e70:	e9 81       	ldd	r30, Y+1	; 0x01
    3e72:	fa 81       	ldd	r31, Y+2	; 0x02
    3e74:	82 81       	ldd	r24, Z+2	; 0x02
    3e76:	93 81       	ldd	r25, Z+3	; 0x03
    3e78:	28 17       	cp	r18, r24
    3e7a:	39 07       	cpc	r19, r25
    3e7c:	08 f4       	brcc	.+2      	; 0x3e80 <prvCopyDataToQueue+0x7e>
    3e7e:	47 c0       	rjmp	.+142    	; 0x3f0e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3e80:	e9 81       	ldd	r30, Y+1	; 0x01
    3e82:	fa 81       	ldd	r31, Y+2	; 0x02
    3e84:	80 81       	ld	r24, Z
    3e86:	91 81       	ldd	r25, Z+1	; 0x01
    3e88:	e9 81       	ldd	r30, Y+1	; 0x01
    3e8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e8c:	95 83       	std	Z+5, r25	; 0x05
    3e8e:	84 83       	std	Z+4, r24	; 0x04
    3e90:	3e c0       	rjmp	.+124    	; 0x3f0e <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3e92:	e9 81       	ldd	r30, Y+1	; 0x01
    3e94:	fa 81       	ldd	r31, Y+2	; 0x02
    3e96:	66 81       	ldd	r22, Z+6	; 0x06
    3e98:	77 81       	ldd	r23, Z+7	; 0x07
    3e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e9e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ea0:	48 2f       	mov	r20, r24
    3ea2:	50 e0       	ldi	r21, 0x00	; 0
    3ea4:	2b 81       	ldd	r18, Y+3	; 0x03
    3ea6:	3c 81       	ldd	r19, Y+4	; 0x04
    3ea8:	cb 01       	movw	r24, r22
    3eaa:	b9 01       	movw	r22, r18
    3eac:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3eb0:	e9 81       	ldd	r30, Y+1	; 0x01
    3eb2:	fa 81       	ldd	r31, Y+2	; 0x02
    3eb4:	26 81       	ldd	r18, Z+6	; 0x06
    3eb6:	37 81       	ldd	r19, Z+7	; 0x07
    3eb8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eba:	fa 81       	ldd	r31, Y+2	; 0x02
    3ebc:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ebe:	88 2f       	mov	r24, r24
    3ec0:	90 e0       	ldi	r25, 0x00	; 0
    3ec2:	90 95       	com	r25
    3ec4:	81 95       	neg	r24
    3ec6:	9f 4f       	sbci	r25, 0xFF	; 255
    3ec8:	82 0f       	add	r24, r18
    3eca:	93 1f       	adc	r25, r19
    3ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ece:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed0:	97 83       	std	Z+7, r25	; 0x07
    3ed2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    3ed4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ed6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ed8:	26 81       	ldd	r18, Z+6	; 0x06
    3eda:	37 81       	ldd	r19, Z+7	; 0x07
    3edc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ede:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee0:	80 81       	ld	r24, Z
    3ee2:	91 81       	ldd	r25, Z+1	; 0x01
    3ee4:	28 17       	cp	r18, r24
    3ee6:	39 07       	cpc	r19, r25
    3ee8:	90 f4       	brcc	.+36     	; 0x3f0e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3eea:	e9 81       	ldd	r30, Y+1	; 0x01
    3eec:	fa 81       	ldd	r31, Y+2	; 0x02
    3eee:	22 81       	ldd	r18, Z+2	; 0x02
    3ef0:	33 81       	ldd	r19, Z+3	; 0x03
    3ef2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef6:	84 8d       	ldd	r24, Z+28	; 0x1c
    3ef8:	88 2f       	mov	r24, r24
    3efa:	90 e0       	ldi	r25, 0x00	; 0
    3efc:	90 95       	com	r25
    3efe:	81 95       	neg	r24
    3f00:	9f 4f       	sbci	r25, 0xFF	; 255
    3f02:	82 0f       	add	r24, r18
    3f04:	93 1f       	adc	r25, r19
    3f06:	e9 81       	ldd	r30, Y+1	; 0x01
    3f08:	fa 81       	ldd	r31, Y+2	; 0x02
    3f0a:	97 83       	std	Z+7, r25	; 0x07
    3f0c:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    3f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f10:	fa 81       	ldd	r31, Y+2	; 0x02
    3f12:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f14:	8f 5f       	subi	r24, 0xFF	; 255
    3f16:	e9 81       	ldd	r30, Y+1	; 0x01
    3f18:	fa 81       	ldd	r31, Y+2	; 0x02
    3f1a:	82 8f       	std	Z+26, r24	; 0x1a
}
    3f1c:	0f 90       	pop	r0
    3f1e:	0f 90       	pop	r0
    3f20:	0f 90       	pop	r0
    3f22:	0f 90       	pop	r0
    3f24:	0f 90       	pop	r0
    3f26:	cf 91       	pop	r28
    3f28:	df 91       	pop	r29
    3f2a:	08 95       	ret

00003f2c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    3f2c:	df 93       	push	r29
    3f2e:	cf 93       	push	r28
    3f30:	00 d0       	rcall	.+0      	; 0x3f32 <prvCopyDataFromQueue+0x6>
    3f32:	00 d0       	rcall	.+0      	; 0x3f34 <prvCopyDataFromQueue+0x8>
    3f34:	cd b7       	in	r28, 0x3d	; 61
    3f36:	de b7       	in	r29, 0x3e	; 62
    3f38:	9a 83       	std	Y+2, r25	; 0x02
    3f3a:	89 83       	std	Y+1, r24	; 0x01
    3f3c:	7c 83       	std	Y+4, r23	; 0x04
    3f3e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    3f40:	e9 81       	ldd	r30, Y+1	; 0x01
    3f42:	fa 81       	ldd	r31, Y+2	; 0x02
    3f44:	80 81       	ld	r24, Z
    3f46:	91 81       	ldd	r25, Z+1	; 0x01
    3f48:	00 97       	sbiw	r24, 0x00	; 0
    3f4a:	89 f1       	breq	.+98     	; 0x3fae <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    3f4c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f4e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f50:	26 81       	ldd	r18, Z+6	; 0x06
    3f52:	37 81       	ldd	r19, Z+7	; 0x07
    3f54:	e9 81       	ldd	r30, Y+1	; 0x01
    3f56:	fa 81       	ldd	r31, Y+2	; 0x02
    3f58:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f5a:	88 2f       	mov	r24, r24
    3f5c:	90 e0       	ldi	r25, 0x00	; 0
    3f5e:	82 0f       	add	r24, r18
    3f60:	93 1f       	adc	r25, r19
    3f62:	e9 81       	ldd	r30, Y+1	; 0x01
    3f64:	fa 81       	ldd	r31, Y+2	; 0x02
    3f66:	97 83       	std	Z+7, r25	; 0x07
    3f68:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    3f6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f6e:	26 81       	ldd	r18, Z+6	; 0x06
    3f70:	37 81       	ldd	r19, Z+7	; 0x07
    3f72:	e9 81       	ldd	r30, Y+1	; 0x01
    3f74:	fa 81       	ldd	r31, Y+2	; 0x02
    3f76:	82 81       	ldd	r24, Z+2	; 0x02
    3f78:	93 81       	ldd	r25, Z+3	; 0x03
    3f7a:	28 17       	cp	r18, r24
    3f7c:	39 07       	cpc	r19, r25
    3f7e:	40 f0       	brcs	.+16     	; 0x3f90 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3f80:	e9 81       	ldd	r30, Y+1	; 0x01
    3f82:	fa 81       	ldd	r31, Y+2	; 0x02
    3f84:	80 81       	ld	r24, Z
    3f86:	91 81       	ldd	r25, Z+1	; 0x01
    3f88:	e9 81       	ldd	r30, Y+1	; 0x01
    3f8a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f8c:	97 83       	std	Z+7, r25	; 0x07
    3f8e:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3f90:	e9 81       	ldd	r30, Y+1	; 0x01
    3f92:	fa 81       	ldd	r31, Y+2	; 0x02
    3f94:	46 81       	ldd	r20, Z+6	; 0x06
    3f96:	57 81       	ldd	r21, Z+7	; 0x07
    3f98:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9a:	fa 81       	ldd	r31, Y+2	; 0x02
    3f9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f9e:	28 2f       	mov	r18, r24
    3fa0:	30 e0       	ldi	r19, 0x00	; 0
    3fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    3fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    3fa6:	ba 01       	movw	r22, r20
    3fa8:	a9 01       	movw	r20, r18
    3faa:	0e 94 e2 27 	call	0x4fc4	; 0x4fc4 <memcpy>
	}
}
    3fae:	0f 90       	pop	r0
    3fb0:	0f 90       	pop	r0
    3fb2:	0f 90       	pop	r0
    3fb4:	0f 90       	pop	r0
    3fb6:	cf 91       	pop	r28
    3fb8:	df 91       	pop	r29
    3fba:	08 95       	ret

00003fbc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    3fbc:	df 93       	push	r29
    3fbe:	cf 93       	push	r28
    3fc0:	00 d0       	rcall	.+0      	; 0x3fc2 <prvUnlockQueue+0x6>
    3fc2:	cd b7       	in	r28, 0x3d	; 61
    3fc4:	de b7       	in	r29, 0x3e	; 62
    3fc6:	9a 83       	std	Y+2, r25	; 0x02
    3fc8:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3fca:	0f b6       	in	r0, 0x3f	; 63
    3fcc:	f8 94       	cli
    3fce:	0f 92       	push	r0
    3fd0:	15 c0       	rjmp	.+42     	; 0x3ffc <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fd6:	81 89       	ldd	r24, Z+17	; 0x11
    3fd8:	88 23       	and	r24, r24
    3fda:	a9 f0       	breq	.+42     	; 0x4006 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3fdc:	89 81       	ldd	r24, Y+1	; 0x01
    3fde:	9a 81       	ldd	r25, Y+2	; 0x02
    3fe0:	41 96       	adiw	r24, 0x11	; 17
    3fe2:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskRemoveFromEventList>
    3fe6:	88 23       	and	r24, r24
    3fe8:	11 f0       	breq	.+4      	; 0x3fee <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3fea:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3fee:	e9 81       	ldd	r30, Y+1	; 0x01
    3ff0:	fa 81       	ldd	r31, Y+2	; 0x02
    3ff2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ff4:	81 50       	subi	r24, 0x01	; 1
    3ff6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ff8:	fa 81       	ldd	r31, Y+2	; 0x02
    3ffa:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3ffc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffe:	fa 81       	ldd	r31, Y+2	; 0x02
    4000:	86 8d       	ldd	r24, Z+30	; 0x1e
    4002:	18 16       	cp	r1, r24
    4004:	34 f3       	brlt	.-52     	; 0x3fd2 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4006:	e9 81       	ldd	r30, Y+1	; 0x01
    4008:	fa 81       	ldd	r31, Y+2	; 0x02
    400a:	8f ef       	ldi	r24, 0xFF	; 255
    400c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    400e:	0f 90       	pop	r0
    4010:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4012:	0f b6       	in	r0, 0x3f	; 63
    4014:	f8 94       	cli
    4016:	0f 92       	push	r0
    4018:	15 c0       	rjmp	.+42     	; 0x4044 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    401a:	e9 81       	ldd	r30, Y+1	; 0x01
    401c:	fa 81       	ldd	r31, Y+2	; 0x02
    401e:	80 85       	ldd	r24, Z+8	; 0x08
    4020:	88 23       	and	r24, r24
    4022:	a9 f0       	breq	.+42     	; 0x404e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4024:	89 81       	ldd	r24, Y+1	; 0x01
    4026:	9a 81       	ldd	r25, Y+2	; 0x02
    4028:	08 96       	adiw	r24, 0x08	; 8
    402a:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <xTaskRemoveFromEventList>
    402e:	88 23       	and	r24, r24
    4030:	11 f0       	breq	.+4      	; 0x4036 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4032:	0e 94 f4 25 	call	0x4be8	; 0x4be8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    4036:	e9 81       	ldd	r30, Y+1	; 0x01
    4038:	fa 81       	ldd	r31, Y+2	; 0x02
    403a:	85 8d       	ldd	r24, Z+29	; 0x1d
    403c:	81 50       	subi	r24, 0x01	; 1
    403e:	e9 81       	ldd	r30, Y+1	; 0x01
    4040:	fa 81       	ldd	r31, Y+2	; 0x02
    4042:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4044:	e9 81       	ldd	r30, Y+1	; 0x01
    4046:	fa 81       	ldd	r31, Y+2	; 0x02
    4048:	85 8d       	ldd	r24, Z+29	; 0x1d
    404a:	18 16       	cp	r1, r24
    404c:	34 f3       	brlt	.-52     	; 0x401a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    404e:	e9 81       	ldd	r30, Y+1	; 0x01
    4050:	fa 81       	ldd	r31, Y+2	; 0x02
    4052:	8f ef       	ldi	r24, 0xFF	; 255
    4054:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    4056:	0f 90       	pop	r0
    4058:	0f be       	out	0x3f, r0	; 63
}
    405a:	0f 90       	pop	r0
    405c:	0f 90       	pop	r0
    405e:	cf 91       	pop	r28
    4060:	df 91       	pop	r29
    4062:	08 95       	ret

00004064 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    4064:	df 93       	push	r29
    4066:	cf 93       	push	r28
    4068:	00 d0       	rcall	.+0      	; 0x406a <prvIsQueueEmpty+0x6>
    406a:	0f 92       	push	r0
    406c:	cd b7       	in	r28, 0x3d	; 61
    406e:	de b7       	in	r29, 0x3e	; 62
    4070:	9b 83       	std	Y+3, r25	; 0x03
    4072:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4074:	0f b6       	in	r0, 0x3f	; 63
    4076:	f8 94       	cli
    4078:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    407a:	ea 81       	ldd	r30, Y+2	; 0x02
    407c:	fb 81       	ldd	r31, Y+3	; 0x03
    407e:	82 8d       	ldd	r24, Z+26	; 0x1a
    4080:	19 82       	std	Y+1, r1	; 0x01
    4082:	88 23       	and	r24, r24
    4084:	11 f4       	brne	.+4      	; 0x408a <prvIsQueueEmpty+0x26>
    4086:	81 e0       	ldi	r24, 0x01	; 1
    4088:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    408a:	0f 90       	pop	r0
    408c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    408e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4090:	0f 90       	pop	r0
    4092:	0f 90       	pop	r0
    4094:	0f 90       	pop	r0
    4096:	cf 91       	pop	r28
    4098:	df 91       	pop	r29
    409a:	08 95       	ret

0000409c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    409c:	df 93       	push	r29
    409e:	cf 93       	push	r28
    40a0:	00 d0       	rcall	.+0      	; 0x40a2 <xQueueIsQueueEmptyFromISR+0x6>
    40a2:	0f 92       	push	r0
    40a4:	cd b7       	in	r28, 0x3d	; 61
    40a6:	de b7       	in	r29, 0x3e	; 62
    40a8:	9b 83       	std	Y+3, r25	; 0x03
    40aa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    40ac:	ea 81       	ldd	r30, Y+2	; 0x02
    40ae:	fb 81       	ldd	r31, Y+3	; 0x03
    40b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    40b2:	19 82       	std	Y+1, r1	; 0x01
    40b4:	88 23       	and	r24, r24
    40b6:	11 f4       	brne	.+4      	; 0x40bc <xQueueIsQueueEmptyFromISR+0x20>
    40b8:	81 e0       	ldi	r24, 0x01	; 1
    40ba:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    40bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    40be:	0f 90       	pop	r0
    40c0:	0f 90       	pop	r0
    40c2:	0f 90       	pop	r0
    40c4:	cf 91       	pop	r28
    40c6:	df 91       	pop	r29
    40c8:	08 95       	ret

000040ca <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    40ca:	df 93       	push	r29
    40cc:	cf 93       	push	r28
    40ce:	00 d0       	rcall	.+0      	; 0x40d0 <prvIsQueueFull+0x6>
    40d0:	0f 92       	push	r0
    40d2:	cd b7       	in	r28, 0x3d	; 61
    40d4:	de b7       	in	r29, 0x3e	; 62
    40d6:	9b 83       	std	Y+3, r25	; 0x03
    40d8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    40da:	0f b6       	in	r0, 0x3f	; 63
    40dc:	f8 94       	cli
    40de:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    40e0:	ea 81       	ldd	r30, Y+2	; 0x02
    40e2:	fb 81       	ldd	r31, Y+3	; 0x03
    40e4:	92 8d       	ldd	r25, Z+26	; 0x1a
    40e6:	ea 81       	ldd	r30, Y+2	; 0x02
    40e8:	fb 81       	ldd	r31, Y+3	; 0x03
    40ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    40ec:	19 82       	std	Y+1, r1	; 0x01
    40ee:	98 17       	cp	r25, r24
    40f0:	11 f4       	brne	.+4      	; 0x40f6 <prvIsQueueFull+0x2c>
    40f2:	81 e0       	ldi	r24, 0x01	; 1
    40f4:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    40f6:	0f 90       	pop	r0
    40f8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    40fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    40fc:	0f 90       	pop	r0
    40fe:	0f 90       	pop	r0
    4100:	0f 90       	pop	r0
    4102:	cf 91       	pop	r28
    4104:	df 91       	pop	r29
    4106:	08 95       	ret

00004108 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    4108:	df 93       	push	r29
    410a:	cf 93       	push	r28
    410c:	00 d0       	rcall	.+0      	; 0x410e <xQueueIsQueueFullFromISR+0x6>
    410e:	0f 92       	push	r0
    4110:	cd b7       	in	r28, 0x3d	; 61
    4112:	de b7       	in	r29, 0x3e	; 62
    4114:	9b 83       	std	Y+3, r25	; 0x03
    4116:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    4118:	ea 81       	ldd	r30, Y+2	; 0x02
    411a:	fb 81       	ldd	r31, Y+3	; 0x03
    411c:	92 8d       	ldd	r25, Z+26	; 0x1a
    411e:	ea 81       	ldd	r30, Y+2	; 0x02
    4120:	fb 81       	ldd	r31, Y+3	; 0x03
    4122:	83 8d       	ldd	r24, Z+27	; 0x1b
    4124:	19 82       	std	Y+1, r1	; 0x01
    4126:	98 17       	cp	r25, r24
    4128:	11 f4       	brne	.+4      	; 0x412e <xQueueIsQueueFullFromISR+0x26>
    412a:	81 e0       	ldi	r24, 0x01	; 1
    412c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    412e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4130:	0f 90       	pop	r0
    4132:	0f 90       	pop	r0
    4134:	0f 90       	pop	r0
    4136:	cf 91       	pop	r28
    4138:	df 91       	pop	r29
    413a:	08 95       	ret

0000413c <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    413c:	af 92       	push	r10
    413e:	bf 92       	push	r11
    4140:	cf 92       	push	r12
    4142:	df 92       	push	r13
    4144:	ef 92       	push	r14
    4146:	ff 92       	push	r15
    4148:	0f 93       	push	r16
    414a:	1f 93       	push	r17
    414c:	df 93       	push	r29
    414e:	cf 93       	push	r28
    4150:	cd b7       	in	r28, 0x3d	; 61
    4152:	de b7       	in	r29, 0x3e	; 62
    4154:	64 97       	sbiw	r28, 0x14	; 20
    4156:	0f b6       	in	r0, 0x3f	; 63
    4158:	f8 94       	cli
    415a:	de bf       	out	0x3e, r29	; 62
    415c:	0f be       	out	0x3f, r0	; 63
    415e:	cd bf       	out	0x3d, r28	; 61
    4160:	9f 83       	std	Y+7, r25	; 0x07
    4162:	8e 83       	std	Y+6, r24	; 0x06
    4164:	79 87       	std	Y+9, r23	; 0x09
    4166:	68 87       	std	Y+8, r22	; 0x08
    4168:	5b 87       	std	Y+11, r21	; 0x0b
    416a:	4a 87       	std	Y+10, r20	; 0x0a
    416c:	3d 87       	std	Y+13, r19	; 0x0d
    416e:	2c 87       	std	Y+12, r18	; 0x0c
    4170:	0e 87       	std	Y+14, r16	; 0x0e
    4172:	f8 8a       	std	Y+16, r15	; 0x10
    4174:	ef 86       	std	Y+15, r14	; 0x0f
    4176:	da 8a       	std	Y+18, r13	; 0x12
    4178:	c9 8a       	std	Y+17, r12	; 0x11
    417a:	bc 8a       	std	Y+20, r11	; 0x14
    417c:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    417e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4180:	9b 85       	ldd	r25, Y+11	; 0x0b
    4182:	29 89       	ldd	r18, Y+17	; 0x11
    4184:	3a 89       	ldd	r19, Y+18	; 0x12
    4186:	b9 01       	movw	r22, r18
    4188:	0e 94 23 27 	call	0x4e46	; 0x4e46 <prvAllocateTCBAndStack>
    418c:	9c 83       	std	Y+4, r25	; 0x04
    418e:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    4190:	8b 81       	ldd	r24, Y+3	; 0x03
    4192:	9c 81       	ldd	r25, Y+4	; 0x04
    4194:	00 97       	sbiw	r24, 0x00	; 0
    4196:	09 f4       	brne	.+2      	; 0x419a <xTaskGenericCreate+0x5e>
    4198:	99 c0       	rjmp	.+306    	; 0x42cc <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    419a:	eb 81       	ldd	r30, Y+3	; 0x03
    419c:	fc 81       	ldd	r31, Y+4	; 0x04
    419e:	27 89       	ldd	r18, Z+23	; 0x17
    41a0:	30 8d       	ldd	r19, Z+24	; 0x18
    41a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    41a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    41a6:	01 97       	sbiw	r24, 0x01	; 1
    41a8:	82 0f       	add	r24, r18
    41aa:	93 1f       	adc	r25, r19
    41ac:	9a 83       	std	Y+2, r25	; 0x02
    41ae:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    41b0:	8b 81       	ldd	r24, Y+3	; 0x03
    41b2:	9c 81       	ldd	r25, Y+4	; 0x04
    41b4:	28 85       	ldd	r18, Y+8	; 0x08
    41b6:	39 85       	ldd	r19, Y+9	; 0x09
    41b8:	eb 89       	ldd	r30, Y+19	; 0x13
    41ba:	fc 89       	ldd	r31, Y+20	; 0x14
    41bc:	aa 85       	ldd	r26, Y+10	; 0x0a
    41be:	bb 85       	ldd	r27, Y+11	; 0x0b
    41c0:	b9 01       	movw	r22, r18
    41c2:	4e 85       	ldd	r20, Y+14	; 0x0e
    41c4:	9f 01       	movw	r18, r30
    41c6:	8d 01       	movw	r16, r26
    41c8:	0e 94 08 26 	call	0x4c10	; 0x4c10 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    41cc:	89 81       	ldd	r24, Y+1	; 0x01
    41ce:	9a 81       	ldd	r25, Y+2	; 0x02
    41d0:	2e 81       	ldd	r18, Y+6	; 0x06
    41d2:	3f 81       	ldd	r19, Y+7	; 0x07
    41d4:	4c 85       	ldd	r20, Y+12	; 0x0c
    41d6:	5d 85       	ldd	r21, Y+13	; 0x0d
    41d8:	b9 01       	movw	r22, r18
    41da:	0e 94 4b 19 	call	0x3296	; 0x3296 <pxPortInitialiseStack>
    41de:	eb 81       	ldd	r30, Y+3	; 0x03
    41e0:	fc 81       	ldd	r31, Y+4	; 0x04
    41e2:	91 83       	std	Z+1, r25	; 0x01
    41e4:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    41e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    41e8:	98 89       	ldd	r25, Y+16	; 0x10
    41ea:	00 97       	sbiw	r24, 0x00	; 0
    41ec:	31 f0       	breq	.+12     	; 0x41fa <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    41ee:	ef 85       	ldd	r30, Y+15	; 0x0f
    41f0:	f8 89       	ldd	r31, Y+16	; 0x10
    41f2:	8b 81       	ldd	r24, Y+3	; 0x03
    41f4:	9c 81       	ldd	r25, Y+4	; 0x04
    41f6:	91 83       	std	Z+1, r25	; 0x01
    41f8:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    41fa:	0f b6       	in	r0, 0x3f	; 63
    41fc:	f8 94       	cli
    41fe:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4200:	80 91 b0 04 	lds	r24, 0x04B0
    4204:	8f 5f       	subi	r24, 0xFF	; 255
    4206:	80 93 b0 04 	sts	0x04B0, r24
			if( pxCurrentTCB == NULL )
    420a:	80 91 ad 04 	lds	r24, 0x04AD
    420e:	90 91 ae 04 	lds	r25, 0x04AE
    4212:	00 97       	sbiw	r24, 0x00	; 0
    4214:	69 f4       	brne	.+26     	; 0x4230 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4216:	8b 81       	ldd	r24, Y+3	; 0x03
    4218:	9c 81       	ldd	r25, Y+4	; 0x04
    421a:	90 93 ae 04 	sts	0x04AE, r25
    421e:	80 93 ad 04 	sts	0x04AD, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    4222:	80 91 b0 04 	lds	r24, 0x04B0
    4226:	81 30       	cpi	r24, 0x01	; 1
    4228:	a9 f4       	brne	.+42     	; 0x4254 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    422a:	0e 94 5f 26 	call	0x4cbe	; 0x4cbe <prvInitialiseTaskLists>
    422e:	12 c0       	rjmp	.+36     	; 0x4254 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4230:	80 91 b5 04 	lds	r24, 0x04B5
    4234:	88 23       	and	r24, r24
    4236:	71 f4       	brne	.+28     	; 0x4254 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4238:	e0 91 ad 04 	lds	r30, 0x04AD
    423c:	f0 91 ae 04 	lds	r31, 0x04AE
    4240:	96 89       	ldd	r25, Z+22	; 0x16
    4242:	8e 85       	ldd	r24, Y+14	; 0x0e
    4244:	89 17       	cp	r24, r25
    4246:	30 f0       	brcs	.+12     	; 0x4254 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    4248:	8b 81       	ldd	r24, Y+3	; 0x03
    424a:	9c 81       	ldd	r25, Y+4	; 0x04
    424c:	90 93 ae 04 	sts	0x04AE, r25
    4250:	80 93 ad 04 	sts	0x04AD, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    4254:	eb 81       	ldd	r30, Y+3	; 0x03
    4256:	fc 81       	ldd	r31, Y+4	; 0x04
    4258:	96 89       	ldd	r25, Z+22	; 0x16
    425a:	80 91 b3 04 	lds	r24, 0x04B3
    425e:	89 17       	cp	r24, r25
    4260:	28 f4       	brcc	.+10     	; 0x426c <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    4262:	eb 81       	ldd	r30, Y+3	; 0x03
    4264:	fc 81       	ldd	r31, Y+4	; 0x04
    4266:	86 89       	ldd	r24, Z+22	; 0x16
    4268:	80 93 b3 04 	sts	0x04B3, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    426c:	80 91 ba 04 	lds	r24, 0x04BA
    4270:	8f 5f       	subi	r24, 0xFF	; 255
    4272:	80 93 ba 04 	sts	0x04BA, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    4276:	eb 81       	ldd	r30, Y+3	; 0x03
    4278:	fc 81       	ldd	r31, Y+4	; 0x04
    427a:	96 89       	ldd	r25, Z+22	; 0x16
    427c:	80 91 b4 04 	lds	r24, 0x04B4
    4280:	89 17       	cp	r24, r25
    4282:	28 f4       	brcc	.+10     	; 0x428e <xTaskGenericCreate+0x152>
    4284:	eb 81       	ldd	r30, Y+3	; 0x03
    4286:	fc 81       	ldd	r31, Y+4	; 0x04
    4288:	86 89       	ldd	r24, Z+22	; 0x16
    428a:	80 93 b4 04 	sts	0x04B4, r24
    428e:	eb 81       	ldd	r30, Y+3	; 0x03
    4290:	fc 81       	ldd	r31, Y+4	; 0x04
    4292:	86 89       	ldd	r24, Z+22	; 0x16
    4294:	28 2f       	mov	r18, r24
    4296:	30 e0       	ldi	r19, 0x00	; 0
    4298:	c9 01       	movw	r24, r18
    429a:	88 0f       	add	r24, r24
    429c:	99 1f       	adc	r25, r25
    429e:	88 0f       	add	r24, r24
    42a0:	99 1f       	adc	r25, r25
    42a2:	88 0f       	add	r24, r24
    42a4:	99 1f       	adc	r25, r25
    42a6:	82 0f       	add	r24, r18
    42a8:	93 1f       	adc	r25, r19
    42aa:	ac 01       	movw	r20, r24
    42ac:	45 54       	subi	r20, 0x45	; 69
    42ae:	5b 4f       	sbci	r21, 0xFB	; 251
    42b0:	8b 81       	ldd	r24, Y+3	; 0x03
    42b2:	9c 81       	ldd	r25, Y+4	; 0x04
    42b4:	9c 01       	movw	r18, r24
    42b6:	2e 5f       	subi	r18, 0xFE	; 254
    42b8:	3f 4f       	sbci	r19, 0xFF	; 255
    42ba:	ca 01       	movw	r24, r20
    42bc:	b9 01       	movw	r22, r18
    42be:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>

			xReturn = pdPASS;
    42c2:	81 e0       	ldi	r24, 0x01	; 1
    42c4:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    42c6:	0f 90       	pop	r0
    42c8:	0f be       	out	0x3f, r0	; 63
    42ca:	02 c0       	rjmp	.+4      	; 0x42d0 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    42cc:	8f ef       	ldi	r24, 0xFF	; 255
    42ce:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    42d0:	8d 81       	ldd	r24, Y+5	; 0x05
    42d2:	81 30       	cpi	r24, 0x01	; 1
    42d4:	71 f4       	brne	.+28     	; 0x42f2 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    42d6:	80 91 b5 04 	lds	r24, 0x04B5
    42da:	88 23       	and	r24, r24
    42dc:	51 f0       	breq	.+20     	; 0x42f2 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    42de:	e0 91 ad 04 	lds	r30, 0x04AD
    42e2:	f0 91 ae 04 	lds	r31, 0x04AE
    42e6:	96 89       	ldd	r25, Z+22	; 0x16
    42e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    42ea:	98 17       	cp	r25, r24
    42ec:	10 f4       	brcc	.+4      	; 0x42f2 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    42ee:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
			}
		}
	}

	return xReturn;
    42f2:	8d 81       	ldd	r24, Y+5	; 0x05
}
    42f4:	64 96       	adiw	r28, 0x14	; 20
    42f6:	0f b6       	in	r0, 0x3f	; 63
    42f8:	f8 94       	cli
    42fa:	de bf       	out	0x3e, r29	; 62
    42fc:	0f be       	out	0x3f, r0	; 63
    42fe:	cd bf       	out	0x3d, r28	; 61
    4300:	cf 91       	pop	r28
    4302:	df 91       	pop	r29
    4304:	1f 91       	pop	r17
    4306:	0f 91       	pop	r16
    4308:	ff 90       	pop	r15
    430a:	ef 90       	pop	r14
    430c:	df 90       	pop	r13
    430e:	cf 90       	pop	r12
    4310:	bf 90       	pop	r11
    4312:	af 90       	pop	r10
    4314:	08 95       	ret

00004316 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    4316:	df 93       	push	r29
    4318:	cf 93       	push	r28
    431a:	00 d0       	rcall	.+0      	; 0x431c <vTaskDelete+0x6>
    431c:	00 d0       	rcall	.+0      	; 0x431e <vTaskDelete+0x8>
    431e:	00 d0       	rcall	.+0      	; 0x4320 <vTaskDelete+0xa>
    4320:	cd b7       	in	r28, 0x3d	; 61
    4322:	de b7       	in	r29, 0x3e	; 62
    4324:	9c 83       	std	Y+4, r25	; 0x04
    4326:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    4328:	0f b6       	in	r0, 0x3f	; 63
    432a:	f8 94       	cli
    432c:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    432e:	20 91 ad 04 	lds	r18, 0x04AD
    4332:	30 91 ae 04 	lds	r19, 0x04AE
    4336:	8b 81       	ldd	r24, Y+3	; 0x03
    4338:	9c 81       	ldd	r25, Y+4	; 0x04
    433a:	82 17       	cp	r24, r18
    433c:	93 07       	cpc	r25, r19
    433e:	11 f4       	brne	.+4      	; 0x4344 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    4340:	1c 82       	std	Y+4, r1	; 0x04
    4342:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    4344:	8b 81       	ldd	r24, Y+3	; 0x03
    4346:	9c 81       	ldd	r25, Y+4	; 0x04
    4348:	00 97       	sbiw	r24, 0x00	; 0
    434a:	39 f4       	brne	.+14     	; 0x435a <vTaskDelete+0x44>
    434c:	80 91 ad 04 	lds	r24, 0x04AD
    4350:	90 91 ae 04 	lds	r25, 0x04AE
    4354:	9e 83       	std	Y+6, r25	; 0x06
    4356:	8d 83       	std	Y+5, r24	; 0x05
    4358:	04 c0       	rjmp	.+8      	; 0x4362 <vTaskDelete+0x4c>
    435a:	8b 81       	ldd	r24, Y+3	; 0x03
    435c:	9c 81       	ldd	r25, Y+4	; 0x04
    435e:	9e 83       	std	Y+6, r25	; 0x06
    4360:	8d 83       	std	Y+5, r24	; 0x05
    4362:	8d 81       	ldd	r24, Y+5	; 0x05
    4364:	9e 81       	ldd	r25, Y+6	; 0x06
    4366:	9a 83       	std	Y+2, r25	; 0x02
    4368:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    436a:	89 81       	ldd	r24, Y+1	; 0x01
    436c:	9a 81       	ldd	r25, Y+2	; 0x02
    436e:	02 96       	adiw	r24, 0x02	; 2
    4370:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    4374:	e9 81       	ldd	r30, Y+1	; 0x01
    4376:	fa 81       	ldd	r31, Y+2	; 0x02
    4378:	84 89       	ldd	r24, Z+20	; 0x14
    437a:	95 89       	ldd	r25, Z+21	; 0x15
    437c:	00 97       	sbiw	r24, 0x00	; 0
    437e:	29 f0       	breq	.+10     	; 0x438a <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    4380:	89 81       	ldd	r24, Y+1	; 0x01
    4382:	9a 81       	ldd	r25, Y+2	; 0x02
    4384:	0c 96       	adiw	r24, 0x0c	; 12
    4386:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    438a:	89 81       	ldd	r24, Y+1	; 0x01
    438c:	9a 81       	ldd	r25, Y+2	; 0x02
    438e:	9c 01       	movw	r18, r24
    4390:	2e 5f       	subi	r18, 0xFE	; 254
    4392:	3f 4f       	sbci	r19, 0xFF	; 255
    4394:	87 e0       	ldi	r24, 0x07	; 7
    4396:	95 e0       	ldi	r25, 0x05	; 5
    4398:	b9 01       	movw	r22, r18
    439a:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    439e:	80 91 af 04 	lds	r24, 0x04AF
    43a2:	8f 5f       	subi	r24, 0xFF	; 255
    43a4:	80 93 af 04 	sts	0x04AF, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    43a8:	80 91 ba 04 	lds	r24, 0x04BA
    43ac:	8f 5f       	subi	r24, 0xFF	; 255
    43ae:	80 93 ba 04 	sts	0x04BA, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    43b2:	0f 90       	pop	r0
    43b4:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    43b6:	80 91 b5 04 	lds	r24, 0x04B5
    43ba:	88 23       	and	r24, r24
    43bc:	31 f0       	breq	.+12     	; 0x43ca <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    43be:	8b 81       	ldd	r24, Y+3	; 0x03
    43c0:	9c 81       	ldd	r25, Y+4	; 0x04
    43c2:	00 97       	sbiw	r24, 0x00	; 0
    43c4:	11 f4       	brne	.+4      	; 0x43ca <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    43c6:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
			}
		}
	}
    43ca:	26 96       	adiw	r28, 0x06	; 6
    43cc:	0f b6       	in	r0, 0x3f	; 63
    43ce:	f8 94       	cli
    43d0:	de bf       	out	0x3e, r29	; 62
    43d2:	0f be       	out	0x3f, r0	; 63
    43d4:	cd bf       	out	0x3d, r28	; 61
    43d6:	cf 91       	pop	r28
    43d8:	df 91       	pop	r29
    43da:	08 95       	ret

000043dc <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    43dc:	df 93       	push	r29
    43de:	cf 93       	push	r28
    43e0:	cd b7       	in	r28, 0x3d	; 61
    43e2:	de b7       	in	r29, 0x3e	; 62
    43e4:	28 97       	sbiw	r28, 0x08	; 8
    43e6:	0f b6       	in	r0, 0x3f	; 63
    43e8:	f8 94       	cli
    43ea:	de bf       	out	0x3e, r29	; 62
    43ec:	0f be       	out	0x3f, r0	; 63
    43ee:	cd bf       	out	0x3d, r28	; 61
    43f0:	9e 83       	std	Y+6, r25	; 0x06
    43f2:	8d 83       	std	Y+5, r24	; 0x05
    43f4:	78 87       	std	Y+8, r23	; 0x08
    43f6:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    43f8:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    43fa:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    43fe:	ed 81       	ldd	r30, Y+5	; 0x05
    4400:	fe 81       	ldd	r31, Y+6	; 0x06
    4402:	20 81       	ld	r18, Z
    4404:	31 81       	ldd	r19, Z+1	; 0x01
    4406:	8f 81       	ldd	r24, Y+7	; 0x07
    4408:	98 85       	ldd	r25, Y+8	; 0x08
    440a:	82 0f       	add	r24, r18
    440c:	93 1f       	adc	r25, r19
    440e:	9c 83       	std	Y+4, r25	; 0x04
    4410:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    4412:	ed 81       	ldd	r30, Y+5	; 0x05
    4414:	fe 81       	ldd	r31, Y+6	; 0x06
    4416:	20 81       	ld	r18, Z
    4418:	31 81       	ldd	r19, Z+1	; 0x01
    441a:	80 91 b1 04 	lds	r24, 0x04B1
    441e:	90 91 b2 04 	lds	r25, 0x04B2
    4422:	82 17       	cp	r24, r18
    4424:	93 07       	cpc	r25, r19
    4426:	a8 f4       	brcc	.+42     	; 0x4452 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    4428:	ed 81       	ldd	r30, Y+5	; 0x05
    442a:	fe 81       	ldd	r31, Y+6	; 0x06
    442c:	20 81       	ld	r18, Z
    442e:	31 81       	ldd	r19, Z+1	; 0x01
    4430:	8b 81       	ldd	r24, Y+3	; 0x03
    4432:	9c 81       	ldd	r25, Y+4	; 0x04
    4434:	82 17       	cp	r24, r18
    4436:	93 07       	cpc	r25, r19
    4438:	00 f5       	brcc	.+64     	; 0x447a <vTaskDelayUntil+0x9e>
    443a:	20 91 b1 04 	lds	r18, 0x04B1
    443e:	30 91 b2 04 	lds	r19, 0x04B2
    4442:	8b 81       	ldd	r24, Y+3	; 0x03
    4444:	9c 81       	ldd	r25, Y+4	; 0x04
    4446:	28 17       	cp	r18, r24
    4448:	39 07       	cpc	r19, r25
    444a:	b8 f4       	brcc	.+46     	; 0x447a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    444c:	81 e0       	ldi	r24, 0x01	; 1
    444e:	89 83       	std	Y+1, r24	; 0x01
    4450:	14 c0       	rjmp	.+40     	; 0x447a <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    4452:	ed 81       	ldd	r30, Y+5	; 0x05
    4454:	fe 81       	ldd	r31, Y+6	; 0x06
    4456:	20 81       	ld	r18, Z
    4458:	31 81       	ldd	r19, Z+1	; 0x01
    445a:	8b 81       	ldd	r24, Y+3	; 0x03
    445c:	9c 81       	ldd	r25, Y+4	; 0x04
    445e:	82 17       	cp	r24, r18
    4460:	93 07       	cpc	r25, r19
    4462:	48 f0       	brcs	.+18     	; 0x4476 <vTaskDelayUntil+0x9a>
    4464:	20 91 b1 04 	lds	r18, 0x04B1
    4468:	30 91 b2 04 	lds	r19, 0x04B2
    446c:	8b 81       	ldd	r24, Y+3	; 0x03
    446e:	9c 81       	ldd	r25, Y+4	; 0x04
    4470:	28 17       	cp	r18, r24
    4472:	39 07       	cpc	r19, r25
    4474:	10 f4       	brcc	.+4      	; 0x447a <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4476:	81 e0       	ldi	r24, 0x01	; 1
    4478:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    447a:	ed 81       	ldd	r30, Y+5	; 0x05
    447c:	fe 81       	ldd	r31, Y+6	; 0x06
    447e:	8b 81       	ldd	r24, Y+3	; 0x03
    4480:	9c 81       	ldd	r25, Y+4	; 0x04
    4482:	91 83       	std	Z+1, r25	; 0x01
    4484:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    4486:	89 81       	ldd	r24, Y+1	; 0x01
    4488:	88 23       	and	r24, r24
    448a:	59 f0       	breq	.+22     	; 0x44a2 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    448c:	80 91 ad 04 	lds	r24, 0x04AD
    4490:	90 91 ae 04 	lds	r25, 0x04AE
    4494:	02 96       	adiw	r24, 0x02	; 2
    4496:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    449a:	8b 81       	ldd	r24, Y+3	; 0x03
    449c:	9c 81       	ldd	r25, Y+4	; 0x04
    449e:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    44a2:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
    44a6:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    44a8:	8a 81       	ldd	r24, Y+2	; 0x02
    44aa:	88 23       	and	r24, r24
    44ac:	11 f4       	brne	.+4      	; 0x44b2 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    44ae:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
		}
	}
    44b2:	28 96       	adiw	r28, 0x08	; 8
    44b4:	0f b6       	in	r0, 0x3f	; 63
    44b6:	f8 94       	cli
    44b8:	de bf       	out	0x3e, r29	; 62
    44ba:	0f be       	out	0x3f, r0	; 63
    44bc:	cd bf       	out	0x3d, r28	; 61
    44be:	cf 91       	pop	r28
    44c0:	df 91       	pop	r29
    44c2:	08 95       	ret

000044c4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    44c4:	df 93       	push	r29
    44c6:	cf 93       	push	r28
    44c8:	00 d0       	rcall	.+0      	; 0x44ca <vTaskDelay+0x6>
    44ca:	00 d0       	rcall	.+0      	; 0x44cc <vTaskDelay+0x8>
    44cc:	0f 92       	push	r0
    44ce:	cd b7       	in	r28, 0x3d	; 61
    44d0:	de b7       	in	r29, 0x3e	; 62
    44d2:	9d 83       	std	Y+5, r25	; 0x05
    44d4:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    44d6:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    44d8:	8c 81       	ldd	r24, Y+4	; 0x04
    44da:	9d 81       	ldd	r25, Y+5	; 0x05
    44dc:	00 97       	sbiw	r24, 0x00	; 0
    44de:	d1 f0       	breq	.+52     	; 0x4514 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    44e0:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    44e4:	20 91 b1 04 	lds	r18, 0x04B1
    44e8:	30 91 b2 04 	lds	r19, 0x04B2
    44ec:	8c 81       	ldd	r24, Y+4	; 0x04
    44ee:	9d 81       	ldd	r25, Y+5	; 0x05
    44f0:	82 0f       	add	r24, r18
    44f2:	93 1f       	adc	r25, r19
    44f4:	9b 83       	std	Y+3, r25	; 0x03
    44f6:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    44f8:	80 91 ad 04 	lds	r24, 0x04AD
    44fc:	90 91 ae 04 	lds	r25, 0x04AE
    4500:	02 96       	adiw	r24, 0x02	; 2
    4502:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4506:	8a 81       	ldd	r24, Y+2	; 0x02
    4508:	9b 81       	ldd	r25, Y+3	; 0x03
    450a:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    450e:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>
    4512:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    4514:	89 81       	ldd	r24, Y+1	; 0x01
    4516:	88 23       	and	r24, r24
    4518:	11 f4       	brne	.+4      	; 0x451e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    451a:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
		}
	}
    451e:	0f 90       	pop	r0
    4520:	0f 90       	pop	r0
    4522:	0f 90       	pop	r0
    4524:	0f 90       	pop	r0
    4526:	0f 90       	pop	r0
    4528:	cf 91       	pop	r28
    452a:	df 91       	pop	r29
    452c:	08 95       	ret

0000452e <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    452e:	af 92       	push	r10
    4530:	bf 92       	push	r11
    4532:	cf 92       	push	r12
    4534:	df 92       	push	r13
    4536:	ef 92       	push	r14
    4538:	ff 92       	push	r15
    453a:	0f 93       	push	r16
    453c:	df 93       	push	r29
    453e:	cf 93       	push	r28
    4540:	0f 92       	push	r0
    4542:	cd b7       	in	r28, 0x3d	; 61
    4544:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4546:	26 e7       	ldi	r18, 0x76	; 118
    4548:	30 e0       	ldi	r19, 0x00	; 0
    454a:	8e ef       	ldi	r24, 0xFE	; 254
    454c:	95 e2       	ldi	r25, 0x25	; 37
    454e:	b9 01       	movw	r22, r18
    4550:	45 e5       	ldi	r20, 0x55	; 85
    4552:	50 e0       	ldi	r21, 0x00	; 0
    4554:	20 e0       	ldi	r18, 0x00	; 0
    4556:	30 e0       	ldi	r19, 0x00	; 0
    4558:	00 e0       	ldi	r16, 0x00	; 0
    455a:	ee 24       	eor	r14, r14
    455c:	ff 24       	eor	r15, r15
    455e:	cc 24       	eor	r12, r12
    4560:	dd 24       	eor	r13, r13
    4562:	aa 24       	eor	r10, r10
    4564:	bb 24       	eor	r11, r11
    4566:	0e 94 9e 20 	call	0x413c	; 0x413c <xTaskGenericCreate>
    456a:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    456c:	89 81       	ldd	r24, Y+1	; 0x01
    456e:	81 30       	cpi	r24, 0x01	; 1
    4570:	51 f4       	brne	.+20     	; 0x4586 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    4572:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    4574:	81 e0       	ldi	r24, 0x01	; 1
    4576:	80 93 b5 04 	sts	0x04B5, r24
		xTickCount = ( portTickType ) 0U;
    457a:	10 92 b2 04 	sts	0x04B2, r1
    457e:	10 92 b1 04 	sts	0x04B1, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    4582:	0e 94 ce 1a 	call	0x359c	; 0x359c <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    4586:	0f 90       	pop	r0
    4588:	cf 91       	pop	r28
    458a:	df 91       	pop	r29
    458c:	0f 91       	pop	r16
    458e:	ff 90       	pop	r15
    4590:	ef 90       	pop	r14
    4592:	df 90       	pop	r13
    4594:	cf 90       	pop	r12
    4596:	bf 90       	pop	r11
    4598:	af 90       	pop	r10
    459a:	08 95       	ret

0000459c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    459c:	df 93       	push	r29
    459e:	cf 93       	push	r28
    45a0:	cd b7       	in	r28, 0x3d	; 61
    45a2:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    45a4:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    45a6:	10 92 b5 04 	sts	0x04B5, r1
	vPortEndScheduler();
    45aa:	0e 94 03 1b 	call	0x3606	; 0x3606 <vPortEndScheduler>
}
    45ae:	cf 91       	pop	r28
    45b0:	df 91       	pop	r29
    45b2:	08 95       	ret

000045b4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    45b4:	df 93       	push	r29
    45b6:	cf 93       	push	r28
    45b8:	cd b7       	in	r28, 0x3d	; 61
    45ba:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    45bc:	80 91 b6 04 	lds	r24, 0x04B6
    45c0:	8f 5f       	subi	r24, 0xFF	; 255
    45c2:	80 93 b6 04 	sts	0x04B6, r24
}
    45c6:	cf 91       	pop	r28
    45c8:	df 91       	pop	r29
    45ca:	08 95       	ret

000045cc <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    45cc:	df 93       	push	r29
    45ce:	cf 93       	push	r28
    45d0:	00 d0       	rcall	.+0      	; 0x45d2 <xTaskResumeAll+0x6>
    45d2:	00 d0       	rcall	.+0      	; 0x45d4 <xTaskResumeAll+0x8>
    45d4:	cd b7       	in	r28, 0x3d	; 61
    45d6:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    45d8:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    45da:	0f b6       	in	r0, 0x3f	; 63
    45dc:	f8 94       	cli
    45de:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    45e0:	80 91 b6 04 	lds	r24, 0x04B6
    45e4:	81 50       	subi	r24, 0x01	; 1
    45e6:	80 93 b6 04 	sts	0x04B6, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    45ea:	80 91 b6 04 	lds	r24, 0x04B6
    45ee:	88 23       	and	r24, r24
    45f0:	09 f0       	breq	.+2      	; 0x45f4 <xTaskResumeAll+0x28>
    45f2:	6c c0       	rjmp	.+216    	; 0x46cc <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    45f4:	80 91 b0 04 	lds	r24, 0x04B0
    45f8:	88 23       	and	r24, r24
    45fa:	09 f4       	brne	.+2      	; 0x45fe <xTaskResumeAll+0x32>
    45fc:	67 c0       	rjmp	.+206    	; 0x46cc <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    45fe:	19 82       	std	Y+1, r1	; 0x01
    4600:	41 c0       	rjmp	.+130    	; 0x4684 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4602:	e0 91 03 05 	lds	r30, 0x0503
    4606:	f0 91 04 05 	lds	r31, 0x0504
    460a:	86 81       	ldd	r24, Z+6	; 0x06
    460c:	97 81       	ldd	r25, Z+7	; 0x07
    460e:	9c 83       	std	Y+4, r25	; 0x04
    4610:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    4612:	8b 81       	ldd	r24, Y+3	; 0x03
    4614:	9c 81       	ldd	r25, Y+4	; 0x04
    4616:	0c 96       	adiw	r24, 0x0c	; 12
    4618:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    461c:	8b 81       	ldd	r24, Y+3	; 0x03
    461e:	9c 81       	ldd	r25, Y+4	; 0x04
    4620:	02 96       	adiw	r24, 0x02	; 2
    4622:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4626:	eb 81       	ldd	r30, Y+3	; 0x03
    4628:	fc 81       	ldd	r31, Y+4	; 0x04
    462a:	96 89       	ldd	r25, Z+22	; 0x16
    462c:	80 91 b4 04 	lds	r24, 0x04B4
    4630:	89 17       	cp	r24, r25
    4632:	28 f4       	brcc	.+10     	; 0x463e <xTaskResumeAll+0x72>
    4634:	eb 81       	ldd	r30, Y+3	; 0x03
    4636:	fc 81       	ldd	r31, Y+4	; 0x04
    4638:	86 89       	ldd	r24, Z+22	; 0x16
    463a:	80 93 b4 04 	sts	0x04B4, r24
    463e:	eb 81       	ldd	r30, Y+3	; 0x03
    4640:	fc 81       	ldd	r31, Y+4	; 0x04
    4642:	86 89       	ldd	r24, Z+22	; 0x16
    4644:	28 2f       	mov	r18, r24
    4646:	30 e0       	ldi	r19, 0x00	; 0
    4648:	c9 01       	movw	r24, r18
    464a:	88 0f       	add	r24, r24
    464c:	99 1f       	adc	r25, r25
    464e:	88 0f       	add	r24, r24
    4650:	99 1f       	adc	r25, r25
    4652:	88 0f       	add	r24, r24
    4654:	99 1f       	adc	r25, r25
    4656:	82 0f       	add	r24, r18
    4658:	93 1f       	adc	r25, r19
    465a:	85 54       	subi	r24, 0x45	; 69
    465c:	9b 4f       	sbci	r25, 0xFB	; 251
    465e:	2b 81       	ldd	r18, Y+3	; 0x03
    4660:	3c 81       	ldd	r19, Y+4	; 0x04
    4662:	2e 5f       	subi	r18, 0xFE	; 254
    4664:	3f 4f       	sbci	r19, 0xFF	; 255
    4666:	b9 01       	movw	r22, r18
    4668:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    466c:	eb 81       	ldd	r30, Y+3	; 0x03
    466e:	fc 81       	ldd	r31, Y+4	; 0x04
    4670:	96 89       	ldd	r25, Z+22	; 0x16
    4672:	e0 91 ad 04 	lds	r30, 0x04AD
    4676:	f0 91 ae 04 	lds	r31, 0x04AE
    467a:	86 89       	ldd	r24, Z+22	; 0x16
    467c:	98 17       	cp	r25, r24
    467e:	10 f0       	brcs	.+4      	; 0x4684 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    4680:	81 e0       	ldi	r24, 0x01	; 1
    4682:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4684:	80 91 fe 04 	lds	r24, 0x04FE
    4688:	88 23       	and	r24, r24
    468a:	09 f0       	breq	.+2      	; 0x468e <xTaskResumeAll+0xc2>
    468c:	ba cf       	rjmp	.-140    	; 0x4602 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    468e:	80 91 b7 04 	lds	r24, 0x04B7
    4692:	88 23       	and	r24, r24
    4694:	71 f0       	breq	.+28     	; 0x46b2 <xTaskResumeAll+0xe6>
    4696:	07 c0       	rjmp	.+14     	; 0x46a6 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4698:	0e 94 a5 23 	call	0x474a	; 0x474a <vTaskIncrementTick>
						--uxMissedTicks;
    469c:	80 91 b7 04 	lds	r24, 0x04B7
    46a0:	81 50       	subi	r24, 0x01	; 1
    46a2:	80 93 b7 04 	sts	0x04B7, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    46a6:	80 91 b7 04 	lds	r24, 0x04B7
    46aa:	88 23       	and	r24, r24
    46ac:	a9 f7       	brne	.-22     	; 0x4698 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    46ae:	81 e0       	ldi	r24, 0x01	; 1
    46b0:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    46b2:	89 81       	ldd	r24, Y+1	; 0x01
    46b4:	81 30       	cpi	r24, 0x01	; 1
    46b6:	21 f0       	breq	.+8      	; 0x46c0 <xTaskResumeAll+0xf4>
    46b8:	80 91 b8 04 	lds	r24, 0x04B8
    46bc:	81 30       	cpi	r24, 0x01	; 1
    46be:	31 f4       	brne	.+12     	; 0x46cc <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    46c0:	81 e0       	ldi	r24, 0x01	; 1
    46c2:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    46c4:	10 92 b8 04 	sts	0x04B8, r1
					portYIELD_WITHIN_API();
    46c8:	0e 94 0a 1b 	call	0x3614	; 0x3614 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    46cc:	0f 90       	pop	r0
    46ce:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    46d0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    46d2:	0f 90       	pop	r0
    46d4:	0f 90       	pop	r0
    46d6:	0f 90       	pop	r0
    46d8:	0f 90       	pop	r0
    46da:	cf 91       	pop	r28
    46dc:	df 91       	pop	r29
    46de:	08 95       	ret

000046e0 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    46e0:	df 93       	push	r29
    46e2:	cf 93       	push	r28
    46e4:	00 d0       	rcall	.+0      	; 0x46e6 <xTaskGetTickCount+0x6>
    46e6:	cd b7       	in	r28, 0x3d	; 61
    46e8:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    46ea:	0f b6       	in	r0, 0x3f	; 63
    46ec:	f8 94       	cli
    46ee:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    46f0:	80 91 b1 04 	lds	r24, 0x04B1
    46f4:	90 91 b2 04 	lds	r25, 0x04B2
    46f8:	9a 83       	std	Y+2, r25	; 0x02
    46fa:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    46fc:	0f 90       	pop	r0
    46fe:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4700:	89 81       	ldd	r24, Y+1	; 0x01
    4702:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4704:	0f 90       	pop	r0
    4706:	0f 90       	pop	r0
    4708:	cf 91       	pop	r28
    470a:	df 91       	pop	r29
    470c:	08 95       	ret

0000470e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    470e:	df 93       	push	r29
    4710:	cf 93       	push	r28
    4712:	00 d0       	rcall	.+0      	; 0x4714 <xTaskGetTickCountFromISR+0x6>
    4714:	0f 92       	push	r0
    4716:	cd b7       	in	r28, 0x3d	; 61
    4718:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    471a:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    471c:	80 91 b1 04 	lds	r24, 0x04B1
    4720:	90 91 b2 04 	lds	r25, 0x04B2
    4724:	9b 83       	std	Y+3, r25	; 0x03
    4726:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4728:	8a 81       	ldd	r24, Y+2	; 0x02
    472a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    472c:	0f 90       	pop	r0
    472e:	0f 90       	pop	r0
    4730:	0f 90       	pop	r0
    4732:	cf 91       	pop	r28
    4734:	df 91       	pop	r29
    4736:	08 95       	ret

00004738 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4738:	df 93       	push	r29
    473a:	cf 93       	push	r28
    473c:	cd b7       	in	r28, 0x3d	; 61
    473e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4740:	80 91 b0 04 	lds	r24, 0x04B0
}
    4744:	cf 91       	pop	r28
    4746:	df 91       	pop	r29
    4748:	08 95       	ret

0000474a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    474a:	df 93       	push	r29
    474c:	cf 93       	push	r28
    474e:	00 d0       	rcall	.+0      	; 0x4750 <vTaskIncrementTick+0x6>
    4750:	00 d0       	rcall	.+0      	; 0x4752 <vTaskIncrementTick+0x8>
    4752:	00 d0       	rcall	.+0      	; 0x4754 <vTaskIncrementTick+0xa>
    4754:	cd b7       	in	r28, 0x3d	; 61
    4756:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4758:	80 91 b6 04 	lds	r24, 0x04B6
    475c:	88 23       	and	r24, r24
    475e:	09 f0       	breq	.+2      	; 0x4762 <vTaskIncrementTick+0x18>
    4760:	bb c0       	rjmp	.+374    	; 0x48d8 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    4762:	80 91 b1 04 	lds	r24, 0x04B1
    4766:	90 91 b2 04 	lds	r25, 0x04B2
    476a:	01 96       	adiw	r24, 0x01	; 1
    476c:	90 93 b2 04 	sts	0x04B2, r25
    4770:	80 93 b1 04 	sts	0x04B1, r24
		if( xTickCount == ( portTickType ) 0U )
    4774:	80 91 b1 04 	lds	r24, 0x04B1
    4778:	90 91 b2 04 	lds	r25, 0x04B2
    477c:	00 97       	sbiw	r24, 0x00	; 0
    477e:	d1 f5       	brne	.+116    	; 0x47f4 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4780:	80 91 fa 04 	lds	r24, 0x04FA
    4784:	90 91 fb 04 	lds	r25, 0x04FB
    4788:	9c 83       	std	Y+4, r25	; 0x04
    478a:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    478c:	80 91 fc 04 	lds	r24, 0x04FC
    4790:	90 91 fd 04 	lds	r25, 0x04FD
    4794:	90 93 fb 04 	sts	0x04FB, r25
    4798:	80 93 fa 04 	sts	0x04FA, r24
			pxOverflowDelayedTaskList = pxTemp;
    479c:	8b 81       	ldd	r24, Y+3	; 0x03
    479e:	9c 81       	ldd	r25, Y+4	; 0x04
    47a0:	90 93 fd 04 	sts	0x04FD, r25
    47a4:	80 93 fc 04 	sts	0x04FC, r24
			xNumOfOverflows++;
    47a8:	80 91 b9 04 	lds	r24, 0x04B9
    47ac:	8f 5f       	subi	r24, 0xFF	; 255
    47ae:	80 93 b9 04 	sts	0x04B9, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    47b2:	e0 91 fa 04 	lds	r30, 0x04FA
    47b6:	f0 91 fb 04 	lds	r31, 0x04FB
    47ba:	80 81       	ld	r24, Z
    47bc:	88 23       	and	r24, r24
    47be:	39 f4       	brne	.+14     	; 0x47ce <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    47c0:	8f ef       	ldi	r24, 0xFF	; 255
    47c2:	9f ef       	ldi	r25, 0xFF	; 255
    47c4:	90 93 84 00 	sts	0x0084, r25
    47c8:	80 93 83 00 	sts	0x0083, r24
    47cc:	13 c0       	rjmp	.+38     	; 0x47f4 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    47ce:	e0 91 fa 04 	lds	r30, 0x04FA
    47d2:	f0 91 fb 04 	lds	r31, 0x04FB
    47d6:	05 80       	ldd	r0, Z+5	; 0x05
    47d8:	f6 81       	ldd	r31, Z+6	; 0x06
    47da:	e0 2d       	mov	r30, r0
    47dc:	86 81       	ldd	r24, Z+6	; 0x06
    47de:	97 81       	ldd	r25, Z+7	; 0x07
    47e0:	9e 83       	std	Y+6, r25	; 0x06
    47e2:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    47e4:	ed 81       	ldd	r30, Y+5	; 0x05
    47e6:	fe 81       	ldd	r31, Y+6	; 0x06
    47e8:	82 81       	ldd	r24, Z+2	; 0x02
    47ea:	93 81       	ldd	r25, Z+3	; 0x03
    47ec:	90 93 84 00 	sts	0x0084, r25
    47f0:	80 93 83 00 	sts	0x0083, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    47f4:	20 91 b1 04 	lds	r18, 0x04B1
    47f8:	30 91 b2 04 	lds	r19, 0x04B2
    47fc:	80 91 83 00 	lds	r24, 0x0083
    4800:	90 91 84 00 	lds	r25, 0x0084
    4804:	28 17       	cp	r18, r24
    4806:	39 07       	cpc	r19, r25
    4808:	08 f4       	brcc	.+2      	; 0x480c <vTaskIncrementTick+0xc2>
    480a:	6b c0       	rjmp	.+214    	; 0x48e2 <vTaskIncrementTick+0x198>
    480c:	e0 91 fa 04 	lds	r30, 0x04FA
    4810:	f0 91 fb 04 	lds	r31, 0x04FB
    4814:	80 81       	ld	r24, Z
    4816:	88 23       	and	r24, r24
    4818:	39 f4       	brne	.+14     	; 0x4828 <vTaskIncrementTick+0xde>
    481a:	8f ef       	ldi	r24, 0xFF	; 255
    481c:	9f ef       	ldi	r25, 0xFF	; 255
    481e:	90 93 84 00 	sts	0x0084, r25
    4822:	80 93 83 00 	sts	0x0083, r24
    4826:	5d c0       	rjmp	.+186    	; 0x48e2 <vTaskIncrementTick+0x198>
    4828:	e0 91 fa 04 	lds	r30, 0x04FA
    482c:	f0 91 fb 04 	lds	r31, 0x04FB
    4830:	05 80       	ldd	r0, Z+5	; 0x05
    4832:	f6 81       	ldd	r31, Z+6	; 0x06
    4834:	e0 2d       	mov	r30, r0
    4836:	86 81       	ldd	r24, Z+6	; 0x06
    4838:	97 81       	ldd	r25, Z+7	; 0x07
    483a:	9e 83       	std	Y+6, r25	; 0x06
    483c:	8d 83       	std	Y+5, r24	; 0x05
    483e:	ed 81       	ldd	r30, Y+5	; 0x05
    4840:	fe 81       	ldd	r31, Y+6	; 0x06
    4842:	82 81       	ldd	r24, Z+2	; 0x02
    4844:	93 81       	ldd	r25, Z+3	; 0x03
    4846:	9a 83       	std	Y+2, r25	; 0x02
    4848:	89 83       	std	Y+1, r24	; 0x01
    484a:	20 91 b1 04 	lds	r18, 0x04B1
    484e:	30 91 b2 04 	lds	r19, 0x04B2
    4852:	89 81       	ldd	r24, Y+1	; 0x01
    4854:	9a 81       	ldd	r25, Y+2	; 0x02
    4856:	28 17       	cp	r18, r24
    4858:	39 07       	cpc	r19, r25
    485a:	38 f4       	brcc	.+14     	; 0x486a <vTaskIncrementTick+0x120>
    485c:	89 81       	ldd	r24, Y+1	; 0x01
    485e:	9a 81       	ldd	r25, Y+2	; 0x02
    4860:	90 93 84 00 	sts	0x0084, r25
    4864:	80 93 83 00 	sts	0x0083, r24
    4868:	3c c0       	rjmp	.+120    	; 0x48e2 <vTaskIncrementTick+0x198>
    486a:	8d 81       	ldd	r24, Y+5	; 0x05
    486c:	9e 81       	ldd	r25, Y+6	; 0x06
    486e:	02 96       	adiw	r24, 0x02	; 2
    4870:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
    4874:	ed 81       	ldd	r30, Y+5	; 0x05
    4876:	fe 81       	ldd	r31, Y+6	; 0x06
    4878:	84 89       	ldd	r24, Z+20	; 0x14
    487a:	95 89       	ldd	r25, Z+21	; 0x15
    487c:	00 97       	sbiw	r24, 0x00	; 0
    487e:	29 f0       	breq	.+10     	; 0x488a <vTaskIncrementTick+0x140>
    4880:	8d 81       	ldd	r24, Y+5	; 0x05
    4882:	9e 81       	ldd	r25, Y+6	; 0x06
    4884:	0c 96       	adiw	r24, 0x0c	; 12
    4886:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
    488a:	ed 81       	ldd	r30, Y+5	; 0x05
    488c:	fe 81       	ldd	r31, Y+6	; 0x06
    488e:	96 89       	ldd	r25, Z+22	; 0x16
    4890:	80 91 b4 04 	lds	r24, 0x04B4
    4894:	89 17       	cp	r24, r25
    4896:	28 f4       	brcc	.+10     	; 0x48a2 <vTaskIncrementTick+0x158>
    4898:	ed 81       	ldd	r30, Y+5	; 0x05
    489a:	fe 81       	ldd	r31, Y+6	; 0x06
    489c:	86 89       	ldd	r24, Z+22	; 0x16
    489e:	80 93 b4 04 	sts	0x04B4, r24
    48a2:	ed 81       	ldd	r30, Y+5	; 0x05
    48a4:	fe 81       	ldd	r31, Y+6	; 0x06
    48a6:	86 89       	ldd	r24, Z+22	; 0x16
    48a8:	28 2f       	mov	r18, r24
    48aa:	30 e0       	ldi	r19, 0x00	; 0
    48ac:	c9 01       	movw	r24, r18
    48ae:	88 0f       	add	r24, r24
    48b0:	99 1f       	adc	r25, r25
    48b2:	88 0f       	add	r24, r24
    48b4:	99 1f       	adc	r25, r25
    48b6:	88 0f       	add	r24, r24
    48b8:	99 1f       	adc	r25, r25
    48ba:	82 0f       	add	r24, r18
    48bc:	93 1f       	adc	r25, r19
    48be:	ac 01       	movw	r20, r24
    48c0:	45 54       	subi	r20, 0x45	; 69
    48c2:	5b 4f       	sbci	r21, 0xFB	; 251
    48c4:	8d 81       	ldd	r24, Y+5	; 0x05
    48c6:	9e 81       	ldd	r25, Y+6	; 0x06
    48c8:	9c 01       	movw	r18, r24
    48ca:	2e 5f       	subi	r18, 0xFE	; 254
    48cc:	3f 4f       	sbci	r19, 0xFF	; 255
    48ce:	ca 01       	movw	r24, r20
    48d0:	b9 01       	movw	r22, r18
    48d2:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>
    48d6:	9a cf       	rjmp	.-204    	; 0x480c <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    48d8:	80 91 b7 04 	lds	r24, 0x04B7
    48dc:	8f 5f       	subi	r24, 0xFF	; 255
    48de:	80 93 b7 04 	sts	0x04B7, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    48e2:	26 96       	adiw	r28, 0x06	; 6
    48e4:	0f b6       	in	r0, 0x3f	; 63
    48e6:	f8 94       	cli
    48e8:	de bf       	out	0x3e, r29	; 62
    48ea:	0f be       	out	0x3f, r0	; 63
    48ec:	cd bf       	out	0x3d, r28	; 61
    48ee:	cf 91       	pop	r28
    48f0:	df 91       	pop	r29
    48f2:	08 95       	ret

000048f4 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    48f4:	df 93       	push	r29
    48f6:	cf 93       	push	r28
    48f8:	00 d0       	rcall	.+0      	; 0x48fa <vTaskSwitchContext+0x6>
    48fa:	cd b7       	in	r28, 0x3d	; 61
    48fc:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    48fe:	80 91 b6 04 	lds	r24, 0x04B6
    4902:	88 23       	and	r24, r24
    4904:	49 f0       	breq	.+18     	; 0x4918 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    4906:	81 e0       	ldi	r24, 0x01	; 1
    4908:	80 93 b8 04 	sts	0x04B8, r24
    490c:	54 c0       	rjmp	.+168    	; 0x49b6 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    490e:	80 91 b4 04 	lds	r24, 0x04B4
    4912:	81 50       	subi	r24, 0x01	; 1
    4914:	80 93 b4 04 	sts	0x04B4, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    4918:	80 91 b4 04 	lds	r24, 0x04B4
    491c:	28 2f       	mov	r18, r24
    491e:	30 e0       	ldi	r19, 0x00	; 0
    4920:	c9 01       	movw	r24, r18
    4922:	88 0f       	add	r24, r24
    4924:	99 1f       	adc	r25, r25
    4926:	88 0f       	add	r24, r24
    4928:	99 1f       	adc	r25, r25
    492a:	88 0f       	add	r24, r24
    492c:	99 1f       	adc	r25, r25
    492e:	82 0f       	add	r24, r18
    4930:	93 1f       	adc	r25, r19
    4932:	fc 01       	movw	r30, r24
    4934:	e5 54       	subi	r30, 0x45	; 69
    4936:	fb 4f       	sbci	r31, 0xFB	; 251
    4938:	80 81       	ld	r24, Z
    493a:	88 23       	and	r24, r24
    493c:	41 f3       	breq	.-48     	; 0x490e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    493e:	80 91 b4 04 	lds	r24, 0x04B4
    4942:	28 2f       	mov	r18, r24
    4944:	30 e0       	ldi	r19, 0x00	; 0
    4946:	c9 01       	movw	r24, r18
    4948:	88 0f       	add	r24, r24
    494a:	99 1f       	adc	r25, r25
    494c:	88 0f       	add	r24, r24
    494e:	99 1f       	adc	r25, r25
    4950:	88 0f       	add	r24, r24
    4952:	99 1f       	adc	r25, r25
    4954:	82 0f       	add	r24, r18
    4956:	93 1f       	adc	r25, r19
    4958:	85 54       	subi	r24, 0x45	; 69
    495a:	9b 4f       	sbci	r25, 0xFB	; 251
    495c:	9a 83       	std	Y+2, r25	; 0x02
    495e:	89 83       	std	Y+1, r24	; 0x01
    4960:	e9 81       	ldd	r30, Y+1	; 0x01
    4962:	fa 81       	ldd	r31, Y+2	; 0x02
    4964:	01 80       	ldd	r0, Z+1	; 0x01
    4966:	f2 81       	ldd	r31, Z+2	; 0x02
    4968:	e0 2d       	mov	r30, r0
    496a:	82 81       	ldd	r24, Z+2	; 0x02
    496c:	93 81       	ldd	r25, Z+3	; 0x03
    496e:	e9 81       	ldd	r30, Y+1	; 0x01
    4970:	fa 81       	ldd	r31, Y+2	; 0x02
    4972:	92 83       	std	Z+2, r25	; 0x02
    4974:	81 83       	std	Z+1, r24	; 0x01
    4976:	e9 81       	ldd	r30, Y+1	; 0x01
    4978:	fa 81       	ldd	r31, Y+2	; 0x02
    497a:	21 81       	ldd	r18, Z+1	; 0x01
    497c:	32 81       	ldd	r19, Z+2	; 0x02
    497e:	89 81       	ldd	r24, Y+1	; 0x01
    4980:	9a 81       	ldd	r25, Y+2	; 0x02
    4982:	03 96       	adiw	r24, 0x03	; 3
    4984:	28 17       	cp	r18, r24
    4986:	39 07       	cpc	r19, r25
    4988:	59 f4       	brne	.+22     	; 0x49a0 <vTaskSwitchContext+0xac>
    498a:	e9 81       	ldd	r30, Y+1	; 0x01
    498c:	fa 81       	ldd	r31, Y+2	; 0x02
    498e:	01 80       	ldd	r0, Z+1	; 0x01
    4990:	f2 81       	ldd	r31, Z+2	; 0x02
    4992:	e0 2d       	mov	r30, r0
    4994:	82 81       	ldd	r24, Z+2	; 0x02
    4996:	93 81       	ldd	r25, Z+3	; 0x03
    4998:	e9 81       	ldd	r30, Y+1	; 0x01
    499a:	fa 81       	ldd	r31, Y+2	; 0x02
    499c:	92 83       	std	Z+2, r25	; 0x02
    499e:	81 83       	std	Z+1, r24	; 0x01
    49a0:	e9 81       	ldd	r30, Y+1	; 0x01
    49a2:	fa 81       	ldd	r31, Y+2	; 0x02
    49a4:	01 80       	ldd	r0, Z+1	; 0x01
    49a6:	f2 81       	ldd	r31, Z+2	; 0x02
    49a8:	e0 2d       	mov	r30, r0
    49aa:	86 81       	ldd	r24, Z+6	; 0x06
    49ac:	97 81       	ldd	r25, Z+7	; 0x07
    49ae:	90 93 ae 04 	sts	0x04AE, r25
    49b2:	80 93 ad 04 	sts	0x04AD, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    49b6:	0f 90       	pop	r0
    49b8:	0f 90       	pop	r0
    49ba:	cf 91       	pop	r28
    49bc:	df 91       	pop	r29
    49be:	08 95       	ret

000049c0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    49c0:	df 93       	push	r29
    49c2:	cf 93       	push	r28
    49c4:	00 d0       	rcall	.+0      	; 0x49c6 <vTaskPlaceOnEventList+0x6>
    49c6:	00 d0       	rcall	.+0      	; 0x49c8 <vTaskPlaceOnEventList+0x8>
    49c8:	00 d0       	rcall	.+0      	; 0x49ca <vTaskPlaceOnEventList+0xa>
    49ca:	cd b7       	in	r28, 0x3d	; 61
    49cc:	de b7       	in	r29, 0x3e	; 62
    49ce:	9c 83       	std	Y+4, r25	; 0x04
    49d0:	8b 83       	std	Y+3, r24	; 0x03
    49d2:	7e 83       	std	Y+6, r23	; 0x06
    49d4:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    49d6:	4b 81       	ldd	r20, Y+3	; 0x03
    49d8:	5c 81       	ldd	r21, Y+4	; 0x04
    49da:	80 91 ad 04 	lds	r24, 0x04AD
    49de:	90 91 ae 04 	lds	r25, 0x04AE
    49e2:	9c 01       	movw	r18, r24
    49e4:	24 5f       	subi	r18, 0xF4	; 244
    49e6:	3f 4f       	sbci	r19, 0xFF	; 255
    49e8:	ca 01       	movw	r24, r20
    49ea:	b9 01       	movw	r22, r18
    49ec:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    49f0:	80 91 ad 04 	lds	r24, 0x04AD
    49f4:	90 91 ae 04 	lds	r25, 0x04AE
    49f8:	02 96       	adiw	r24, 0x02	; 2
    49fa:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    49fe:	20 91 b1 04 	lds	r18, 0x04B1
    4a02:	30 91 b2 04 	lds	r19, 0x04B2
    4a06:	8d 81       	ldd	r24, Y+5	; 0x05
    4a08:	9e 81       	ldd	r25, Y+6	; 0x06
    4a0a:	82 0f       	add	r24, r18
    4a0c:	93 1f       	adc	r25, r19
    4a0e:	9a 83       	std	Y+2, r25	; 0x02
    4a10:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4a12:	89 81       	ldd	r24, Y+1	; 0x01
    4a14:	9a 81       	ldd	r25, Y+2	; 0x02
    4a16:	0e 94 da 26 	call	0x4db4	; 0x4db4 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    4a1a:	26 96       	adiw	r28, 0x06	; 6
    4a1c:	0f b6       	in	r0, 0x3f	; 63
    4a1e:	f8 94       	cli
    4a20:	de bf       	out	0x3e, r29	; 62
    4a22:	0f be       	out	0x3f, r0	; 63
    4a24:	cd bf       	out	0x3d, r28	; 61
    4a26:	cf 91       	pop	r28
    4a28:	df 91       	pop	r29
    4a2a:	08 95       	ret

00004a2c <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4a2c:	df 93       	push	r29
    4a2e:	cf 93       	push	r28
    4a30:	00 d0       	rcall	.+0      	; 0x4a32 <xTaskRemoveFromEventList+0x6>
    4a32:	00 d0       	rcall	.+0      	; 0x4a34 <xTaskRemoveFromEventList+0x8>
    4a34:	0f 92       	push	r0
    4a36:	cd b7       	in	r28, 0x3d	; 61
    4a38:	de b7       	in	r29, 0x3e	; 62
    4a3a:	9d 83       	std	Y+5, r25	; 0x05
    4a3c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4a3e:	ec 81       	ldd	r30, Y+4	; 0x04
    4a40:	fd 81       	ldd	r31, Y+5	; 0x05
    4a42:	05 80       	ldd	r0, Z+5	; 0x05
    4a44:	f6 81       	ldd	r31, Z+6	; 0x06
    4a46:	e0 2d       	mov	r30, r0
    4a48:	86 81       	ldd	r24, Z+6	; 0x06
    4a4a:	97 81       	ldd	r25, Z+7	; 0x07
    4a4c:	9b 83       	std	Y+3, r25	; 0x03
    4a4e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4a50:	8a 81       	ldd	r24, Y+2	; 0x02
    4a52:	9b 81       	ldd	r25, Y+3	; 0x03
    4a54:	0c 96       	adiw	r24, 0x0c	; 12
    4a56:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4a5a:	80 91 b6 04 	lds	r24, 0x04B6
    4a5e:	88 23       	and	r24, r24
    4a60:	61 f5       	brne	.+88     	; 0x4aba <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4a62:	8a 81       	ldd	r24, Y+2	; 0x02
    4a64:	9b 81       	ldd	r25, Y+3	; 0x03
    4a66:	02 96       	adiw	r24, 0x02	; 2
    4a68:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4a6c:	ea 81       	ldd	r30, Y+2	; 0x02
    4a6e:	fb 81       	ldd	r31, Y+3	; 0x03
    4a70:	96 89       	ldd	r25, Z+22	; 0x16
    4a72:	80 91 b4 04 	lds	r24, 0x04B4
    4a76:	89 17       	cp	r24, r25
    4a78:	28 f4       	brcc	.+10     	; 0x4a84 <xTaskRemoveFromEventList+0x58>
    4a7a:	ea 81       	ldd	r30, Y+2	; 0x02
    4a7c:	fb 81       	ldd	r31, Y+3	; 0x03
    4a7e:	86 89       	ldd	r24, Z+22	; 0x16
    4a80:	80 93 b4 04 	sts	0x04B4, r24
    4a84:	ea 81       	ldd	r30, Y+2	; 0x02
    4a86:	fb 81       	ldd	r31, Y+3	; 0x03
    4a88:	86 89       	ldd	r24, Z+22	; 0x16
    4a8a:	28 2f       	mov	r18, r24
    4a8c:	30 e0       	ldi	r19, 0x00	; 0
    4a8e:	c9 01       	movw	r24, r18
    4a90:	88 0f       	add	r24, r24
    4a92:	99 1f       	adc	r25, r25
    4a94:	88 0f       	add	r24, r24
    4a96:	99 1f       	adc	r25, r25
    4a98:	88 0f       	add	r24, r24
    4a9a:	99 1f       	adc	r25, r25
    4a9c:	82 0f       	add	r24, r18
    4a9e:	93 1f       	adc	r25, r19
    4aa0:	ac 01       	movw	r20, r24
    4aa2:	45 54       	subi	r20, 0x45	; 69
    4aa4:	5b 4f       	sbci	r21, 0xFB	; 251
    4aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    4aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    4aaa:	9c 01       	movw	r18, r24
    4aac:	2e 5f       	subi	r18, 0xFE	; 254
    4aae:	3f 4f       	sbci	r19, 0xFF	; 255
    4ab0:	ca 01       	movw	r24, r20
    4ab2:	b9 01       	movw	r22, r18
    4ab4:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>
    4ab8:	0a c0       	rjmp	.+20     	; 0x4ace <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4aba:	8a 81       	ldd	r24, Y+2	; 0x02
    4abc:	9b 81       	ldd	r25, Y+3	; 0x03
    4abe:	9c 01       	movw	r18, r24
    4ac0:	24 5f       	subi	r18, 0xF4	; 244
    4ac2:	3f 4f       	sbci	r19, 0xFF	; 255
    4ac4:	8e ef       	ldi	r24, 0xFE	; 254
    4ac6:	94 e0       	ldi	r25, 0x04	; 4
    4ac8:	b9 01       	movw	r22, r18
    4aca:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4ace:	ea 81       	ldd	r30, Y+2	; 0x02
    4ad0:	fb 81       	ldd	r31, Y+3	; 0x03
    4ad2:	96 89       	ldd	r25, Z+22	; 0x16
    4ad4:	e0 91 ad 04 	lds	r30, 0x04AD
    4ad8:	f0 91 ae 04 	lds	r31, 0x04AE
    4adc:	86 89       	ldd	r24, Z+22	; 0x16
    4ade:	98 17       	cp	r25, r24
    4ae0:	18 f0       	brcs	.+6      	; 0x4ae8 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4ae2:	81 e0       	ldi	r24, 0x01	; 1
    4ae4:	89 83       	std	Y+1, r24	; 0x01
    4ae6:	01 c0       	rjmp	.+2      	; 0x4aea <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4ae8:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4aea:	89 81       	ldd	r24, Y+1	; 0x01
}
    4aec:	0f 90       	pop	r0
    4aee:	0f 90       	pop	r0
    4af0:	0f 90       	pop	r0
    4af2:	0f 90       	pop	r0
    4af4:	0f 90       	pop	r0
    4af6:	cf 91       	pop	r28
    4af8:	df 91       	pop	r29
    4afa:	08 95       	ret

00004afc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4afc:	df 93       	push	r29
    4afe:	cf 93       	push	r28
    4b00:	00 d0       	rcall	.+0      	; 0x4b02 <vTaskSetTimeOutState+0x6>
    4b02:	cd b7       	in	r28, 0x3d	; 61
    4b04:	de b7       	in	r29, 0x3e	; 62
    4b06:	9a 83       	std	Y+2, r25	; 0x02
    4b08:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4b0a:	80 91 b9 04 	lds	r24, 0x04B9
    4b0e:	e9 81       	ldd	r30, Y+1	; 0x01
    4b10:	fa 81       	ldd	r31, Y+2	; 0x02
    4b12:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4b14:	80 91 b1 04 	lds	r24, 0x04B1
    4b18:	90 91 b2 04 	lds	r25, 0x04B2
    4b1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4b1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4b20:	92 83       	std	Z+2, r25	; 0x02
    4b22:	81 83       	std	Z+1, r24	; 0x01
}
    4b24:	0f 90       	pop	r0
    4b26:	0f 90       	pop	r0
    4b28:	cf 91       	pop	r28
    4b2a:	df 91       	pop	r29
    4b2c:	08 95       	ret

00004b2e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4b2e:	df 93       	push	r29
    4b30:	cf 93       	push	r28
    4b32:	00 d0       	rcall	.+0      	; 0x4b34 <xTaskCheckForTimeOut+0x6>
    4b34:	00 d0       	rcall	.+0      	; 0x4b36 <xTaskCheckForTimeOut+0x8>
    4b36:	0f 92       	push	r0
    4b38:	cd b7       	in	r28, 0x3d	; 61
    4b3a:	de b7       	in	r29, 0x3e	; 62
    4b3c:	9b 83       	std	Y+3, r25	; 0x03
    4b3e:	8a 83       	std	Y+2, r24	; 0x02
    4b40:	7d 83       	std	Y+5, r23	; 0x05
    4b42:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4b44:	0f b6       	in	r0, 0x3f	; 63
    4b46:	f8 94       	cli
    4b48:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4b4a:	ea 81       	ldd	r30, Y+2	; 0x02
    4b4c:	fb 81       	ldd	r31, Y+3	; 0x03
    4b4e:	90 81       	ld	r25, Z
    4b50:	80 91 b9 04 	lds	r24, 0x04B9
    4b54:	98 17       	cp	r25, r24
    4b56:	71 f0       	breq	.+28     	; 0x4b74 <xTaskCheckForTimeOut+0x46>
    4b58:	ea 81       	ldd	r30, Y+2	; 0x02
    4b5a:	fb 81       	ldd	r31, Y+3	; 0x03
    4b5c:	21 81       	ldd	r18, Z+1	; 0x01
    4b5e:	32 81       	ldd	r19, Z+2	; 0x02
    4b60:	80 91 b1 04 	lds	r24, 0x04B1
    4b64:	90 91 b2 04 	lds	r25, 0x04B2
    4b68:	82 17       	cp	r24, r18
    4b6a:	93 07       	cpc	r25, r19
    4b6c:	18 f0       	brcs	.+6      	; 0x4b74 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4b6e:	81 e0       	ldi	r24, 0x01	; 1
    4b70:	89 83       	std	Y+1, r24	; 0x01
    4b72:	2f c0       	rjmp	.+94     	; 0x4bd2 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4b74:	20 91 b1 04 	lds	r18, 0x04B1
    4b78:	30 91 b2 04 	lds	r19, 0x04B2
    4b7c:	ea 81       	ldd	r30, Y+2	; 0x02
    4b7e:	fb 81       	ldd	r31, Y+3	; 0x03
    4b80:	81 81       	ldd	r24, Z+1	; 0x01
    4b82:	92 81       	ldd	r25, Z+2	; 0x02
    4b84:	28 1b       	sub	r18, r24
    4b86:	39 0b       	sbc	r19, r25
    4b88:	ec 81       	ldd	r30, Y+4	; 0x04
    4b8a:	fd 81       	ldd	r31, Y+5	; 0x05
    4b8c:	80 81       	ld	r24, Z
    4b8e:	91 81       	ldd	r25, Z+1	; 0x01
    4b90:	28 17       	cp	r18, r24
    4b92:	39 07       	cpc	r19, r25
    4b94:	e0 f4       	brcc	.+56     	; 0x4bce <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4b96:	ec 81       	ldd	r30, Y+4	; 0x04
    4b98:	fd 81       	ldd	r31, Y+5	; 0x05
    4b9a:	40 81       	ld	r20, Z
    4b9c:	51 81       	ldd	r21, Z+1	; 0x01
    4b9e:	ea 81       	ldd	r30, Y+2	; 0x02
    4ba0:	fb 81       	ldd	r31, Y+3	; 0x03
    4ba2:	21 81       	ldd	r18, Z+1	; 0x01
    4ba4:	32 81       	ldd	r19, Z+2	; 0x02
    4ba6:	80 91 b1 04 	lds	r24, 0x04B1
    4baa:	90 91 b2 04 	lds	r25, 0x04B2
    4bae:	b9 01       	movw	r22, r18
    4bb0:	68 1b       	sub	r22, r24
    4bb2:	79 0b       	sbc	r23, r25
    4bb4:	cb 01       	movw	r24, r22
    4bb6:	84 0f       	add	r24, r20
    4bb8:	95 1f       	adc	r25, r21
    4bba:	ec 81       	ldd	r30, Y+4	; 0x04
    4bbc:	fd 81       	ldd	r31, Y+5	; 0x05
    4bbe:	91 83       	std	Z+1, r25	; 0x01
    4bc0:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4bc2:	8a 81       	ldd	r24, Y+2	; 0x02
    4bc4:	9b 81       	ldd	r25, Y+3	; 0x03
    4bc6:	0e 94 7e 25 	call	0x4afc	; 0x4afc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4bca:	19 82       	std	Y+1, r1	; 0x01
    4bcc:	02 c0       	rjmp	.+4      	; 0x4bd2 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    4bce:	81 e0       	ldi	r24, 0x01	; 1
    4bd0:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4bd2:	0f 90       	pop	r0
    4bd4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4bd6:	89 81       	ldd	r24, Y+1	; 0x01
}
    4bd8:	0f 90       	pop	r0
    4bda:	0f 90       	pop	r0
    4bdc:	0f 90       	pop	r0
    4bde:	0f 90       	pop	r0
    4be0:	0f 90       	pop	r0
    4be2:	cf 91       	pop	r28
    4be4:	df 91       	pop	r29
    4be6:	08 95       	ret

00004be8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4be8:	df 93       	push	r29
    4bea:	cf 93       	push	r28
    4bec:	cd b7       	in	r28, 0x3d	; 61
    4bee:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4bf0:	81 e0       	ldi	r24, 0x01	; 1
    4bf2:	80 93 b8 04 	sts	0x04B8, r24
}
    4bf6:	cf 91       	pop	r28
    4bf8:	df 91       	pop	r29
    4bfa:	08 95       	ret

00004bfc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4bfc:	df 93       	push	r29
    4bfe:	cf 93       	push	r28
    4c00:	00 d0       	rcall	.+0      	; 0x4c02 <prvIdleTask+0x6>
    4c02:	cd b7       	in	r28, 0x3d	; 61
    4c04:	de b7       	in	r29, 0x3e	; 62
    4c06:	9a 83       	std	Y+2, r25	; 0x02
    4c08:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4c0a:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <prvCheckTasksWaitingTermination>
    4c0e:	fd cf       	rjmp	.-6      	; 0x4c0a <prvIdleTask+0xe>

00004c10 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4c10:	0f 93       	push	r16
    4c12:	1f 93       	push	r17
    4c14:	df 93       	push	r29
    4c16:	cf 93       	push	r28
    4c18:	cd b7       	in	r28, 0x3d	; 61
    4c1a:	de b7       	in	r29, 0x3e	; 62
    4c1c:	29 97       	sbiw	r28, 0x09	; 9
    4c1e:	0f b6       	in	r0, 0x3f	; 63
    4c20:	f8 94       	cli
    4c22:	de bf       	out	0x3e, r29	; 62
    4c24:	0f be       	out	0x3f, r0	; 63
    4c26:	cd bf       	out	0x3d, r28	; 61
    4c28:	9a 83       	std	Y+2, r25	; 0x02
    4c2a:	89 83       	std	Y+1, r24	; 0x01
    4c2c:	7c 83       	std	Y+4, r23	; 0x04
    4c2e:	6b 83       	std	Y+3, r22	; 0x03
    4c30:	4d 83       	std	Y+5, r20	; 0x05
    4c32:	3f 83       	std	Y+7, r19	; 0x07
    4c34:	2e 83       	std	Y+6, r18	; 0x06
    4c36:	19 87       	std	Y+9, r17	; 0x09
    4c38:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4c3a:	89 81       	ldd	r24, Y+1	; 0x01
    4c3c:	9a 81       	ldd	r25, Y+2	; 0x02
    4c3e:	49 96       	adiw	r24, 0x19	; 25
    4c40:	2b 81       	ldd	r18, Y+3	; 0x03
    4c42:	3c 81       	ldd	r19, Y+4	; 0x04
    4c44:	b9 01       	movw	r22, r18
    4c46:	48 e0       	ldi	r20, 0x08	; 8
    4c48:	50 e0       	ldi	r21, 0x00	; 0
    4c4a:	0e 94 f2 27 	call	0x4fe4	; 0x4fe4 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4c4e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c50:	fa 81       	ldd	r31, Y+2	; 0x02
    4c52:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4c54:	8d 81       	ldd	r24, Y+5	; 0x05
    4c56:	85 30       	cpi	r24, 0x05	; 5
    4c58:	10 f0       	brcs	.+4      	; 0x4c5e <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4c5a:	84 e0       	ldi	r24, 0x04	; 4
    4c5c:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4c5e:	e9 81       	ldd	r30, Y+1	; 0x01
    4c60:	fa 81       	ldd	r31, Y+2	; 0x02
    4c62:	8d 81       	ldd	r24, Y+5	; 0x05
    4c64:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4c66:	89 81       	ldd	r24, Y+1	; 0x01
    4c68:	9a 81       	ldd	r25, Y+2	; 0x02
    4c6a:	02 96       	adiw	r24, 0x02	; 2
    4c6c:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4c70:	89 81       	ldd	r24, Y+1	; 0x01
    4c72:	9a 81       	ldd	r25, Y+2	; 0x02
    4c74:	0c 96       	adiw	r24, 0x0c	; 12
    4c76:	0e 94 2a 17 	call	0x2e54	; 0x2e54 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    4c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    4c7e:	89 81       	ldd	r24, Y+1	; 0x01
    4c80:	9a 81       	ldd	r25, Y+2	; 0x02
    4c82:	91 87       	std	Z+9, r25	; 0x09
    4c84:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    4c86:	8d 81       	ldd	r24, Y+5	; 0x05
    4c88:	28 2f       	mov	r18, r24
    4c8a:	30 e0       	ldi	r19, 0x00	; 0
    4c8c:	85 e0       	ldi	r24, 0x05	; 5
    4c8e:	90 e0       	ldi	r25, 0x00	; 0
    4c90:	82 1b       	sub	r24, r18
    4c92:	93 0b       	sbc	r25, r19
    4c94:	e9 81       	ldd	r30, Y+1	; 0x01
    4c96:	fa 81       	ldd	r31, Y+2	; 0x02
    4c98:	95 87       	std	Z+13, r25	; 0x0d
    4c9a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4c9c:	e9 81       	ldd	r30, Y+1	; 0x01
    4c9e:	fa 81       	ldd	r31, Y+2	; 0x02
    4ca0:	89 81       	ldd	r24, Y+1	; 0x01
    4ca2:	9a 81       	ldd	r25, Y+2	; 0x02
    4ca4:	93 8b       	std	Z+19, r25	; 0x13
    4ca6:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    4ca8:	29 96       	adiw	r28, 0x09	; 9
    4caa:	0f b6       	in	r0, 0x3f	; 63
    4cac:	f8 94       	cli
    4cae:	de bf       	out	0x3e, r29	; 62
    4cb0:	0f be       	out	0x3f, r0	; 63
    4cb2:	cd bf       	out	0x3d, r28	; 61
    4cb4:	cf 91       	pop	r28
    4cb6:	df 91       	pop	r29
    4cb8:	1f 91       	pop	r17
    4cba:	0f 91       	pop	r16
    4cbc:	08 95       	ret

00004cbe <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4cbe:	df 93       	push	r29
    4cc0:	cf 93       	push	r28
    4cc2:	0f 92       	push	r0
    4cc4:	cd b7       	in	r28, 0x3d	; 61
    4cc6:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4cc8:	19 82       	std	Y+1, r1	; 0x01
    4cca:	13 c0       	rjmp	.+38     	; 0x4cf2 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4ccc:	89 81       	ldd	r24, Y+1	; 0x01
    4cce:	28 2f       	mov	r18, r24
    4cd0:	30 e0       	ldi	r19, 0x00	; 0
    4cd2:	c9 01       	movw	r24, r18
    4cd4:	88 0f       	add	r24, r24
    4cd6:	99 1f       	adc	r25, r25
    4cd8:	88 0f       	add	r24, r24
    4cda:	99 1f       	adc	r25, r25
    4cdc:	88 0f       	add	r24, r24
    4cde:	99 1f       	adc	r25, r25
    4ce0:	82 0f       	add	r24, r18
    4ce2:	93 1f       	adc	r25, r19
    4ce4:	85 54       	subi	r24, 0x45	; 69
    4ce6:	9b 4f       	sbci	r25, 0xFB	; 251
    4ce8:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4cec:	89 81       	ldd	r24, Y+1	; 0x01
    4cee:	8f 5f       	subi	r24, 0xFF	; 255
    4cf0:	89 83       	std	Y+1, r24	; 0x01
    4cf2:	89 81       	ldd	r24, Y+1	; 0x01
    4cf4:	85 30       	cpi	r24, 0x05	; 5
    4cf6:	50 f3       	brcs	.-44     	; 0x4ccc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4cf8:	88 ee       	ldi	r24, 0xE8	; 232
    4cfa:	94 e0       	ldi	r25, 0x04	; 4
    4cfc:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4d00:	81 ef       	ldi	r24, 0xF1	; 241
    4d02:	94 e0       	ldi	r25, 0x04	; 4
    4d04:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4d08:	8e ef       	ldi	r24, 0xFE	; 254
    4d0a:	94 e0       	ldi	r25, 0x04	; 4
    4d0c:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4d10:	87 e0       	ldi	r24, 0x07	; 7
    4d12:	95 e0       	ldi	r25, 0x05	; 5
    4d14:	0e 94 00 17 	call	0x2e00	; 0x2e00 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4d18:	88 ee       	ldi	r24, 0xE8	; 232
    4d1a:	94 e0       	ldi	r25, 0x04	; 4
    4d1c:	90 93 fb 04 	sts	0x04FB, r25
    4d20:	80 93 fa 04 	sts	0x04FA, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4d24:	81 ef       	ldi	r24, 0xF1	; 241
    4d26:	94 e0       	ldi	r25, 0x04	; 4
    4d28:	90 93 fd 04 	sts	0x04FD, r25
    4d2c:	80 93 fc 04 	sts	0x04FC, r24
}
    4d30:	0f 90       	pop	r0
    4d32:	cf 91       	pop	r28
    4d34:	df 91       	pop	r29
    4d36:	08 95       	ret

00004d38 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4d38:	df 93       	push	r29
    4d3a:	cf 93       	push	r28
    4d3c:	00 d0       	rcall	.+0      	; 0x4d3e <prvCheckTasksWaitingTermination+0x6>
    4d3e:	0f 92       	push	r0
    4d40:	cd b7       	in	r28, 0x3d	; 61
    4d42:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4d44:	80 91 af 04 	lds	r24, 0x04AF
    4d48:	88 23       	and	r24, r24
    4d4a:	71 f1       	breq	.+92     	; 0x4da8 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    4d4c:	0e 94 da 22 	call	0x45b4	; 0x45b4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4d50:	80 91 07 05 	lds	r24, 0x0507
    4d54:	1b 82       	std	Y+3, r1	; 0x03
    4d56:	88 23       	and	r24, r24
    4d58:	11 f4       	brne	.+4      	; 0x4d5e <prvCheckTasksWaitingTermination+0x26>
    4d5a:	81 e0       	ldi	r24, 0x01	; 1
    4d5c:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    4d5e:	0e 94 e6 22 	call	0x45cc	; 0x45cc <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4d62:	8b 81       	ldd	r24, Y+3	; 0x03
    4d64:	88 23       	and	r24, r24
    4d66:	01 f5       	brne	.+64     	; 0x4da8 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4d68:	0f b6       	in	r0, 0x3f	; 63
    4d6a:	f8 94       	cli
    4d6c:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4d6e:	e0 91 0c 05 	lds	r30, 0x050C
    4d72:	f0 91 0d 05 	lds	r31, 0x050D
    4d76:	86 81       	ldd	r24, Z+6	; 0x06
    4d78:	97 81       	ldd	r25, Z+7	; 0x07
    4d7a:	9a 83       	std	Y+2, r25	; 0x02
    4d7c:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4d7e:	89 81       	ldd	r24, Y+1	; 0x01
    4d80:	9a 81       	ldd	r25, Y+2	; 0x02
    4d82:	02 96       	adiw	r24, 0x02	; 2
    4d84:	0e 94 f2 17 	call	0x2fe4	; 0x2fe4 <vListRemove>
					--uxCurrentNumberOfTasks;
    4d88:	80 91 b0 04 	lds	r24, 0x04B0
    4d8c:	81 50       	subi	r24, 0x01	; 1
    4d8e:	80 93 b0 04 	sts	0x04B0, r24
					--uxTasksDeleted;
    4d92:	80 91 af 04 	lds	r24, 0x04AF
    4d96:	81 50       	subi	r24, 0x01	; 1
    4d98:	80 93 af 04 	sts	0x04AF, r24
				}
				taskEXIT_CRITICAL();
    4d9c:	0f 90       	pop	r0
    4d9e:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4da0:	89 81       	ldd	r24, Y+1	; 0x01
    4da2:	9a 81       	ldd	r25, Y+2	; 0x02
    4da4:	0e 94 73 27 	call	0x4ee6	; 0x4ee6 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    4da8:	0f 90       	pop	r0
    4daa:	0f 90       	pop	r0
    4dac:	0f 90       	pop	r0
    4dae:	cf 91       	pop	r28
    4db0:	df 91       	pop	r29
    4db2:	08 95       	ret

00004db4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    4db4:	df 93       	push	r29
    4db6:	cf 93       	push	r28
    4db8:	00 d0       	rcall	.+0      	; 0x4dba <prvAddCurrentTaskToDelayedList+0x6>
    4dba:	cd b7       	in	r28, 0x3d	; 61
    4dbc:	de b7       	in	r29, 0x3e	; 62
    4dbe:	9a 83       	std	Y+2, r25	; 0x02
    4dc0:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4dc2:	e0 91 ad 04 	lds	r30, 0x04AD
    4dc6:	f0 91 ae 04 	lds	r31, 0x04AE
    4dca:	89 81       	ldd	r24, Y+1	; 0x01
    4dcc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dce:	93 83       	std	Z+3, r25	; 0x03
    4dd0:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4dd2:	20 91 b1 04 	lds	r18, 0x04B1
    4dd6:	30 91 b2 04 	lds	r19, 0x04B2
    4dda:	89 81       	ldd	r24, Y+1	; 0x01
    4ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dde:	82 17       	cp	r24, r18
    4de0:	93 07       	cpc	r25, r19
    4de2:	70 f4       	brcc	.+28     	; 0x4e00 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4de4:	80 91 fc 04 	lds	r24, 0x04FC
    4de8:	90 91 fd 04 	lds	r25, 0x04FD
    4dec:	20 91 ad 04 	lds	r18, 0x04AD
    4df0:	30 91 ae 04 	lds	r19, 0x04AE
    4df4:	2e 5f       	subi	r18, 0xFE	; 254
    4df6:	3f 4f       	sbci	r19, 0xFF	; 255
    4df8:	b9 01       	movw	r22, r18
    4dfa:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <vListInsert>
    4dfe:	1e c0       	rjmp	.+60     	; 0x4e3c <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4e00:	40 91 fa 04 	lds	r20, 0x04FA
    4e04:	50 91 fb 04 	lds	r21, 0x04FB
    4e08:	80 91 ad 04 	lds	r24, 0x04AD
    4e0c:	90 91 ae 04 	lds	r25, 0x04AE
    4e10:	9c 01       	movw	r18, r24
    4e12:	2e 5f       	subi	r18, 0xFE	; 254
    4e14:	3f 4f       	sbci	r19, 0xFF	; 255
    4e16:	ca 01       	movw	r24, r20
    4e18:	b9 01       	movw	r22, r18
    4e1a:	0e 94 86 17 	call	0x2f0c	; 0x2f0c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    4e1e:	20 91 83 00 	lds	r18, 0x0083
    4e22:	30 91 84 00 	lds	r19, 0x0084
    4e26:	89 81       	ldd	r24, Y+1	; 0x01
    4e28:	9a 81       	ldd	r25, Y+2	; 0x02
    4e2a:	82 17       	cp	r24, r18
    4e2c:	93 07       	cpc	r25, r19
    4e2e:	30 f4       	brcc	.+12     	; 0x4e3c <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    4e30:	89 81       	ldd	r24, Y+1	; 0x01
    4e32:	9a 81       	ldd	r25, Y+2	; 0x02
    4e34:	90 93 84 00 	sts	0x0084, r25
    4e38:	80 93 83 00 	sts	0x0083, r24
		}
	}
}
    4e3c:	0f 90       	pop	r0
    4e3e:	0f 90       	pop	r0
    4e40:	cf 91       	pop	r28
    4e42:	df 91       	pop	r29
    4e44:	08 95       	ret

00004e46 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    4e46:	df 93       	push	r29
    4e48:	cf 93       	push	r28
    4e4a:	cd b7       	in	r28, 0x3d	; 61
    4e4c:	de b7       	in	r29, 0x3e	; 62
    4e4e:	28 97       	sbiw	r28, 0x08	; 8
    4e50:	0f b6       	in	r0, 0x3f	; 63
    4e52:	f8 94       	cli
    4e54:	de bf       	out	0x3e, r29	; 62
    4e56:	0f be       	out	0x3f, r0	; 63
    4e58:	cd bf       	out	0x3d, r28	; 61
    4e5a:	9c 83       	std	Y+4, r25	; 0x04
    4e5c:	8b 83       	std	Y+3, r24	; 0x03
    4e5e:	7e 83       	std	Y+6, r23	; 0x06
    4e60:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    4e62:	81 e2       	ldi	r24, 0x21	; 33
    4e64:	90 e0       	ldi	r25, 0x00	; 0
    4e66:	0e 94 94 16 	call	0x2d28	; 0x2d28 <pvPortMalloc>
    4e6a:	9a 83       	std	Y+2, r25	; 0x02
    4e6c:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4e6e:	89 81       	ldd	r24, Y+1	; 0x01
    4e70:	9a 81       	ldd	r25, Y+2	; 0x02
    4e72:	00 97       	sbiw	r24, 0x00	; 0
    4e74:	69 f1       	breq	.+90     	; 0x4ed0 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    4e76:	8d 81       	ldd	r24, Y+5	; 0x05
    4e78:	9e 81       	ldd	r25, Y+6	; 0x06
    4e7a:	00 97       	sbiw	r24, 0x00	; 0
    4e7c:	39 f4       	brne	.+14     	; 0x4e8c <prvAllocateTCBAndStack+0x46>
    4e7e:	8b 81       	ldd	r24, Y+3	; 0x03
    4e80:	9c 81       	ldd	r25, Y+4	; 0x04
    4e82:	0e 94 94 16 	call	0x2d28	; 0x2d28 <pvPortMalloc>
    4e86:	98 87       	std	Y+8, r25	; 0x08
    4e88:	8f 83       	std	Y+7, r24	; 0x07
    4e8a:	04 c0       	rjmp	.+8      	; 0x4e94 <prvAllocateTCBAndStack+0x4e>
    4e8c:	8d 81       	ldd	r24, Y+5	; 0x05
    4e8e:	9e 81       	ldd	r25, Y+6	; 0x06
    4e90:	98 87       	std	Y+8, r25	; 0x08
    4e92:	8f 83       	std	Y+7, r24	; 0x07
    4e94:	e9 81       	ldd	r30, Y+1	; 0x01
    4e96:	fa 81       	ldd	r31, Y+2	; 0x02
    4e98:	8f 81       	ldd	r24, Y+7	; 0x07
    4e9a:	98 85       	ldd	r25, Y+8	; 0x08
    4e9c:	90 8f       	std	Z+24, r25	; 0x18
    4e9e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    4ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    4ea4:	87 89       	ldd	r24, Z+23	; 0x17
    4ea6:	90 8d       	ldd	r25, Z+24	; 0x18
    4ea8:	00 97       	sbiw	r24, 0x00	; 0
    4eaa:	39 f4       	brne	.+14     	; 0x4eba <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4eac:	89 81       	ldd	r24, Y+1	; 0x01
    4eae:	9a 81       	ldd	r25, Y+2	; 0x02
    4eb0:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortFree>
			pxNewTCB = NULL;
    4eb4:	1a 82       	std	Y+2, r1	; 0x02
    4eb6:	19 82       	std	Y+1, r1	; 0x01
    4eb8:	0b c0       	rjmp	.+22     	; 0x4ed0 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4eba:	e9 81       	ldd	r30, Y+1	; 0x01
    4ebc:	fa 81       	ldd	r31, Y+2	; 0x02
    4ebe:	87 89       	ldd	r24, Z+23	; 0x17
    4ec0:	90 8d       	ldd	r25, Z+24	; 0x18
    4ec2:	2b 81       	ldd	r18, Y+3	; 0x03
    4ec4:	3c 81       	ldd	r19, Y+4	; 0x04
    4ec6:	65 ea       	ldi	r22, 0xA5	; 165
    4ec8:	70 e0       	ldi	r23, 0x00	; 0
    4eca:	a9 01       	movw	r20, r18
    4ecc:	0e 94 eb 27 	call	0x4fd6	; 0x4fd6 <memset>
		}
	}

	return pxNewTCB;
    4ed0:	89 81       	ldd	r24, Y+1	; 0x01
    4ed2:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4ed4:	28 96       	adiw	r28, 0x08	; 8
    4ed6:	0f b6       	in	r0, 0x3f	; 63
    4ed8:	f8 94       	cli
    4eda:	de bf       	out	0x3e, r29	; 62
    4edc:	0f be       	out	0x3f, r0	; 63
    4ede:	cd bf       	out	0x3d, r28	; 61
    4ee0:	cf 91       	pop	r28
    4ee2:	df 91       	pop	r29
    4ee4:	08 95       	ret

00004ee6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    4ee6:	df 93       	push	r29
    4ee8:	cf 93       	push	r28
    4eea:	00 d0       	rcall	.+0      	; 0x4eec <prvDeleteTCB+0x6>
    4eec:	cd b7       	in	r28, 0x3d	; 61
    4eee:	de b7       	in	r29, 0x3e	; 62
    4ef0:	9a 83       	std	Y+2, r25	; 0x02
    4ef2:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    4ef4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ef6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ef8:	87 89       	ldd	r24, Z+23	; 0x17
    4efa:	90 8d       	ldd	r25, Z+24	; 0x18
    4efc:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortFree>
		vPortFree( pxTCB );
    4f00:	89 81       	ldd	r24, Y+1	; 0x01
    4f02:	9a 81       	ldd	r25, Y+2	; 0x02
    4f04:	0e 94 da 16 	call	0x2db4	; 0x2db4 <vPortFree>
	}
    4f08:	0f 90       	pop	r0
    4f0a:	0f 90       	pop	r0
    4f0c:	cf 91       	pop	r28
    4f0e:	df 91       	pop	r29
    4f10:	08 95       	ret

00004f12 <__udivmodsi4>:
    4f12:	a1 e2       	ldi	r26, 0x21	; 33
    4f14:	1a 2e       	mov	r1, r26
    4f16:	aa 1b       	sub	r26, r26
    4f18:	bb 1b       	sub	r27, r27
    4f1a:	fd 01       	movw	r30, r26
    4f1c:	0d c0       	rjmp	.+26     	; 0x4f38 <__udivmodsi4_ep>

00004f1e <__udivmodsi4_loop>:
    4f1e:	aa 1f       	adc	r26, r26
    4f20:	bb 1f       	adc	r27, r27
    4f22:	ee 1f       	adc	r30, r30
    4f24:	ff 1f       	adc	r31, r31
    4f26:	a2 17       	cp	r26, r18
    4f28:	b3 07       	cpc	r27, r19
    4f2a:	e4 07       	cpc	r30, r20
    4f2c:	f5 07       	cpc	r31, r21
    4f2e:	20 f0       	brcs	.+8      	; 0x4f38 <__udivmodsi4_ep>
    4f30:	a2 1b       	sub	r26, r18
    4f32:	b3 0b       	sbc	r27, r19
    4f34:	e4 0b       	sbc	r30, r20
    4f36:	f5 0b       	sbc	r31, r21

00004f38 <__udivmodsi4_ep>:
    4f38:	66 1f       	adc	r22, r22
    4f3a:	77 1f       	adc	r23, r23
    4f3c:	88 1f       	adc	r24, r24
    4f3e:	99 1f       	adc	r25, r25
    4f40:	1a 94       	dec	r1
    4f42:	69 f7       	brne	.-38     	; 0x4f1e <__udivmodsi4_loop>
    4f44:	60 95       	com	r22
    4f46:	70 95       	com	r23
    4f48:	80 95       	com	r24
    4f4a:	90 95       	com	r25
    4f4c:	9b 01       	movw	r18, r22
    4f4e:	ac 01       	movw	r20, r24
    4f50:	bd 01       	movw	r22, r26
    4f52:	cf 01       	movw	r24, r30
    4f54:	08 95       	ret

00004f56 <__prologue_saves__>:
    4f56:	2f 92       	push	r2
    4f58:	3f 92       	push	r3
    4f5a:	4f 92       	push	r4
    4f5c:	5f 92       	push	r5
    4f5e:	6f 92       	push	r6
    4f60:	7f 92       	push	r7
    4f62:	8f 92       	push	r8
    4f64:	9f 92       	push	r9
    4f66:	af 92       	push	r10
    4f68:	bf 92       	push	r11
    4f6a:	cf 92       	push	r12
    4f6c:	df 92       	push	r13
    4f6e:	ef 92       	push	r14
    4f70:	ff 92       	push	r15
    4f72:	0f 93       	push	r16
    4f74:	1f 93       	push	r17
    4f76:	cf 93       	push	r28
    4f78:	df 93       	push	r29
    4f7a:	cd b7       	in	r28, 0x3d	; 61
    4f7c:	de b7       	in	r29, 0x3e	; 62
    4f7e:	ca 1b       	sub	r28, r26
    4f80:	db 0b       	sbc	r29, r27
    4f82:	0f b6       	in	r0, 0x3f	; 63
    4f84:	f8 94       	cli
    4f86:	de bf       	out	0x3e, r29	; 62
    4f88:	0f be       	out	0x3f, r0	; 63
    4f8a:	cd bf       	out	0x3d, r28	; 61
    4f8c:	09 94       	ijmp

00004f8e <__epilogue_restores__>:
    4f8e:	2a 88       	ldd	r2, Y+18	; 0x12
    4f90:	39 88       	ldd	r3, Y+17	; 0x11
    4f92:	48 88       	ldd	r4, Y+16	; 0x10
    4f94:	5f 84       	ldd	r5, Y+15	; 0x0f
    4f96:	6e 84       	ldd	r6, Y+14	; 0x0e
    4f98:	7d 84       	ldd	r7, Y+13	; 0x0d
    4f9a:	8c 84       	ldd	r8, Y+12	; 0x0c
    4f9c:	9b 84       	ldd	r9, Y+11	; 0x0b
    4f9e:	aa 84       	ldd	r10, Y+10	; 0x0a
    4fa0:	b9 84       	ldd	r11, Y+9	; 0x09
    4fa2:	c8 84       	ldd	r12, Y+8	; 0x08
    4fa4:	df 80       	ldd	r13, Y+7	; 0x07
    4fa6:	ee 80       	ldd	r14, Y+6	; 0x06
    4fa8:	fd 80       	ldd	r15, Y+5	; 0x05
    4faa:	0c 81       	ldd	r16, Y+4	; 0x04
    4fac:	1b 81       	ldd	r17, Y+3	; 0x03
    4fae:	aa 81       	ldd	r26, Y+2	; 0x02
    4fb0:	b9 81       	ldd	r27, Y+1	; 0x01
    4fb2:	ce 0f       	add	r28, r30
    4fb4:	d1 1d       	adc	r29, r1
    4fb6:	0f b6       	in	r0, 0x3f	; 63
    4fb8:	f8 94       	cli
    4fba:	de bf       	out	0x3e, r29	; 62
    4fbc:	0f be       	out	0x3f, r0	; 63
    4fbe:	cd bf       	out	0x3d, r28	; 61
    4fc0:	ed 01       	movw	r28, r26
    4fc2:	08 95       	ret

00004fc4 <memcpy>:
    4fc4:	fb 01       	movw	r30, r22
    4fc6:	dc 01       	movw	r26, r24
    4fc8:	02 c0       	rjmp	.+4      	; 0x4fce <memcpy+0xa>
    4fca:	01 90       	ld	r0, Z+
    4fcc:	0d 92       	st	X+, r0
    4fce:	41 50       	subi	r20, 0x01	; 1
    4fd0:	50 40       	sbci	r21, 0x00	; 0
    4fd2:	d8 f7       	brcc	.-10     	; 0x4fca <memcpy+0x6>
    4fd4:	08 95       	ret

00004fd6 <memset>:
    4fd6:	dc 01       	movw	r26, r24
    4fd8:	01 c0       	rjmp	.+2      	; 0x4fdc <memset+0x6>
    4fda:	6d 93       	st	X+, r22
    4fdc:	41 50       	subi	r20, 0x01	; 1
    4fde:	50 40       	sbci	r21, 0x00	; 0
    4fe0:	e0 f7       	brcc	.-8      	; 0x4fda <memset+0x4>
    4fe2:	08 95       	ret

00004fe4 <strncpy>:
    4fe4:	fb 01       	movw	r30, r22
    4fe6:	dc 01       	movw	r26, r24
    4fe8:	41 50       	subi	r20, 0x01	; 1
    4fea:	50 40       	sbci	r21, 0x00	; 0
    4fec:	48 f0       	brcs	.+18     	; 0x5000 <strncpy+0x1c>
    4fee:	01 90       	ld	r0, Z+
    4ff0:	0d 92       	st	X+, r0
    4ff2:	00 20       	and	r0, r0
    4ff4:	c9 f7       	brne	.-14     	; 0x4fe8 <strncpy+0x4>
    4ff6:	01 c0       	rjmp	.+2      	; 0x4ffa <strncpy+0x16>
    4ff8:	1d 92       	st	X+, r1
    4ffa:	41 50       	subi	r20, 0x01	; 1
    4ffc:	50 40       	sbci	r21, 0x00	; 0
    4ffe:	e0 f7       	brcc	.-8      	; 0x4ff8 <strncpy+0x14>
    5000:	08 95       	ret

00005002 <_exit>:
    5002:	f8 94       	cli

00005004 <__stop_program>:
    5004:	ff cf       	rjmp	.-2      	; 0x5004 <__stop_program>
